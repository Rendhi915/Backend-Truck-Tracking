
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model FleetGroup
 * 
 */
export type FleetGroup = $Result.DefaultSelection<Prisma.$FleetGroupPayload>
/**
 * Model Truck
 * 
 */
export type Truck = $Result.DefaultSelection<Prisma.$TruckPayload>
/**
 * Model Device
 * 
 */
export type Device = $Result.DefaultSelection<Prisma.$DevicePayload>
/**
 * Model Sensor
 * 
 */
export type Sensor = $Result.DefaultSelection<Prisma.$SensorPayload>
/**
 * Model TruckStatusEvent
 * 
 */
export type TruckStatusEvent = $Result.DefaultSelection<Prisma.$TruckStatusEventPayload>
/**
 * Model Geofence
 * 
 */
export type Geofence = $Result.DefaultSelection<Prisma.$GeofencePayload>
/**
 * Model GpsPosition
 * 
 */
export type GpsPosition = $Result.DefaultSelection<Prisma.$GpsPositionPayload>
/**
 * Model Trip
 * 
 */
export type Trip = $Result.DefaultSelection<Prisma.$TripPayload>
/**
 * Model TirePressureEvent
 * 
 */
export type TirePressureEvent = $Result.DefaultSelection<Prisma.$TirePressureEventPayload>
/**
 * Model TireErrorCode
 * 
 */
export type TireErrorCode = $Result.DefaultSelection<Prisma.$TireErrorCodePayload>
/**
 * Model HubTemperatureEvent
 * 
 */
export type HubTemperatureEvent = $Result.DefaultSelection<Prisma.$HubTemperatureEventPayload>
/**
 * Model FuelLevelEvent
 * 
 */
export type FuelLevelEvent = $Result.DefaultSelection<Prisma.$FuelLevelEventPayload>
/**
 * Model SpeedEvent
 * 
 */
export type SpeedEvent = $Result.DefaultSelection<Prisma.$SpeedEventPayload>
/**
 * Model AlertEvent
 * 
 */
export type AlertEvent = $Result.DefaultSelection<Prisma.$AlertEventPayload>
/**
 * Model DeviceStatusEvent
 * 
 */
export type DeviceStatusEvent = $Result.DefaultSelection<Prisma.$DeviceStatusEventPayload>
/**
 * Model LockEvent
 * 
 */
export type LockEvent = $Result.DefaultSelection<Prisma.$LockEventPayload>
/**
 * Model DailyRoute
 * 
 */
export type DailyRoute = $Result.DefaultSelection<Prisma.$DailyRoutePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TruckStatus: {
  active: 'active',
  inactive: 'inactive',
  maintenance: 'maintenance'
};

export type TruckStatus = (typeof TruckStatus)[keyof typeof TruckStatus]


export const AlertType: {
  LOW_TIRE: 'LOW_TIRE',
  SPEEDING: 'SPEEDING',
  IDLE: 'IDLE',
  GEOFENCE_IN: 'GEOFENCE_IN',
  GEOFENCE_OUT: 'GEOFENCE_OUT',
  FUEL_DROP: 'FUEL_DROP',
  HIGH_TEMP: 'HIGH_TEMP',
  DEVICE_LOST: 'DEVICE_LOST'
};

export type AlertType = (typeof AlertType)[keyof typeof AlertType]

}

export type TruckStatus = $Enums.TruckStatus

export const TruckStatus: typeof $Enums.TruckStatus

export type AlertType = $Enums.AlertType

export const AlertType: typeof $Enums.AlertType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more FleetGroups
 * const fleetGroups = await prisma.fleetGroup.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more FleetGroups
   * const fleetGroups = await prisma.fleetGroup.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.fleetGroup`: Exposes CRUD operations for the **FleetGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FleetGroups
    * const fleetGroups = await prisma.fleetGroup.findMany()
    * ```
    */
  get fleetGroup(): Prisma.FleetGroupDelegate<ExtArgs>;

  /**
   * `prisma.truck`: Exposes CRUD operations for the **Truck** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trucks
    * const trucks = await prisma.truck.findMany()
    * ```
    */
  get truck(): Prisma.TruckDelegate<ExtArgs>;

  /**
   * `prisma.device`: Exposes CRUD operations for the **Device** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Devices
    * const devices = await prisma.device.findMany()
    * ```
    */
  get device(): Prisma.DeviceDelegate<ExtArgs>;

  /**
   * `prisma.sensor`: Exposes CRUD operations for the **Sensor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sensors
    * const sensors = await prisma.sensor.findMany()
    * ```
    */
  get sensor(): Prisma.SensorDelegate<ExtArgs>;

  /**
   * `prisma.truckStatusEvent`: Exposes CRUD operations for the **TruckStatusEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TruckStatusEvents
    * const truckStatusEvents = await prisma.truckStatusEvent.findMany()
    * ```
    */
  get truckStatusEvent(): Prisma.TruckStatusEventDelegate<ExtArgs>;

  /**
   * `prisma.geofence`: Exposes CRUD operations for the **Geofence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Geofences
    * const geofences = await prisma.geofence.findMany()
    * ```
    */
  get geofence(): Prisma.GeofenceDelegate<ExtArgs>;

  /**
   * `prisma.gpsPosition`: Exposes CRUD operations for the **GpsPosition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GpsPositions
    * const gpsPositions = await prisma.gpsPosition.findMany()
    * ```
    */
  get gpsPosition(): Prisma.GpsPositionDelegate<ExtArgs>;

  /**
   * `prisma.trip`: Exposes CRUD operations for the **Trip** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trips
    * const trips = await prisma.trip.findMany()
    * ```
    */
  get trip(): Prisma.TripDelegate<ExtArgs>;

  /**
   * `prisma.tirePressureEvent`: Exposes CRUD operations for the **TirePressureEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TirePressureEvents
    * const tirePressureEvents = await prisma.tirePressureEvent.findMany()
    * ```
    */
  get tirePressureEvent(): Prisma.TirePressureEventDelegate<ExtArgs>;

  /**
   * `prisma.tireErrorCode`: Exposes CRUD operations for the **TireErrorCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TireErrorCodes
    * const tireErrorCodes = await prisma.tireErrorCode.findMany()
    * ```
    */
  get tireErrorCode(): Prisma.TireErrorCodeDelegate<ExtArgs>;

  /**
   * `prisma.hubTemperatureEvent`: Exposes CRUD operations for the **HubTemperatureEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HubTemperatureEvents
    * const hubTemperatureEvents = await prisma.hubTemperatureEvent.findMany()
    * ```
    */
  get hubTemperatureEvent(): Prisma.HubTemperatureEventDelegate<ExtArgs>;

  /**
   * `prisma.fuelLevelEvent`: Exposes CRUD operations for the **FuelLevelEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FuelLevelEvents
    * const fuelLevelEvents = await prisma.fuelLevelEvent.findMany()
    * ```
    */
  get fuelLevelEvent(): Prisma.FuelLevelEventDelegate<ExtArgs>;

  /**
   * `prisma.speedEvent`: Exposes CRUD operations for the **SpeedEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpeedEvents
    * const speedEvents = await prisma.speedEvent.findMany()
    * ```
    */
  get speedEvent(): Prisma.SpeedEventDelegate<ExtArgs>;

  /**
   * `prisma.alertEvent`: Exposes CRUD operations for the **AlertEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AlertEvents
    * const alertEvents = await prisma.alertEvent.findMany()
    * ```
    */
  get alertEvent(): Prisma.AlertEventDelegate<ExtArgs>;

  /**
   * `prisma.deviceStatusEvent`: Exposes CRUD operations for the **DeviceStatusEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceStatusEvents
    * const deviceStatusEvents = await prisma.deviceStatusEvent.findMany()
    * ```
    */
  get deviceStatusEvent(): Prisma.DeviceStatusEventDelegate<ExtArgs>;

  /**
   * `prisma.lockEvent`: Exposes CRUD operations for the **LockEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LockEvents
    * const lockEvents = await prisma.lockEvent.findMany()
    * ```
    */
  get lockEvent(): Prisma.LockEventDelegate<ExtArgs>;

  /**
   * `prisma.dailyRoute`: Exposes CRUD operations for the **DailyRoute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyRoutes
    * const dailyRoutes = await prisma.dailyRoute.findMany()
    * ```
    */
  get dailyRoute(): Prisma.DailyRouteDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    FleetGroup: 'FleetGroup',
    Truck: 'Truck',
    Device: 'Device',
    Sensor: 'Sensor',
    TruckStatusEvent: 'TruckStatusEvent',
    Geofence: 'Geofence',
    GpsPosition: 'GpsPosition',
    Trip: 'Trip',
    TirePressureEvent: 'TirePressureEvent',
    TireErrorCode: 'TireErrorCode',
    HubTemperatureEvent: 'HubTemperatureEvent',
    FuelLevelEvent: 'FuelLevelEvent',
    SpeedEvent: 'SpeedEvent',
    AlertEvent: 'AlertEvent',
    DeviceStatusEvent: 'DeviceStatusEvent',
    LockEvent: 'LockEvent',
    DailyRoute: 'DailyRoute'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "fleetGroup" | "truck" | "device" | "sensor" | "truckStatusEvent" | "geofence" | "gpsPosition" | "trip" | "tirePressureEvent" | "tireErrorCode" | "hubTemperatureEvent" | "fuelLevelEvent" | "speedEvent" | "alertEvent" | "deviceStatusEvent" | "lockEvent" | "dailyRoute"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      FleetGroup: {
        payload: Prisma.$FleetGroupPayload<ExtArgs>
        fields: Prisma.FleetGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FleetGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FleetGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FleetGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FleetGroupPayload>
          }
          findFirst: {
            args: Prisma.FleetGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FleetGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FleetGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FleetGroupPayload>
          }
          findMany: {
            args: Prisma.FleetGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FleetGroupPayload>[]
          }
          create: {
            args: Prisma.FleetGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FleetGroupPayload>
          }
          createMany: {
            args: Prisma.FleetGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FleetGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FleetGroupPayload>[]
          }
          delete: {
            args: Prisma.FleetGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FleetGroupPayload>
          }
          update: {
            args: Prisma.FleetGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FleetGroupPayload>
          }
          deleteMany: {
            args: Prisma.FleetGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FleetGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FleetGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FleetGroupPayload>
          }
          aggregate: {
            args: Prisma.FleetGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFleetGroup>
          }
          groupBy: {
            args: Prisma.FleetGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<FleetGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.FleetGroupCountArgs<ExtArgs>
            result: $Utils.Optional<FleetGroupCountAggregateOutputType> | number
          }
        }
      }
      Truck: {
        payload: Prisma.$TruckPayload<ExtArgs>
        fields: Prisma.TruckFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TruckFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TruckFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckPayload>
          }
          findFirst: {
            args: Prisma.TruckFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TruckFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckPayload>
          }
          findMany: {
            args: Prisma.TruckFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckPayload>[]
          }
          create: {
            args: Prisma.TruckCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckPayload>
          }
          createMany: {
            args: Prisma.TruckCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TruckCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckPayload>[]
          }
          delete: {
            args: Prisma.TruckDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckPayload>
          }
          update: {
            args: Prisma.TruckUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckPayload>
          }
          deleteMany: {
            args: Prisma.TruckDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TruckUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TruckUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckPayload>
          }
          aggregate: {
            args: Prisma.TruckAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTruck>
          }
          groupBy: {
            args: Prisma.TruckGroupByArgs<ExtArgs>
            result: $Utils.Optional<TruckGroupByOutputType>[]
          }
          count: {
            args: Prisma.TruckCountArgs<ExtArgs>
            result: $Utils.Optional<TruckCountAggregateOutputType> | number
          }
        }
      }
      Device: {
        payload: Prisma.$DevicePayload<ExtArgs>
        fields: Prisma.DeviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          findFirst: {
            args: Prisma.DeviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          findMany: {
            args: Prisma.DeviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          create: {
            args: Prisma.DeviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          createMany: {
            args: Prisma.DeviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          delete: {
            args: Prisma.DeviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          update: {
            args: Prisma.DeviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          deleteMany: {
            args: Prisma.DeviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          aggregate: {
            args: Prisma.DeviceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDevice>
          }
          groupBy: {
            args: Prisma.DeviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceCountAggregateOutputType> | number
          }
        }
      }
      Sensor: {
        payload: Prisma.$SensorPayload<ExtArgs>
        fields: Prisma.SensorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SensorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SensorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>
          }
          findFirst: {
            args: Prisma.SensorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SensorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>
          }
          findMany: {
            args: Prisma.SensorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>[]
          }
          create: {
            args: Prisma.SensorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>
          }
          createMany: {
            args: Prisma.SensorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SensorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>[]
          }
          delete: {
            args: Prisma.SensorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>
          }
          update: {
            args: Prisma.SensorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>
          }
          deleteMany: {
            args: Prisma.SensorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SensorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SensorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>
          }
          aggregate: {
            args: Prisma.SensorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSensor>
          }
          groupBy: {
            args: Prisma.SensorGroupByArgs<ExtArgs>
            result: $Utils.Optional<SensorGroupByOutputType>[]
          }
          count: {
            args: Prisma.SensorCountArgs<ExtArgs>
            result: $Utils.Optional<SensorCountAggregateOutputType> | number
          }
        }
      }
      TruckStatusEvent: {
        payload: Prisma.$TruckStatusEventPayload<ExtArgs>
        fields: Prisma.TruckStatusEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TruckStatusEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckStatusEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TruckStatusEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckStatusEventPayload>
          }
          findFirst: {
            args: Prisma.TruckStatusEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckStatusEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TruckStatusEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckStatusEventPayload>
          }
          findMany: {
            args: Prisma.TruckStatusEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckStatusEventPayload>[]
          }
          create: {
            args: Prisma.TruckStatusEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckStatusEventPayload>
          }
          createMany: {
            args: Prisma.TruckStatusEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TruckStatusEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckStatusEventPayload>[]
          }
          delete: {
            args: Prisma.TruckStatusEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckStatusEventPayload>
          }
          update: {
            args: Prisma.TruckStatusEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckStatusEventPayload>
          }
          deleteMany: {
            args: Prisma.TruckStatusEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TruckStatusEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TruckStatusEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckStatusEventPayload>
          }
          aggregate: {
            args: Prisma.TruckStatusEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTruckStatusEvent>
          }
          groupBy: {
            args: Prisma.TruckStatusEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<TruckStatusEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.TruckStatusEventCountArgs<ExtArgs>
            result: $Utils.Optional<TruckStatusEventCountAggregateOutputType> | number
          }
        }
      }
      Geofence: {
        payload: Prisma.$GeofencePayload<ExtArgs>
        fields: Prisma.GeofenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GeofenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeofencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GeofenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeofencePayload>
          }
          findFirst: {
            args: Prisma.GeofenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeofencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GeofenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeofencePayload>
          }
          findMany: {
            args: Prisma.GeofenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeofencePayload>[]
          }
          create: {
            args: Prisma.GeofenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeofencePayload>
          }
          createMany: {
            args: Prisma.GeofenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GeofenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeofencePayload>[]
          }
          delete: {
            args: Prisma.GeofenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeofencePayload>
          }
          update: {
            args: Prisma.GeofenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeofencePayload>
          }
          deleteMany: {
            args: Prisma.GeofenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GeofenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GeofenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeofencePayload>
          }
          aggregate: {
            args: Prisma.GeofenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGeofence>
          }
          groupBy: {
            args: Prisma.GeofenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<GeofenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.GeofenceCountArgs<ExtArgs>
            result: $Utils.Optional<GeofenceCountAggregateOutputType> | number
          }
        }
      }
      GpsPosition: {
        payload: Prisma.$GpsPositionPayload<ExtArgs>
        fields: Prisma.GpsPositionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GpsPositionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GpsPositionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GpsPositionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GpsPositionPayload>
          }
          findFirst: {
            args: Prisma.GpsPositionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GpsPositionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GpsPositionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GpsPositionPayload>
          }
          findMany: {
            args: Prisma.GpsPositionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GpsPositionPayload>[]
          }
          create: {
            args: Prisma.GpsPositionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GpsPositionPayload>
          }
          createMany: {
            args: Prisma.GpsPositionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GpsPositionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GpsPositionPayload>[]
          }
          delete: {
            args: Prisma.GpsPositionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GpsPositionPayload>
          }
          update: {
            args: Prisma.GpsPositionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GpsPositionPayload>
          }
          deleteMany: {
            args: Prisma.GpsPositionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GpsPositionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GpsPositionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GpsPositionPayload>
          }
          aggregate: {
            args: Prisma.GpsPositionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGpsPosition>
          }
          groupBy: {
            args: Prisma.GpsPositionGroupByArgs<ExtArgs>
            result: $Utils.Optional<GpsPositionGroupByOutputType>[]
          }
          count: {
            args: Prisma.GpsPositionCountArgs<ExtArgs>
            result: $Utils.Optional<GpsPositionCountAggregateOutputType> | number
          }
        }
      }
      Trip: {
        payload: Prisma.$TripPayload<ExtArgs>
        fields: Prisma.TripFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TripFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TripFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          findFirst: {
            args: Prisma.TripFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TripFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          findMany: {
            args: Prisma.TripFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>[]
          }
          create: {
            args: Prisma.TripCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          createMany: {
            args: Prisma.TripCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TripCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>[]
          }
          delete: {
            args: Prisma.TripDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          update: {
            args: Prisma.TripUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          deleteMany: {
            args: Prisma.TripDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TripUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TripUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          aggregate: {
            args: Prisma.TripAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrip>
          }
          groupBy: {
            args: Prisma.TripGroupByArgs<ExtArgs>
            result: $Utils.Optional<TripGroupByOutputType>[]
          }
          count: {
            args: Prisma.TripCountArgs<ExtArgs>
            result: $Utils.Optional<TripCountAggregateOutputType> | number
          }
        }
      }
      TirePressureEvent: {
        payload: Prisma.$TirePressureEventPayload<ExtArgs>
        fields: Prisma.TirePressureEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TirePressureEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TirePressureEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TirePressureEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TirePressureEventPayload>
          }
          findFirst: {
            args: Prisma.TirePressureEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TirePressureEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TirePressureEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TirePressureEventPayload>
          }
          findMany: {
            args: Prisma.TirePressureEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TirePressureEventPayload>[]
          }
          create: {
            args: Prisma.TirePressureEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TirePressureEventPayload>
          }
          createMany: {
            args: Prisma.TirePressureEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TirePressureEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TirePressureEventPayload>[]
          }
          delete: {
            args: Prisma.TirePressureEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TirePressureEventPayload>
          }
          update: {
            args: Prisma.TirePressureEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TirePressureEventPayload>
          }
          deleteMany: {
            args: Prisma.TirePressureEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TirePressureEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TirePressureEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TirePressureEventPayload>
          }
          aggregate: {
            args: Prisma.TirePressureEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTirePressureEvent>
          }
          groupBy: {
            args: Prisma.TirePressureEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<TirePressureEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.TirePressureEventCountArgs<ExtArgs>
            result: $Utils.Optional<TirePressureEventCountAggregateOutputType> | number
          }
        }
      }
      TireErrorCode: {
        payload: Prisma.$TireErrorCodePayload<ExtArgs>
        fields: Prisma.TireErrorCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TireErrorCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TireErrorCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TireErrorCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TireErrorCodePayload>
          }
          findFirst: {
            args: Prisma.TireErrorCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TireErrorCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TireErrorCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TireErrorCodePayload>
          }
          findMany: {
            args: Prisma.TireErrorCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TireErrorCodePayload>[]
          }
          create: {
            args: Prisma.TireErrorCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TireErrorCodePayload>
          }
          createMany: {
            args: Prisma.TireErrorCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TireErrorCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TireErrorCodePayload>[]
          }
          delete: {
            args: Prisma.TireErrorCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TireErrorCodePayload>
          }
          update: {
            args: Prisma.TireErrorCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TireErrorCodePayload>
          }
          deleteMany: {
            args: Prisma.TireErrorCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TireErrorCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TireErrorCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TireErrorCodePayload>
          }
          aggregate: {
            args: Prisma.TireErrorCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTireErrorCode>
          }
          groupBy: {
            args: Prisma.TireErrorCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TireErrorCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.TireErrorCodeCountArgs<ExtArgs>
            result: $Utils.Optional<TireErrorCodeCountAggregateOutputType> | number
          }
        }
      }
      HubTemperatureEvent: {
        payload: Prisma.$HubTemperatureEventPayload<ExtArgs>
        fields: Prisma.HubTemperatureEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HubTemperatureEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HubTemperatureEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HubTemperatureEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HubTemperatureEventPayload>
          }
          findFirst: {
            args: Prisma.HubTemperatureEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HubTemperatureEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HubTemperatureEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HubTemperatureEventPayload>
          }
          findMany: {
            args: Prisma.HubTemperatureEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HubTemperatureEventPayload>[]
          }
          create: {
            args: Prisma.HubTemperatureEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HubTemperatureEventPayload>
          }
          createMany: {
            args: Prisma.HubTemperatureEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HubTemperatureEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HubTemperatureEventPayload>[]
          }
          delete: {
            args: Prisma.HubTemperatureEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HubTemperatureEventPayload>
          }
          update: {
            args: Prisma.HubTemperatureEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HubTemperatureEventPayload>
          }
          deleteMany: {
            args: Prisma.HubTemperatureEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HubTemperatureEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HubTemperatureEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HubTemperatureEventPayload>
          }
          aggregate: {
            args: Prisma.HubTemperatureEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHubTemperatureEvent>
          }
          groupBy: {
            args: Prisma.HubTemperatureEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<HubTemperatureEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.HubTemperatureEventCountArgs<ExtArgs>
            result: $Utils.Optional<HubTemperatureEventCountAggregateOutputType> | number
          }
        }
      }
      FuelLevelEvent: {
        payload: Prisma.$FuelLevelEventPayload<ExtArgs>
        fields: Prisma.FuelLevelEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FuelLevelEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FuelLevelEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FuelLevelEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FuelLevelEventPayload>
          }
          findFirst: {
            args: Prisma.FuelLevelEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FuelLevelEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FuelLevelEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FuelLevelEventPayload>
          }
          findMany: {
            args: Prisma.FuelLevelEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FuelLevelEventPayload>[]
          }
          create: {
            args: Prisma.FuelLevelEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FuelLevelEventPayload>
          }
          createMany: {
            args: Prisma.FuelLevelEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FuelLevelEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FuelLevelEventPayload>[]
          }
          delete: {
            args: Prisma.FuelLevelEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FuelLevelEventPayload>
          }
          update: {
            args: Prisma.FuelLevelEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FuelLevelEventPayload>
          }
          deleteMany: {
            args: Prisma.FuelLevelEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FuelLevelEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FuelLevelEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FuelLevelEventPayload>
          }
          aggregate: {
            args: Prisma.FuelLevelEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFuelLevelEvent>
          }
          groupBy: {
            args: Prisma.FuelLevelEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<FuelLevelEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.FuelLevelEventCountArgs<ExtArgs>
            result: $Utils.Optional<FuelLevelEventCountAggregateOutputType> | number
          }
        }
      }
      SpeedEvent: {
        payload: Prisma.$SpeedEventPayload<ExtArgs>
        fields: Prisma.SpeedEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpeedEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeedEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpeedEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeedEventPayload>
          }
          findFirst: {
            args: Prisma.SpeedEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeedEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpeedEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeedEventPayload>
          }
          findMany: {
            args: Prisma.SpeedEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeedEventPayload>[]
          }
          create: {
            args: Prisma.SpeedEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeedEventPayload>
          }
          createMany: {
            args: Prisma.SpeedEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpeedEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeedEventPayload>[]
          }
          delete: {
            args: Prisma.SpeedEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeedEventPayload>
          }
          update: {
            args: Prisma.SpeedEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeedEventPayload>
          }
          deleteMany: {
            args: Prisma.SpeedEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpeedEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpeedEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeedEventPayload>
          }
          aggregate: {
            args: Prisma.SpeedEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpeedEvent>
          }
          groupBy: {
            args: Prisma.SpeedEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpeedEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpeedEventCountArgs<ExtArgs>
            result: $Utils.Optional<SpeedEventCountAggregateOutputType> | number
          }
        }
      }
      AlertEvent: {
        payload: Prisma.$AlertEventPayload<ExtArgs>
        fields: Prisma.AlertEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlertEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload>
          }
          findFirst: {
            args: Prisma.AlertEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload>
          }
          findMany: {
            args: Prisma.AlertEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload>[]
          }
          create: {
            args: Prisma.AlertEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload>
          }
          createMany: {
            args: Prisma.AlertEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlertEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload>[]
          }
          delete: {
            args: Prisma.AlertEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload>
          }
          update: {
            args: Prisma.AlertEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload>
          }
          deleteMany: {
            args: Prisma.AlertEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlertEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AlertEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload>
          }
          aggregate: {
            args: Prisma.AlertEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlertEvent>
          }
          groupBy: {
            args: Prisma.AlertEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertEventCountArgs<ExtArgs>
            result: $Utils.Optional<AlertEventCountAggregateOutputType> | number
          }
        }
      }
      DeviceStatusEvent: {
        payload: Prisma.$DeviceStatusEventPayload<ExtArgs>
        fields: Prisma.DeviceStatusEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceStatusEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatusEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceStatusEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatusEventPayload>
          }
          findFirst: {
            args: Prisma.DeviceStatusEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatusEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceStatusEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatusEventPayload>
          }
          findMany: {
            args: Prisma.DeviceStatusEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatusEventPayload>[]
          }
          create: {
            args: Prisma.DeviceStatusEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatusEventPayload>
          }
          createMany: {
            args: Prisma.DeviceStatusEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceStatusEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatusEventPayload>[]
          }
          delete: {
            args: Prisma.DeviceStatusEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatusEventPayload>
          }
          update: {
            args: Prisma.DeviceStatusEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatusEventPayload>
          }
          deleteMany: {
            args: Prisma.DeviceStatusEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceStatusEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeviceStatusEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatusEventPayload>
          }
          aggregate: {
            args: Prisma.DeviceStatusEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceStatusEvent>
          }
          groupBy: {
            args: Prisma.DeviceStatusEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceStatusEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceStatusEventCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceStatusEventCountAggregateOutputType> | number
          }
        }
      }
      LockEvent: {
        payload: Prisma.$LockEventPayload<ExtArgs>
        fields: Prisma.LockEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LockEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LockEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockEventPayload>
          }
          findFirst: {
            args: Prisma.LockEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LockEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockEventPayload>
          }
          findMany: {
            args: Prisma.LockEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockEventPayload>[]
          }
          create: {
            args: Prisma.LockEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockEventPayload>
          }
          createMany: {
            args: Prisma.LockEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LockEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockEventPayload>[]
          }
          delete: {
            args: Prisma.LockEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockEventPayload>
          }
          update: {
            args: Prisma.LockEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockEventPayload>
          }
          deleteMany: {
            args: Prisma.LockEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LockEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LockEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LockEventPayload>
          }
          aggregate: {
            args: Prisma.LockEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLockEvent>
          }
          groupBy: {
            args: Prisma.LockEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<LockEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.LockEventCountArgs<ExtArgs>
            result: $Utils.Optional<LockEventCountAggregateOutputType> | number
          }
        }
      }
      DailyRoute: {
        payload: Prisma.$DailyRoutePayload<ExtArgs>
        fields: Prisma.DailyRouteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyRouteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRoutePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyRouteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRoutePayload>
          }
          findFirst: {
            args: Prisma.DailyRouteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRoutePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyRouteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRoutePayload>
          }
          findMany: {
            args: Prisma.DailyRouteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRoutePayload>[]
          }
          create: {
            args: Prisma.DailyRouteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRoutePayload>
          }
          createMany: {
            args: Prisma.DailyRouteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyRouteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRoutePayload>[]
          }
          delete: {
            args: Prisma.DailyRouteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRoutePayload>
          }
          update: {
            args: Prisma.DailyRouteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRoutePayload>
          }
          deleteMany: {
            args: Prisma.DailyRouteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyRouteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DailyRouteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRoutePayload>
          }
          aggregate: {
            args: Prisma.DailyRouteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyRoute>
          }
          groupBy: {
            args: Prisma.DailyRouteGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyRouteGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyRouteCountArgs<ExtArgs>
            result: $Utils.Optional<DailyRouteCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type FleetGroupCountOutputType
   */

  export type FleetGroupCountOutputType = {
    trucks: number
  }

  export type FleetGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trucks?: boolean | FleetGroupCountOutputTypeCountTrucksArgs
  }

  // Custom InputTypes
  /**
   * FleetGroupCountOutputType without action
   */
  export type FleetGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FleetGroupCountOutputType
     */
    select?: FleetGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FleetGroupCountOutputType without action
   */
  export type FleetGroupCountOutputTypeCountTrucksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TruckWhereInput
  }


  /**
   * Count Type TruckCountOutputType
   */

  export type TruckCountOutputType = {
    devices: number
    truckStatusEvents: number
    gpsPositions: number
    trips: number
    tirePressureEvents: number
    hubTemperatureEvents: number
    fuelLevelEvents: number
    speedEvents: number
    alertEvents: number
    deviceStatusEvents: number
    lockEvents: number
    dailyRoutes: number
  }

  export type TruckCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    devices?: boolean | TruckCountOutputTypeCountDevicesArgs
    truckStatusEvents?: boolean | TruckCountOutputTypeCountTruckStatusEventsArgs
    gpsPositions?: boolean | TruckCountOutputTypeCountGpsPositionsArgs
    trips?: boolean | TruckCountOutputTypeCountTripsArgs
    tirePressureEvents?: boolean | TruckCountOutputTypeCountTirePressureEventsArgs
    hubTemperatureEvents?: boolean | TruckCountOutputTypeCountHubTemperatureEventsArgs
    fuelLevelEvents?: boolean | TruckCountOutputTypeCountFuelLevelEventsArgs
    speedEvents?: boolean | TruckCountOutputTypeCountSpeedEventsArgs
    alertEvents?: boolean | TruckCountOutputTypeCountAlertEventsArgs
    deviceStatusEvents?: boolean | TruckCountOutputTypeCountDeviceStatusEventsArgs
    lockEvents?: boolean | TruckCountOutputTypeCountLockEventsArgs
    dailyRoutes?: boolean | TruckCountOutputTypeCountDailyRoutesArgs
  }

  // Custom InputTypes
  /**
   * TruckCountOutputType without action
   */
  export type TruckCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckCountOutputType
     */
    select?: TruckCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TruckCountOutputType without action
   */
  export type TruckCountOutputTypeCountDevicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceWhereInput
  }

  /**
   * TruckCountOutputType without action
   */
  export type TruckCountOutputTypeCountTruckStatusEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TruckStatusEventWhereInput
  }

  /**
   * TruckCountOutputType without action
   */
  export type TruckCountOutputTypeCountGpsPositionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GpsPositionWhereInput
  }

  /**
   * TruckCountOutputType without action
   */
  export type TruckCountOutputTypeCountTripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripWhereInput
  }

  /**
   * TruckCountOutputType without action
   */
  export type TruckCountOutputTypeCountTirePressureEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TirePressureEventWhereInput
  }

  /**
   * TruckCountOutputType without action
   */
  export type TruckCountOutputTypeCountHubTemperatureEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HubTemperatureEventWhereInput
  }

  /**
   * TruckCountOutputType without action
   */
  export type TruckCountOutputTypeCountFuelLevelEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FuelLevelEventWhereInput
  }

  /**
   * TruckCountOutputType without action
   */
  export type TruckCountOutputTypeCountSpeedEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpeedEventWhereInput
  }

  /**
   * TruckCountOutputType without action
   */
  export type TruckCountOutputTypeCountAlertEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertEventWhereInput
  }

  /**
   * TruckCountOutputType without action
   */
  export type TruckCountOutputTypeCountDeviceStatusEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceStatusEventWhereInput
  }

  /**
   * TruckCountOutputType without action
   */
  export type TruckCountOutputTypeCountLockEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LockEventWhereInput
  }

  /**
   * TruckCountOutputType without action
   */
  export type TruckCountOutputTypeCountDailyRoutesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyRouteWhereInput
  }


  /**
   * Count Type DeviceCountOutputType
   */

  export type DeviceCountOutputType = {
    sensors: number
    gpsPositions: number
    tirePressureEvents: number
    hubTemperatureEvents: number
    deviceStatusEvents: number
    lockEvents: number
  }

  export type DeviceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sensors?: boolean | DeviceCountOutputTypeCountSensorsArgs
    gpsPositions?: boolean | DeviceCountOutputTypeCountGpsPositionsArgs
    tirePressureEvents?: boolean | DeviceCountOutputTypeCountTirePressureEventsArgs
    hubTemperatureEvents?: boolean | DeviceCountOutputTypeCountHubTemperatureEventsArgs
    deviceStatusEvents?: boolean | DeviceCountOutputTypeCountDeviceStatusEventsArgs
    lockEvents?: boolean | DeviceCountOutputTypeCountLockEventsArgs
  }

  // Custom InputTypes
  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceCountOutputType
     */
    select?: DeviceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountSensorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SensorWhereInput
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountGpsPositionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GpsPositionWhereInput
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountTirePressureEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TirePressureEventWhereInput
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountHubTemperatureEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HubTemperatureEventWhereInput
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountDeviceStatusEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceStatusEventWhereInput
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountLockEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LockEventWhereInput
  }


  /**
   * Models
   */

  /**
   * Model FleetGroup
   */

  export type AggregateFleetGroup = {
    _count: FleetGroupCountAggregateOutputType | null
    _min: FleetGroupMinAggregateOutputType | null
    _max: FleetGroupMaxAggregateOutputType | null
  }

  export type FleetGroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    site: string | null
    description: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type FleetGroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    site: string | null
    description: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type FleetGroupCountAggregateOutputType = {
    id: number
    name: number
    site: number
    description: number
    createdAt: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type FleetGroupMinAggregateInputType = {
    id?: true
    name?: true
    site?: true
    description?: true
    createdAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type FleetGroupMaxAggregateInputType = {
    id?: true
    name?: true
    site?: true
    description?: true
    createdAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type FleetGroupCountAggregateInputType = {
    id?: true
    name?: true
    site?: true
    description?: true
    createdAt?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type FleetGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FleetGroup to aggregate.
     */
    where?: FleetGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FleetGroups to fetch.
     */
    orderBy?: FleetGroupOrderByWithRelationInput | FleetGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FleetGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FleetGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FleetGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FleetGroups
    **/
    _count?: true | FleetGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FleetGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FleetGroupMaxAggregateInputType
  }

  export type GetFleetGroupAggregateType<T extends FleetGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateFleetGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFleetGroup[P]>
      : GetScalarType<T[P], AggregateFleetGroup[P]>
  }




  export type FleetGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FleetGroupWhereInput
    orderBy?: FleetGroupOrderByWithAggregationInput | FleetGroupOrderByWithAggregationInput[]
    by: FleetGroupScalarFieldEnum[] | FleetGroupScalarFieldEnum
    having?: FleetGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FleetGroupCountAggregateInputType | true
    _min?: FleetGroupMinAggregateInputType
    _max?: FleetGroupMaxAggregateInputType
  }

  export type FleetGroupGroupByOutputType = {
    id: string
    name: string
    site: string | null
    description: string | null
    createdAt: Date
    createdBy: string | null
    updatedBy: string | null
    _count: FleetGroupCountAggregateOutputType | null
    _min: FleetGroupMinAggregateOutputType | null
    _max: FleetGroupMaxAggregateOutputType | null
  }

  type GetFleetGroupGroupByPayload<T extends FleetGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FleetGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FleetGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FleetGroupGroupByOutputType[P]>
            : GetScalarType<T[P], FleetGroupGroupByOutputType[P]>
        }
      >
    >


  export type FleetGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    site?: boolean
    description?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    trucks?: boolean | FleetGroup$trucksArgs<ExtArgs>
    _count?: boolean | FleetGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fleetGroup"]>

  export type FleetGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    site?: boolean
    description?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["fleetGroup"]>

  export type FleetGroupSelectScalar = {
    id?: boolean
    name?: boolean
    site?: boolean
    description?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type FleetGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trucks?: boolean | FleetGroup$trucksArgs<ExtArgs>
    _count?: boolean | FleetGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FleetGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FleetGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FleetGroup"
    objects: {
      trucks: Prisma.$TruckPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      site: string | null
      description: string | null
      createdAt: Date
      createdBy: string | null
      updatedBy: string | null
    }, ExtArgs["result"]["fleetGroup"]>
    composites: {}
  }

  type FleetGroupGetPayload<S extends boolean | null | undefined | FleetGroupDefaultArgs> = $Result.GetResult<Prisma.$FleetGroupPayload, S>

  type FleetGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FleetGroupFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FleetGroupCountAggregateInputType | true
    }

  export interface FleetGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FleetGroup'], meta: { name: 'FleetGroup' } }
    /**
     * Find zero or one FleetGroup that matches the filter.
     * @param {FleetGroupFindUniqueArgs} args - Arguments to find a FleetGroup
     * @example
     * // Get one FleetGroup
     * const fleetGroup = await prisma.fleetGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FleetGroupFindUniqueArgs>(args: SelectSubset<T, FleetGroupFindUniqueArgs<ExtArgs>>): Prisma__FleetGroupClient<$Result.GetResult<Prisma.$FleetGroupPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FleetGroup that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FleetGroupFindUniqueOrThrowArgs} args - Arguments to find a FleetGroup
     * @example
     * // Get one FleetGroup
     * const fleetGroup = await prisma.fleetGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FleetGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, FleetGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FleetGroupClient<$Result.GetResult<Prisma.$FleetGroupPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FleetGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FleetGroupFindFirstArgs} args - Arguments to find a FleetGroup
     * @example
     * // Get one FleetGroup
     * const fleetGroup = await prisma.fleetGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FleetGroupFindFirstArgs>(args?: SelectSubset<T, FleetGroupFindFirstArgs<ExtArgs>>): Prisma__FleetGroupClient<$Result.GetResult<Prisma.$FleetGroupPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FleetGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FleetGroupFindFirstOrThrowArgs} args - Arguments to find a FleetGroup
     * @example
     * // Get one FleetGroup
     * const fleetGroup = await prisma.fleetGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FleetGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, FleetGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__FleetGroupClient<$Result.GetResult<Prisma.$FleetGroupPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FleetGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FleetGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FleetGroups
     * const fleetGroups = await prisma.fleetGroup.findMany()
     * 
     * // Get first 10 FleetGroups
     * const fleetGroups = await prisma.fleetGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fleetGroupWithIdOnly = await prisma.fleetGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FleetGroupFindManyArgs>(args?: SelectSubset<T, FleetGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FleetGroupPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FleetGroup.
     * @param {FleetGroupCreateArgs} args - Arguments to create a FleetGroup.
     * @example
     * // Create one FleetGroup
     * const FleetGroup = await prisma.fleetGroup.create({
     *   data: {
     *     // ... data to create a FleetGroup
     *   }
     * })
     * 
     */
    create<T extends FleetGroupCreateArgs>(args: SelectSubset<T, FleetGroupCreateArgs<ExtArgs>>): Prisma__FleetGroupClient<$Result.GetResult<Prisma.$FleetGroupPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FleetGroups.
     * @param {FleetGroupCreateManyArgs} args - Arguments to create many FleetGroups.
     * @example
     * // Create many FleetGroups
     * const fleetGroup = await prisma.fleetGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FleetGroupCreateManyArgs>(args?: SelectSubset<T, FleetGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FleetGroups and returns the data saved in the database.
     * @param {FleetGroupCreateManyAndReturnArgs} args - Arguments to create many FleetGroups.
     * @example
     * // Create many FleetGroups
     * const fleetGroup = await prisma.fleetGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FleetGroups and only return the `id`
     * const fleetGroupWithIdOnly = await prisma.fleetGroup.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FleetGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, FleetGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FleetGroupPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FleetGroup.
     * @param {FleetGroupDeleteArgs} args - Arguments to delete one FleetGroup.
     * @example
     * // Delete one FleetGroup
     * const FleetGroup = await prisma.fleetGroup.delete({
     *   where: {
     *     // ... filter to delete one FleetGroup
     *   }
     * })
     * 
     */
    delete<T extends FleetGroupDeleteArgs>(args: SelectSubset<T, FleetGroupDeleteArgs<ExtArgs>>): Prisma__FleetGroupClient<$Result.GetResult<Prisma.$FleetGroupPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FleetGroup.
     * @param {FleetGroupUpdateArgs} args - Arguments to update one FleetGroup.
     * @example
     * // Update one FleetGroup
     * const fleetGroup = await prisma.fleetGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FleetGroupUpdateArgs>(args: SelectSubset<T, FleetGroupUpdateArgs<ExtArgs>>): Prisma__FleetGroupClient<$Result.GetResult<Prisma.$FleetGroupPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FleetGroups.
     * @param {FleetGroupDeleteManyArgs} args - Arguments to filter FleetGroups to delete.
     * @example
     * // Delete a few FleetGroups
     * const { count } = await prisma.fleetGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FleetGroupDeleteManyArgs>(args?: SelectSubset<T, FleetGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FleetGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FleetGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FleetGroups
     * const fleetGroup = await prisma.fleetGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FleetGroupUpdateManyArgs>(args: SelectSubset<T, FleetGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FleetGroup.
     * @param {FleetGroupUpsertArgs} args - Arguments to update or create a FleetGroup.
     * @example
     * // Update or create a FleetGroup
     * const fleetGroup = await prisma.fleetGroup.upsert({
     *   create: {
     *     // ... data to create a FleetGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FleetGroup we want to update
     *   }
     * })
     */
    upsert<T extends FleetGroupUpsertArgs>(args: SelectSubset<T, FleetGroupUpsertArgs<ExtArgs>>): Prisma__FleetGroupClient<$Result.GetResult<Prisma.$FleetGroupPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FleetGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FleetGroupCountArgs} args - Arguments to filter FleetGroups to count.
     * @example
     * // Count the number of FleetGroups
     * const count = await prisma.fleetGroup.count({
     *   where: {
     *     // ... the filter for the FleetGroups we want to count
     *   }
     * })
    **/
    count<T extends FleetGroupCountArgs>(
      args?: Subset<T, FleetGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FleetGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FleetGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FleetGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FleetGroupAggregateArgs>(args: Subset<T, FleetGroupAggregateArgs>): Prisma.PrismaPromise<GetFleetGroupAggregateType<T>>

    /**
     * Group by FleetGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FleetGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FleetGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FleetGroupGroupByArgs['orderBy'] }
        : { orderBy?: FleetGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FleetGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFleetGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FleetGroup model
   */
  readonly fields: FleetGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FleetGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FleetGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trucks<T extends FleetGroup$trucksArgs<ExtArgs> = {}>(args?: Subset<T, FleetGroup$trucksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TruckPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FleetGroup model
   */ 
  interface FleetGroupFieldRefs {
    readonly id: FieldRef<"FleetGroup", 'String'>
    readonly name: FieldRef<"FleetGroup", 'String'>
    readonly site: FieldRef<"FleetGroup", 'String'>
    readonly description: FieldRef<"FleetGroup", 'String'>
    readonly createdAt: FieldRef<"FleetGroup", 'DateTime'>
    readonly createdBy: FieldRef<"FleetGroup", 'String'>
    readonly updatedBy: FieldRef<"FleetGroup", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FleetGroup findUnique
   */
  export type FleetGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FleetGroup
     */
    select?: FleetGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FleetGroupInclude<ExtArgs> | null
    /**
     * Filter, which FleetGroup to fetch.
     */
    where: FleetGroupWhereUniqueInput
  }

  /**
   * FleetGroup findUniqueOrThrow
   */
  export type FleetGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FleetGroup
     */
    select?: FleetGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FleetGroupInclude<ExtArgs> | null
    /**
     * Filter, which FleetGroup to fetch.
     */
    where: FleetGroupWhereUniqueInput
  }

  /**
   * FleetGroup findFirst
   */
  export type FleetGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FleetGroup
     */
    select?: FleetGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FleetGroupInclude<ExtArgs> | null
    /**
     * Filter, which FleetGroup to fetch.
     */
    where?: FleetGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FleetGroups to fetch.
     */
    orderBy?: FleetGroupOrderByWithRelationInput | FleetGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FleetGroups.
     */
    cursor?: FleetGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FleetGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FleetGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FleetGroups.
     */
    distinct?: FleetGroupScalarFieldEnum | FleetGroupScalarFieldEnum[]
  }

  /**
   * FleetGroup findFirstOrThrow
   */
  export type FleetGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FleetGroup
     */
    select?: FleetGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FleetGroupInclude<ExtArgs> | null
    /**
     * Filter, which FleetGroup to fetch.
     */
    where?: FleetGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FleetGroups to fetch.
     */
    orderBy?: FleetGroupOrderByWithRelationInput | FleetGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FleetGroups.
     */
    cursor?: FleetGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FleetGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FleetGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FleetGroups.
     */
    distinct?: FleetGroupScalarFieldEnum | FleetGroupScalarFieldEnum[]
  }

  /**
   * FleetGroup findMany
   */
  export type FleetGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FleetGroup
     */
    select?: FleetGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FleetGroupInclude<ExtArgs> | null
    /**
     * Filter, which FleetGroups to fetch.
     */
    where?: FleetGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FleetGroups to fetch.
     */
    orderBy?: FleetGroupOrderByWithRelationInput | FleetGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FleetGroups.
     */
    cursor?: FleetGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FleetGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FleetGroups.
     */
    skip?: number
    distinct?: FleetGroupScalarFieldEnum | FleetGroupScalarFieldEnum[]
  }

  /**
   * FleetGroup create
   */
  export type FleetGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FleetGroup
     */
    select?: FleetGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FleetGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a FleetGroup.
     */
    data: XOR<FleetGroupCreateInput, FleetGroupUncheckedCreateInput>
  }

  /**
   * FleetGroup createMany
   */
  export type FleetGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FleetGroups.
     */
    data: FleetGroupCreateManyInput | FleetGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FleetGroup createManyAndReturn
   */
  export type FleetGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FleetGroup
     */
    select?: FleetGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FleetGroups.
     */
    data: FleetGroupCreateManyInput | FleetGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FleetGroup update
   */
  export type FleetGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FleetGroup
     */
    select?: FleetGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FleetGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a FleetGroup.
     */
    data: XOR<FleetGroupUpdateInput, FleetGroupUncheckedUpdateInput>
    /**
     * Choose, which FleetGroup to update.
     */
    where: FleetGroupWhereUniqueInput
  }

  /**
   * FleetGroup updateMany
   */
  export type FleetGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FleetGroups.
     */
    data: XOR<FleetGroupUpdateManyMutationInput, FleetGroupUncheckedUpdateManyInput>
    /**
     * Filter which FleetGroups to update
     */
    where?: FleetGroupWhereInput
  }

  /**
   * FleetGroup upsert
   */
  export type FleetGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FleetGroup
     */
    select?: FleetGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FleetGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the FleetGroup to update in case it exists.
     */
    where: FleetGroupWhereUniqueInput
    /**
     * In case the FleetGroup found by the `where` argument doesn't exist, create a new FleetGroup with this data.
     */
    create: XOR<FleetGroupCreateInput, FleetGroupUncheckedCreateInput>
    /**
     * In case the FleetGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FleetGroupUpdateInput, FleetGroupUncheckedUpdateInput>
  }

  /**
   * FleetGroup delete
   */
  export type FleetGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FleetGroup
     */
    select?: FleetGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FleetGroupInclude<ExtArgs> | null
    /**
     * Filter which FleetGroup to delete.
     */
    where: FleetGroupWhereUniqueInput
  }

  /**
   * FleetGroup deleteMany
   */
  export type FleetGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FleetGroups to delete
     */
    where?: FleetGroupWhereInput
  }

  /**
   * FleetGroup.trucks
   */
  export type FleetGroup$trucksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Truck
     */
    select?: TruckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckInclude<ExtArgs> | null
    where?: TruckWhereInput
    orderBy?: TruckOrderByWithRelationInput | TruckOrderByWithRelationInput[]
    cursor?: TruckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TruckScalarFieldEnum | TruckScalarFieldEnum[]
  }

  /**
   * FleetGroup without action
   */
  export type FleetGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FleetGroup
     */
    select?: FleetGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FleetGroupInclude<ExtArgs> | null
  }


  /**
   * Model Truck
   */

  export type AggregateTruck = {
    _count: TruckCountAggregateOutputType | null
    _avg: TruckAvgAggregateOutputType | null
    _sum: TruckSumAggregateOutputType | null
    _min: TruckMinAggregateOutputType | null
    _max: TruckMaxAggregateOutputType | null
  }

  export type TruckAvgAggregateOutputType = {
    year: number | null
  }

  export type TruckSumAggregateOutputType = {
    year: number | null
  }

  export type TruckMinAggregateOutputType = {
    id: string | null
    plateNumber: string | null
    vin: string | null
    name: string | null
    model: string | null
    year: number | null
    tireConfig: string | null
    fleetGroupId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type TruckMaxAggregateOutputType = {
    id: string | null
    plateNumber: string | null
    vin: string | null
    name: string | null
    model: string | null
    year: number | null
    tireConfig: string | null
    fleetGroupId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type TruckCountAggregateOutputType = {
    id: number
    plateNumber: number
    vin: number
    name: number
    model: number
    year: number
    tireConfig: number
    fleetGroupId: number
    createdAt: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type TruckAvgAggregateInputType = {
    year?: true
  }

  export type TruckSumAggregateInputType = {
    year?: true
  }

  export type TruckMinAggregateInputType = {
    id?: true
    plateNumber?: true
    vin?: true
    name?: true
    model?: true
    year?: true
    tireConfig?: true
    fleetGroupId?: true
    createdAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type TruckMaxAggregateInputType = {
    id?: true
    plateNumber?: true
    vin?: true
    name?: true
    model?: true
    year?: true
    tireConfig?: true
    fleetGroupId?: true
    createdAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type TruckCountAggregateInputType = {
    id?: true
    plateNumber?: true
    vin?: true
    name?: true
    model?: true
    year?: true
    tireConfig?: true
    fleetGroupId?: true
    createdAt?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type TruckAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Truck to aggregate.
     */
    where?: TruckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trucks to fetch.
     */
    orderBy?: TruckOrderByWithRelationInput | TruckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TruckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trucks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trucks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trucks
    **/
    _count?: true | TruckCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TruckAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TruckSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TruckMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TruckMaxAggregateInputType
  }

  export type GetTruckAggregateType<T extends TruckAggregateArgs> = {
        [P in keyof T & keyof AggregateTruck]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTruck[P]>
      : GetScalarType<T[P], AggregateTruck[P]>
  }




  export type TruckGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TruckWhereInput
    orderBy?: TruckOrderByWithAggregationInput | TruckOrderByWithAggregationInput[]
    by: TruckScalarFieldEnum[] | TruckScalarFieldEnum
    having?: TruckScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TruckCountAggregateInputType | true
    _avg?: TruckAvgAggregateInputType
    _sum?: TruckSumAggregateInputType
    _min?: TruckMinAggregateInputType
    _max?: TruckMaxAggregateInputType
  }

  export type TruckGroupByOutputType = {
    id: string
    plateNumber: string
    vin: string | null
    name: string | null
    model: string | null
    year: number | null
    tireConfig: string | null
    fleetGroupId: string | null
    createdAt: Date
    createdBy: string | null
    updatedBy: string | null
    _count: TruckCountAggregateOutputType | null
    _avg: TruckAvgAggregateOutputType | null
    _sum: TruckSumAggregateOutputType | null
    _min: TruckMinAggregateOutputType | null
    _max: TruckMaxAggregateOutputType | null
  }

  type GetTruckGroupByPayload<T extends TruckGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TruckGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TruckGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TruckGroupByOutputType[P]>
            : GetScalarType<T[P], TruckGroupByOutputType[P]>
        }
      >
    >


  export type TruckSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plateNumber?: boolean
    vin?: boolean
    name?: boolean
    model?: boolean
    year?: boolean
    tireConfig?: boolean
    fleetGroupId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    fleetGroup?: boolean | Truck$fleetGroupArgs<ExtArgs>
    devices?: boolean | Truck$devicesArgs<ExtArgs>
    truckStatusEvents?: boolean | Truck$truckStatusEventsArgs<ExtArgs>
    gpsPositions?: boolean | Truck$gpsPositionsArgs<ExtArgs>
    trips?: boolean | Truck$tripsArgs<ExtArgs>
    tirePressureEvents?: boolean | Truck$tirePressureEventsArgs<ExtArgs>
    hubTemperatureEvents?: boolean | Truck$hubTemperatureEventsArgs<ExtArgs>
    fuelLevelEvents?: boolean | Truck$fuelLevelEventsArgs<ExtArgs>
    speedEvents?: boolean | Truck$speedEventsArgs<ExtArgs>
    alertEvents?: boolean | Truck$alertEventsArgs<ExtArgs>
    deviceStatusEvents?: boolean | Truck$deviceStatusEventsArgs<ExtArgs>
    lockEvents?: boolean | Truck$lockEventsArgs<ExtArgs>
    dailyRoutes?: boolean | Truck$dailyRoutesArgs<ExtArgs>
    _count?: boolean | TruckCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["truck"]>

  export type TruckSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plateNumber?: boolean
    vin?: boolean
    name?: boolean
    model?: boolean
    year?: boolean
    tireConfig?: boolean
    fleetGroupId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    fleetGroup?: boolean | Truck$fleetGroupArgs<ExtArgs>
  }, ExtArgs["result"]["truck"]>

  export type TruckSelectScalar = {
    id?: boolean
    plateNumber?: boolean
    vin?: boolean
    name?: boolean
    model?: boolean
    year?: boolean
    tireConfig?: boolean
    fleetGroupId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type TruckInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fleetGroup?: boolean | Truck$fleetGroupArgs<ExtArgs>
    devices?: boolean | Truck$devicesArgs<ExtArgs>
    truckStatusEvents?: boolean | Truck$truckStatusEventsArgs<ExtArgs>
    gpsPositions?: boolean | Truck$gpsPositionsArgs<ExtArgs>
    trips?: boolean | Truck$tripsArgs<ExtArgs>
    tirePressureEvents?: boolean | Truck$tirePressureEventsArgs<ExtArgs>
    hubTemperatureEvents?: boolean | Truck$hubTemperatureEventsArgs<ExtArgs>
    fuelLevelEvents?: boolean | Truck$fuelLevelEventsArgs<ExtArgs>
    speedEvents?: boolean | Truck$speedEventsArgs<ExtArgs>
    alertEvents?: boolean | Truck$alertEventsArgs<ExtArgs>
    deviceStatusEvents?: boolean | Truck$deviceStatusEventsArgs<ExtArgs>
    lockEvents?: boolean | Truck$lockEventsArgs<ExtArgs>
    dailyRoutes?: boolean | Truck$dailyRoutesArgs<ExtArgs>
    _count?: boolean | TruckCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TruckIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fleetGroup?: boolean | Truck$fleetGroupArgs<ExtArgs>
  }

  export type $TruckPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Truck"
    objects: {
      fleetGroup: Prisma.$FleetGroupPayload<ExtArgs> | null
      devices: Prisma.$DevicePayload<ExtArgs>[]
      truckStatusEvents: Prisma.$TruckStatusEventPayload<ExtArgs>[]
      gpsPositions: Prisma.$GpsPositionPayload<ExtArgs>[]
      trips: Prisma.$TripPayload<ExtArgs>[]
      tirePressureEvents: Prisma.$TirePressureEventPayload<ExtArgs>[]
      hubTemperatureEvents: Prisma.$HubTemperatureEventPayload<ExtArgs>[]
      fuelLevelEvents: Prisma.$FuelLevelEventPayload<ExtArgs>[]
      speedEvents: Prisma.$SpeedEventPayload<ExtArgs>[]
      alertEvents: Prisma.$AlertEventPayload<ExtArgs>[]
      deviceStatusEvents: Prisma.$DeviceStatusEventPayload<ExtArgs>[]
      lockEvents: Prisma.$LockEventPayload<ExtArgs>[]
      dailyRoutes: Prisma.$DailyRoutePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      plateNumber: string
      vin: string | null
      name: string | null
      model: string | null
      year: number | null
      tireConfig: string | null
      fleetGroupId: string | null
      createdAt: Date
      createdBy: string | null
      updatedBy: string | null
    }, ExtArgs["result"]["truck"]>
    composites: {}
  }

  type TruckGetPayload<S extends boolean | null | undefined | TruckDefaultArgs> = $Result.GetResult<Prisma.$TruckPayload, S>

  type TruckCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TruckFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TruckCountAggregateInputType | true
    }

  export interface TruckDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Truck'], meta: { name: 'Truck' } }
    /**
     * Find zero or one Truck that matches the filter.
     * @param {TruckFindUniqueArgs} args - Arguments to find a Truck
     * @example
     * // Get one Truck
     * const truck = await prisma.truck.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TruckFindUniqueArgs>(args: SelectSubset<T, TruckFindUniqueArgs<ExtArgs>>): Prisma__TruckClient<$Result.GetResult<Prisma.$TruckPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Truck that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TruckFindUniqueOrThrowArgs} args - Arguments to find a Truck
     * @example
     * // Get one Truck
     * const truck = await prisma.truck.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TruckFindUniqueOrThrowArgs>(args: SelectSubset<T, TruckFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TruckClient<$Result.GetResult<Prisma.$TruckPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Truck that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckFindFirstArgs} args - Arguments to find a Truck
     * @example
     * // Get one Truck
     * const truck = await prisma.truck.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TruckFindFirstArgs>(args?: SelectSubset<T, TruckFindFirstArgs<ExtArgs>>): Prisma__TruckClient<$Result.GetResult<Prisma.$TruckPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Truck that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckFindFirstOrThrowArgs} args - Arguments to find a Truck
     * @example
     * // Get one Truck
     * const truck = await prisma.truck.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TruckFindFirstOrThrowArgs>(args?: SelectSubset<T, TruckFindFirstOrThrowArgs<ExtArgs>>): Prisma__TruckClient<$Result.GetResult<Prisma.$TruckPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Trucks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trucks
     * const trucks = await prisma.truck.findMany()
     * 
     * // Get first 10 Trucks
     * const trucks = await prisma.truck.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const truckWithIdOnly = await prisma.truck.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TruckFindManyArgs>(args?: SelectSubset<T, TruckFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TruckPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Truck.
     * @param {TruckCreateArgs} args - Arguments to create a Truck.
     * @example
     * // Create one Truck
     * const Truck = await prisma.truck.create({
     *   data: {
     *     // ... data to create a Truck
     *   }
     * })
     * 
     */
    create<T extends TruckCreateArgs>(args: SelectSubset<T, TruckCreateArgs<ExtArgs>>): Prisma__TruckClient<$Result.GetResult<Prisma.$TruckPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Trucks.
     * @param {TruckCreateManyArgs} args - Arguments to create many Trucks.
     * @example
     * // Create many Trucks
     * const truck = await prisma.truck.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TruckCreateManyArgs>(args?: SelectSubset<T, TruckCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Trucks and returns the data saved in the database.
     * @param {TruckCreateManyAndReturnArgs} args - Arguments to create many Trucks.
     * @example
     * // Create many Trucks
     * const truck = await prisma.truck.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Trucks and only return the `id`
     * const truckWithIdOnly = await prisma.truck.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TruckCreateManyAndReturnArgs>(args?: SelectSubset<T, TruckCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TruckPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Truck.
     * @param {TruckDeleteArgs} args - Arguments to delete one Truck.
     * @example
     * // Delete one Truck
     * const Truck = await prisma.truck.delete({
     *   where: {
     *     // ... filter to delete one Truck
     *   }
     * })
     * 
     */
    delete<T extends TruckDeleteArgs>(args: SelectSubset<T, TruckDeleteArgs<ExtArgs>>): Prisma__TruckClient<$Result.GetResult<Prisma.$TruckPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Truck.
     * @param {TruckUpdateArgs} args - Arguments to update one Truck.
     * @example
     * // Update one Truck
     * const truck = await prisma.truck.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TruckUpdateArgs>(args: SelectSubset<T, TruckUpdateArgs<ExtArgs>>): Prisma__TruckClient<$Result.GetResult<Prisma.$TruckPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Trucks.
     * @param {TruckDeleteManyArgs} args - Arguments to filter Trucks to delete.
     * @example
     * // Delete a few Trucks
     * const { count } = await prisma.truck.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TruckDeleteManyArgs>(args?: SelectSubset<T, TruckDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trucks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trucks
     * const truck = await prisma.truck.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TruckUpdateManyArgs>(args: SelectSubset<T, TruckUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Truck.
     * @param {TruckUpsertArgs} args - Arguments to update or create a Truck.
     * @example
     * // Update or create a Truck
     * const truck = await prisma.truck.upsert({
     *   create: {
     *     // ... data to create a Truck
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Truck we want to update
     *   }
     * })
     */
    upsert<T extends TruckUpsertArgs>(args: SelectSubset<T, TruckUpsertArgs<ExtArgs>>): Prisma__TruckClient<$Result.GetResult<Prisma.$TruckPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Trucks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckCountArgs} args - Arguments to filter Trucks to count.
     * @example
     * // Count the number of Trucks
     * const count = await prisma.truck.count({
     *   where: {
     *     // ... the filter for the Trucks we want to count
     *   }
     * })
    **/
    count<T extends TruckCountArgs>(
      args?: Subset<T, TruckCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TruckCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Truck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TruckAggregateArgs>(args: Subset<T, TruckAggregateArgs>): Prisma.PrismaPromise<GetTruckAggregateType<T>>

    /**
     * Group by Truck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TruckGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TruckGroupByArgs['orderBy'] }
        : { orderBy?: TruckGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TruckGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTruckGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Truck model
   */
  readonly fields: TruckFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Truck.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TruckClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fleetGroup<T extends Truck$fleetGroupArgs<ExtArgs> = {}>(args?: Subset<T, Truck$fleetGroupArgs<ExtArgs>>): Prisma__FleetGroupClient<$Result.GetResult<Prisma.$FleetGroupPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    devices<T extends Truck$devicesArgs<ExtArgs> = {}>(args?: Subset<T, Truck$devicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findMany"> | Null>
    truckStatusEvents<T extends Truck$truckStatusEventsArgs<ExtArgs> = {}>(args?: Subset<T, Truck$truckStatusEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TruckStatusEventPayload<ExtArgs>, T, "findMany"> | Null>
    gpsPositions<T extends Truck$gpsPositionsArgs<ExtArgs> = {}>(args?: Subset<T, Truck$gpsPositionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GpsPositionPayload<ExtArgs>, T, "findMany"> | Null>
    trips<T extends Truck$tripsArgs<ExtArgs> = {}>(args?: Subset<T, Truck$tripsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findMany"> | Null>
    tirePressureEvents<T extends Truck$tirePressureEventsArgs<ExtArgs> = {}>(args?: Subset<T, Truck$tirePressureEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TirePressureEventPayload<ExtArgs>, T, "findMany"> | Null>
    hubTemperatureEvents<T extends Truck$hubTemperatureEventsArgs<ExtArgs> = {}>(args?: Subset<T, Truck$hubTemperatureEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HubTemperatureEventPayload<ExtArgs>, T, "findMany"> | Null>
    fuelLevelEvents<T extends Truck$fuelLevelEventsArgs<ExtArgs> = {}>(args?: Subset<T, Truck$fuelLevelEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FuelLevelEventPayload<ExtArgs>, T, "findMany"> | Null>
    speedEvents<T extends Truck$speedEventsArgs<ExtArgs> = {}>(args?: Subset<T, Truck$speedEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeedEventPayload<ExtArgs>, T, "findMany"> | Null>
    alertEvents<T extends Truck$alertEventsArgs<ExtArgs> = {}>(args?: Subset<T, Truck$alertEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "findMany"> | Null>
    deviceStatusEvents<T extends Truck$deviceStatusEventsArgs<ExtArgs> = {}>(args?: Subset<T, Truck$deviceStatusEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceStatusEventPayload<ExtArgs>, T, "findMany"> | Null>
    lockEvents<T extends Truck$lockEventsArgs<ExtArgs> = {}>(args?: Subset<T, Truck$lockEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LockEventPayload<ExtArgs>, T, "findMany"> | Null>
    dailyRoutes<T extends Truck$dailyRoutesArgs<ExtArgs> = {}>(args?: Subset<T, Truck$dailyRoutesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyRoutePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Truck model
   */ 
  interface TruckFieldRefs {
    readonly id: FieldRef<"Truck", 'String'>
    readonly plateNumber: FieldRef<"Truck", 'String'>
    readonly vin: FieldRef<"Truck", 'String'>
    readonly name: FieldRef<"Truck", 'String'>
    readonly model: FieldRef<"Truck", 'String'>
    readonly year: FieldRef<"Truck", 'Int'>
    readonly tireConfig: FieldRef<"Truck", 'String'>
    readonly fleetGroupId: FieldRef<"Truck", 'String'>
    readonly createdAt: FieldRef<"Truck", 'DateTime'>
    readonly createdBy: FieldRef<"Truck", 'String'>
    readonly updatedBy: FieldRef<"Truck", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Truck findUnique
   */
  export type TruckFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Truck
     */
    select?: TruckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckInclude<ExtArgs> | null
    /**
     * Filter, which Truck to fetch.
     */
    where: TruckWhereUniqueInput
  }

  /**
   * Truck findUniqueOrThrow
   */
  export type TruckFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Truck
     */
    select?: TruckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckInclude<ExtArgs> | null
    /**
     * Filter, which Truck to fetch.
     */
    where: TruckWhereUniqueInput
  }

  /**
   * Truck findFirst
   */
  export type TruckFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Truck
     */
    select?: TruckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckInclude<ExtArgs> | null
    /**
     * Filter, which Truck to fetch.
     */
    where?: TruckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trucks to fetch.
     */
    orderBy?: TruckOrderByWithRelationInput | TruckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trucks.
     */
    cursor?: TruckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trucks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trucks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trucks.
     */
    distinct?: TruckScalarFieldEnum | TruckScalarFieldEnum[]
  }

  /**
   * Truck findFirstOrThrow
   */
  export type TruckFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Truck
     */
    select?: TruckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckInclude<ExtArgs> | null
    /**
     * Filter, which Truck to fetch.
     */
    where?: TruckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trucks to fetch.
     */
    orderBy?: TruckOrderByWithRelationInput | TruckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trucks.
     */
    cursor?: TruckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trucks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trucks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trucks.
     */
    distinct?: TruckScalarFieldEnum | TruckScalarFieldEnum[]
  }

  /**
   * Truck findMany
   */
  export type TruckFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Truck
     */
    select?: TruckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckInclude<ExtArgs> | null
    /**
     * Filter, which Trucks to fetch.
     */
    where?: TruckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trucks to fetch.
     */
    orderBy?: TruckOrderByWithRelationInput | TruckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trucks.
     */
    cursor?: TruckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trucks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trucks.
     */
    skip?: number
    distinct?: TruckScalarFieldEnum | TruckScalarFieldEnum[]
  }

  /**
   * Truck create
   */
  export type TruckCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Truck
     */
    select?: TruckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckInclude<ExtArgs> | null
    /**
     * The data needed to create a Truck.
     */
    data: XOR<TruckCreateInput, TruckUncheckedCreateInput>
  }

  /**
   * Truck createMany
   */
  export type TruckCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Trucks.
     */
    data: TruckCreateManyInput | TruckCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Truck createManyAndReturn
   */
  export type TruckCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Truck
     */
    select?: TruckSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Trucks.
     */
    data: TruckCreateManyInput | TruckCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Truck update
   */
  export type TruckUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Truck
     */
    select?: TruckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckInclude<ExtArgs> | null
    /**
     * The data needed to update a Truck.
     */
    data: XOR<TruckUpdateInput, TruckUncheckedUpdateInput>
    /**
     * Choose, which Truck to update.
     */
    where: TruckWhereUniqueInput
  }

  /**
   * Truck updateMany
   */
  export type TruckUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Trucks.
     */
    data: XOR<TruckUpdateManyMutationInput, TruckUncheckedUpdateManyInput>
    /**
     * Filter which Trucks to update
     */
    where?: TruckWhereInput
  }

  /**
   * Truck upsert
   */
  export type TruckUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Truck
     */
    select?: TruckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckInclude<ExtArgs> | null
    /**
     * The filter to search for the Truck to update in case it exists.
     */
    where: TruckWhereUniqueInput
    /**
     * In case the Truck found by the `where` argument doesn't exist, create a new Truck with this data.
     */
    create: XOR<TruckCreateInput, TruckUncheckedCreateInput>
    /**
     * In case the Truck was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TruckUpdateInput, TruckUncheckedUpdateInput>
  }

  /**
   * Truck delete
   */
  export type TruckDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Truck
     */
    select?: TruckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckInclude<ExtArgs> | null
    /**
     * Filter which Truck to delete.
     */
    where: TruckWhereUniqueInput
  }

  /**
   * Truck deleteMany
   */
  export type TruckDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trucks to delete
     */
    where?: TruckWhereInput
  }

  /**
   * Truck.fleetGroup
   */
  export type Truck$fleetGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FleetGroup
     */
    select?: FleetGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FleetGroupInclude<ExtArgs> | null
    where?: FleetGroupWhereInput
  }

  /**
   * Truck.devices
   */
  export type Truck$devicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    where?: DeviceWhereInput
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    cursor?: DeviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Truck.truckStatusEvents
   */
  export type Truck$truckStatusEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckStatusEvent
     */
    select?: TruckStatusEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckStatusEventInclude<ExtArgs> | null
    where?: TruckStatusEventWhereInput
    orderBy?: TruckStatusEventOrderByWithRelationInput | TruckStatusEventOrderByWithRelationInput[]
    cursor?: TruckStatusEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TruckStatusEventScalarFieldEnum | TruckStatusEventScalarFieldEnum[]
  }

  /**
   * Truck.gpsPositions
   */
  export type Truck$gpsPositionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GpsPosition
     */
    select?: GpsPositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GpsPositionInclude<ExtArgs> | null
    where?: GpsPositionWhereInput
    orderBy?: GpsPositionOrderByWithRelationInput | GpsPositionOrderByWithRelationInput[]
    cursor?: GpsPositionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GpsPositionScalarFieldEnum | GpsPositionScalarFieldEnum[]
  }

  /**
   * Truck.trips
   */
  export type Truck$tripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    where?: TripWhereInput
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    cursor?: TripWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Truck.tirePressureEvents
   */
  export type Truck$tirePressureEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TirePressureEvent
     */
    select?: TirePressureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TirePressureEventInclude<ExtArgs> | null
    where?: TirePressureEventWhereInput
    orderBy?: TirePressureEventOrderByWithRelationInput | TirePressureEventOrderByWithRelationInput[]
    cursor?: TirePressureEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TirePressureEventScalarFieldEnum | TirePressureEventScalarFieldEnum[]
  }

  /**
   * Truck.hubTemperatureEvents
   */
  export type Truck$hubTemperatureEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HubTemperatureEvent
     */
    select?: HubTemperatureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HubTemperatureEventInclude<ExtArgs> | null
    where?: HubTemperatureEventWhereInput
    orderBy?: HubTemperatureEventOrderByWithRelationInput | HubTemperatureEventOrderByWithRelationInput[]
    cursor?: HubTemperatureEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HubTemperatureEventScalarFieldEnum | HubTemperatureEventScalarFieldEnum[]
  }

  /**
   * Truck.fuelLevelEvents
   */
  export type Truck$fuelLevelEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FuelLevelEvent
     */
    select?: FuelLevelEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FuelLevelEventInclude<ExtArgs> | null
    where?: FuelLevelEventWhereInput
    orderBy?: FuelLevelEventOrderByWithRelationInput | FuelLevelEventOrderByWithRelationInput[]
    cursor?: FuelLevelEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FuelLevelEventScalarFieldEnum | FuelLevelEventScalarFieldEnum[]
  }

  /**
   * Truck.speedEvents
   */
  export type Truck$speedEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeedEvent
     */
    select?: SpeedEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeedEventInclude<ExtArgs> | null
    where?: SpeedEventWhereInput
    orderBy?: SpeedEventOrderByWithRelationInput | SpeedEventOrderByWithRelationInput[]
    cursor?: SpeedEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpeedEventScalarFieldEnum | SpeedEventScalarFieldEnum[]
  }

  /**
   * Truck.alertEvents
   */
  export type Truck$alertEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    where?: AlertEventWhereInput
    orderBy?: AlertEventOrderByWithRelationInput | AlertEventOrderByWithRelationInput[]
    cursor?: AlertEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertEventScalarFieldEnum | AlertEventScalarFieldEnum[]
  }

  /**
   * Truck.deviceStatusEvents
   */
  export type Truck$deviceStatusEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStatusEvent
     */
    select?: DeviceStatusEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceStatusEventInclude<ExtArgs> | null
    where?: DeviceStatusEventWhereInput
    orderBy?: DeviceStatusEventOrderByWithRelationInput | DeviceStatusEventOrderByWithRelationInput[]
    cursor?: DeviceStatusEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceStatusEventScalarFieldEnum | DeviceStatusEventScalarFieldEnum[]
  }

  /**
   * Truck.lockEvents
   */
  export type Truck$lockEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockEvent
     */
    select?: LockEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockEventInclude<ExtArgs> | null
    where?: LockEventWhereInput
    orderBy?: LockEventOrderByWithRelationInput | LockEventOrderByWithRelationInput[]
    cursor?: LockEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LockEventScalarFieldEnum | LockEventScalarFieldEnum[]
  }

  /**
   * Truck.dailyRoutes
   */
  export type Truck$dailyRoutesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRoute
     */
    select?: DailyRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRouteInclude<ExtArgs> | null
    where?: DailyRouteWhereInput
    orderBy?: DailyRouteOrderByWithRelationInput | DailyRouteOrderByWithRelationInput[]
    cursor?: DailyRouteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyRouteScalarFieldEnum | DailyRouteScalarFieldEnum[]
  }

  /**
   * Truck without action
   */
  export type TruckDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Truck
     */
    select?: TruckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckInclude<ExtArgs> | null
  }


  /**
   * Model Device
   */

  export type AggregateDevice = {
    _count: DeviceCountAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  export type DeviceMinAggregateOutputType = {
    id: string | null
    truckId: string | null
    sn: string | null
    simNumber: string | null
    installedAt: Date | null
    removedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type DeviceMaxAggregateOutputType = {
    id: string | null
    truckId: string | null
    sn: string | null
    simNumber: string | null
    installedAt: Date | null
    removedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type DeviceCountAggregateOutputType = {
    id: number
    truckId: number
    sn: number
    simNumber: number
    installedAt: number
    removedAt: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type DeviceMinAggregateInputType = {
    id?: true
    truckId?: true
    sn?: true
    simNumber?: true
    installedAt?: true
    removedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type DeviceMaxAggregateInputType = {
    id?: true
    truckId?: true
    sn?: true
    simNumber?: true
    installedAt?: true
    removedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type DeviceCountAggregateInputType = {
    id?: true
    truckId?: true
    sn?: true
    simNumber?: true
    installedAt?: true
    removedAt?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type DeviceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Device to aggregate.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Devices
    **/
    _count?: true | DeviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceMaxAggregateInputType
  }

  export type GetDeviceAggregateType<T extends DeviceAggregateArgs> = {
        [P in keyof T & keyof AggregateDevice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevice[P]>
      : GetScalarType<T[P], AggregateDevice[P]>
  }




  export type DeviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceWhereInput
    orderBy?: DeviceOrderByWithAggregationInput | DeviceOrderByWithAggregationInput[]
    by: DeviceScalarFieldEnum[] | DeviceScalarFieldEnum
    having?: DeviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceCountAggregateInputType | true
    _min?: DeviceMinAggregateInputType
    _max?: DeviceMaxAggregateInputType
  }

  export type DeviceGroupByOutputType = {
    id: string
    truckId: string
    sn: string
    simNumber: string | null
    installedAt: Date
    removedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    _count: DeviceCountAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  type GetDeviceGroupByPayload<T extends DeviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceGroupByOutputType[P]>
        }
      >
    >


  export type DeviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    truckId?: boolean
    sn?: boolean
    simNumber?: boolean
    installedAt?: boolean
    removedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    truck?: boolean | TruckDefaultArgs<ExtArgs>
    sensors?: boolean | Device$sensorsArgs<ExtArgs>
    gpsPositions?: boolean | Device$gpsPositionsArgs<ExtArgs>
    tirePressureEvents?: boolean | Device$tirePressureEventsArgs<ExtArgs>
    hubTemperatureEvents?: boolean | Device$hubTemperatureEventsArgs<ExtArgs>
    deviceStatusEvents?: boolean | Device$deviceStatusEventsArgs<ExtArgs>
    lockEvents?: boolean | Device$lockEventsArgs<ExtArgs>
    _count?: boolean | DeviceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    truckId?: boolean
    sn?: boolean
    simNumber?: boolean
    installedAt?: boolean
    removedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectScalar = {
    id?: boolean
    truckId?: boolean
    sn?: boolean
    simNumber?: boolean
    installedAt?: boolean
    removedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type DeviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    truck?: boolean | TruckDefaultArgs<ExtArgs>
    sensors?: boolean | Device$sensorsArgs<ExtArgs>
    gpsPositions?: boolean | Device$gpsPositionsArgs<ExtArgs>
    tirePressureEvents?: boolean | Device$tirePressureEventsArgs<ExtArgs>
    hubTemperatureEvents?: boolean | Device$hubTemperatureEventsArgs<ExtArgs>
    deviceStatusEvents?: boolean | Device$deviceStatusEventsArgs<ExtArgs>
    lockEvents?: boolean | Device$lockEventsArgs<ExtArgs>
    _count?: boolean | DeviceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeviceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }

  export type $DevicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Device"
    objects: {
      truck: Prisma.$TruckPayload<ExtArgs>
      sensors: Prisma.$SensorPayload<ExtArgs>[]
      gpsPositions: Prisma.$GpsPositionPayload<ExtArgs>[]
      tirePressureEvents: Prisma.$TirePressureEventPayload<ExtArgs>[]
      hubTemperatureEvents: Prisma.$HubTemperatureEventPayload<ExtArgs>[]
      deviceStatusEvents: Prisma.$DeviceStatusEventPayload<ExtArgs>[]
      lockEvents: Prisma.$LockEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      truckId: string
      sn: string
      simNumber: string | null
      installedAt: Date
      removedAt: Date | null
      createdBy: string | null
      updatedBy: string | null
    }, ExtArgs["result"]["device"]>
    composites: {}
  }

  type DeviceGetPayload<S extends boolean | null | undefined | DeviceDefaultArgs> = $Result.GetResult<Prisma.$DevicePayload, S>

  type DeviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeviceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeviceCountAggregateInputType | true
    }

  export interface DeviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Device'], meta: { name: 'Device' } }
    /**
     * Find zero or one Device that matches the filter.
     * @param {DeviceFindUniqueArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceFindUniqueArgs>(args: SelectSubset<T, DeviceFindUniqueArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Device that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeviceFindUniqueOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Device that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceFindFirstArgs>(args?: SelectSubset<T, DeviceFindFirstArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Device that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Devices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Devices
     * const devices = await prisma.device.findMany()
     * 
     * // Get first 10 Devices
     * const devices = await prisma.device.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceWithIdOnly = await prisma.device.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceFindManyArgs>(args?: SelectSubset<T, DeviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Device.
     * @param {DeviceCreateArgs} args - Arguments to create a Device.
     * @example
     * // Create one Device
     * const Device = await prisma.device.create({
     *   data: {
     *     // ... data to create a Device
     *   }
     * })
     * 
     */
    create<T extends DeviceCreateArgs>(args: SelectSubset<T, DeviceCreateArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Devices.
     * @param {DeviceCreateManyArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceCreateManyArgs>(args?: SelectSubset<T, DeviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Devices and returns the data saved in the database.
     * @param {DeviceCreateManyAndReturnArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Devices and only return the `id`
     * const deviceWithIdOnly = await prisma.device.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Device.
     * @param {DeviceDeleteArgs} args - Arguments to delete one Device.
     * @example
     * // Delete one Device
     * const Device = await prisma.device.delete({
     *   where: {
     *     // ... filter to delete one Device
     *   }
     * })
     * 
     */
    delete<T extends DeviceDeleteArgs>(args: SelectSubset<T, DeviceDeleteArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Device.
     * @param {DeviceUpdateArgs} args - Arguments to update one Device.
     * @example
     * // Update one Device
     * const device = await prisma.device.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceUpdateArgs>(args: SelectSubset<T, DeviceUpdateArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Devices.
     * @param {DeviceDeleteManyArgs} args - Arguments to filter Devices to delete.
     * @example
     * // Delete a few Devices
     * const { count } = await prisma.device.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceDeleteManyArgs>(args?: SelectSubset<T, DeviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Devices
     * const device = await prisma.device.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceUpdateManyArgs>(args: SelectSubset<T, DeviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Device.
     * @param {DeviceUpsertArgs} args - Arguments to update or create a Device.
     * @example
     * // Update or create a Device
     * const device = await prisma.device.upsert({
     *   create: {
     *     // ... data to create a Device
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Device we want to update
     *   }
     * })
     */
    upsert<T extends DeviceUpsertArgs>(args: SelectSubset<T, DeviceUpsertArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceCountArgs} args - Arguments to filter Devices to count.
     * @example
     * // Count the number of Devices
     * const count = await prisma.device.count({
     *   where: {
     *     // ... the filter for the Devices we want to count
     *   }
     * })
    **/
    count<T extends DeviceCountArgs>(
      args?: Subset<T, DeviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceAggregateArgs>(args: Subset<T, DeviceAggregateArgs>): Prisma.PrismaPromise<GetDeviceAggregateType<T>>

    /**
     * Group by Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceGroupByArgs['orderBy'] }
        : { orderBy?: DeviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Device model
   */
  readonly fields: DeviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Device.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    truck<T extends TruckDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TruckDefaultArgs<ExtArgs>>): Prisma__TruckClient<$Result.GetResult<Prisma.$TruckPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sensors<T extends Device$sensorsArgs<ExtArgs> = {}>(args?: Subset<T, Device$sensorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "findMany"> | Null>
    gpsPositions<T extends Device$gpsPositionsArgs<ExtArgs> = {}>(args?: Subset<T, Device$gpsPositionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GpsPositionPayload<ExtArgs>, T, "findMany"> | Null>
    tirePressureEvents<T extends Device$tirePressureEventsArgs<ExtArgs> = {}>(args?: Subset<T, Device$tirePressureEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TirePressureEventPayload<ExtArgs>, T, "findMany"> | Null>
    hubTemperatureEvents<T extends Device$hubTemperatureEventsArgs<ExtArgs> = {}>(args?: Subset<T, Device$hubTemperatureEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HubTemperatureEventPayload<ExtArgs>, T, "findMany"> | Null>
    deviceStatusEvents<T extends Device$deviceStatusEventsArgs<ExtArgs> = {}>(args?: Subset<T, Device$deviceStatusEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceStatusEventPayload<ExtArgs>, T, "findMany"> | Null>
    lockEvents<T extends Device$lockEventsArgs<ExtArgs> = {}>(args?: Subset<T, Device$lockEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LockEventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Device model
   */ 
  interface DeviceFieldRefs {
    readonly id: FieldRef<"Device", 'String'>
    readonly truckId: FieldRef<"Device", 'String'>
    readonly sn: FieldRef<"Device", 'String'>
    readonly simNumber: FieldRef<"Device", 'String'>
    readonly installedAt: FieldRef<"Device", 'DateTime'>
    readonly removedAt: FieldRef<"Device", 'DateTime'>
    readonly createdBy: FieldRef<"Device", 'String'>
    readonly updatedBy: FieldRef<"Device", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Device findUnique
   */
  export type DeviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findUniqueOrThrow
   */
  export type DeviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findFirst
   */
  export type DeviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device findFirstOrThrow
   */
  export type DeviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device findMany
   */
  export type DeviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Devices to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device create
   */
  export type DeviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The data needed to create a Device.
     */
    data: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
  }

  /**
   * Device createMany
   */
  export type DeviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Devices.
     */
    data: DeviceCreateManyInput | DeviceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Device createManyAndReturn
   */
  export type DeviceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Devices.
     */
    data: DeviceCreateManyInput | DeviceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Device update
   */
  export type DeviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The data needed to update a Device.
     */
    data: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
    /**
     * Choose, which Device to update.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device updateMany
   */
  export type DeviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Devices.
     */
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyInput>
    /**
     * Filter which Devices to update
     */
    where?: DeviceWhereInput
  }

  /**
   * Device upsert
   */
  export type DeviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The filter to search for the Device to update in case it exists.
     */
    where: DeviceWhereUniqueInput
    /**
     * In case the Device found by the `where` argument doesn't exist, create a new Device with this data.
     */
    create: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
    /**
     * In case the Device was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
  }

  /**
   * Device delete
   */
  export type DeviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter which Device to delete.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device deleteMany
   */
  export type DeviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Devices to delete
     */
    where?: DeviceWhereInput
  }

  /**
   * Device.sensors
   */
  export type Device$sensorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    where?: SensorWhereInput
    orderBy?: SensorOrderByWithRelationInput | SensorOrderByWithRelationInput[]
    cursor?: SensorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SensorScalarFieldEnum | SensorScalarFieldEnum[]
  }

  /**
   * Device.gpsPositions
   */
  export type Device$gpsPositionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GpsPosition
     */
    select?: GpsPositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GpsPositionInclude<ExtArgs> | null
    where?: GpsPositionWhereInput
    orderBy?: GpsPositionOrderByWithRelationInput | GpsPositionOrderByWithRelationInput[]
    cursor?: GpsPositionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GpsPositionScalarFieldEnum | GpsPositionScalarFieldEnum[]
  }

  /**
   * Device.tirePressureEvents
   */
  export type Device$tirePressureEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TirePressureEvent
     */
    select?: TirePressureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TirePressureEventInclude<ExtArgs> | null
    where?: TirePressureEventWhereInput
    orderBy?: TirePressureEventOrderByWithRelationInput | TirePressureEventOrderByWithRelationInput[]
    cursor?: TirePressureEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TirePressureEventScalarFieldEnum | TirePressureEventScalarFieldEnum[]
  }

  /**
   * Device.hubTemperatureEvents
   */
  export type Device$hubTemperatureEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HubTemperatureEvent
     */
    select?: HubTemperatureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HubTemperatureEventInclude<ExtArgs> | null
    where?: HubTemperatureEventWhereInput
    orderBy?: HubTemperatureEventOrderByWithRelationInput | HubTemperatureEventOrderByWithRelationInput[]
    cursor?: HubTemperatureEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HubTemperatureEventScalarFieldEnum | HubTemperatureEventScalarFieldEnum[]
  }

  /**
   * Device.deviceStatusEvents
   */
  export type Device$deviceStatusEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStatusEvent
     */
    select?: DeviceStatusEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceStatusEventInclude<ExtArgs> | null
    where?: DeviceStatusEventWhereInput
    orderBy?: DeviceStatusEventOrderByWithRelationInput | DeviceStatusEventOrderByWithRelationInput[]
    cursor?: DeviceStatusEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceStatusEventScalarFieldEnum | DeviceStatusEventScalarFieldEnum[]
  }

  /**
   * Device.lockEvents
   */
  export type Device$lockEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockEvent
     */
    select?: LockEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockEventInclude<ExtArgs> | null
    where?: LockEventWhereInput
    orderBy?: LockEventOrderByWithRelationInput | LockEventOrderByWithRelationInput[]
    cursor?: LockEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LockEventScalarFieldEnum | LockEventScalarFieldEnum[]
  }

  /**
   * Device without action
   */
  export type DeviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
  }


  /**
   * Model Sensor
   */

  export type AggregateSensor = {
    _count: SensorCountAggregateOutputType | null
    _avg: SensorAvgAggregateOutputType | null
    _sum: SensorSumAggregateOutputType | null
    _min: SensorMinAggregateOutputType | null
    _max: SensorMaxAggregateOutputType | null
  }

  export type SensorAvgAggregateOutputType = {
    positionNo: number | null
  }

  export type SensorSumAggregateOutputType = {
    positionNo: number | null
  }

  export type SensorMinAggregateOutputType = {
    id: string | null
    deviceId: string | null
    type: string | null
    positionNo: number | null
    sn: string | null
    installedAt: Date | null
    removedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type SensorMaxAggregateOutputType = {
    id: string | null
    deviceId: string | null
    type: string | null
    positionNo: number | null
    sn: string | null
    installedAt: Date | null
    removedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type SensorCountAggregateOutputType = {
    id: number
    deviceId: number
    type: number
    positionNo: number
    sn: number
    installedAt: number
    removedAt: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type SensorAvgAggregateInputType = {
    positionNo?: true
  }

  export type SensorSumAggregateInputType = {
    positionNo?: true
  }

  export type SensorMinAggregateInputType = {
    id?: true
    deviceId?: true
    type?: true
    positionNo?: true
    sn?: true
    installedAt?: true
    removedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type SensorMaxAggregateInputType = {
    id?: true
    deviceId?: true
    type?: true
    positionNo?: true
    sn?: true
    installedAt?: true
    removedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type SensorCountAggregateInputType = {
    id?: true
    deviceId?: true
    type?: true
    positionNo?: true
    sn?: true
    installedAt?: true
    removedAt?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type SensorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sensor to aggregate.
     */
    where?: SensorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sensors to fetch.
     */
    orderBy?: SensorOrderByWithRelationInput | SensorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SensorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sensors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sensors
    **/
    _count?: true | SensorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SensorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SensorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SensorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SensorMaxAggregateInputType
  }

  export type GetSensorAggregateType<T extends SensorAggregateArgs> = {
        [P in keyof T & keyof AggregateSensor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSensor[P]>
      : GetScalarType<T[P], AggregateSensor[P]>
  }




  export type SensorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SensorWhereInput
    orderBy?: SensorOrderByWithAggregationInput | SensorOrderByWithAggregationInput[]
    by: SensorScalarFieldEnum[] | SensorScalarFieldEnum
    having?: SensorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SensorCountAggregateInputType | true
    _avg?: SensorAvgAggregateInputType
    _sum?: SensorSumAggregateInputType
    _min?: SensorMinAggregateInputType
    _max?: SensorMaxAggregateInputType
  }

  export type SensorGroupByOutputType = {
    id: string
    deviceId: string
    type: string
    positionNo: number
    sn: string | null
    installedAt: Date | null
    removedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    _count: SensorCountAggregateOutputType | null
    _avg: SensorAvgAggregateOutputType | null
    _sum: SensorSumAggregateOutputType | null
    _min: SensorMinAggregateOutputType | null
    _max: SensorMaxAggregateOutputType | null
  }

  type GetSensorGroupByPayload<T extends SensorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SensorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SensorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SensorGroupByOutputType[P]>
            : GetScalarType<T[P], SensorGroupByOutputType[P]>
        }
      >
    >


  export type SensorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    type?: boolean
    positionNo?: boolean
    sn?: boolean
    installedAt?: boolean
    removedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sensor"]>

  export type SensorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    type?: boolean
    positionNo?: boolean
    sn?: boolean
    installedAt?: boolean
    removedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sensor"]>

  export type SensorSelectScalar = {
    id?: boolean
    deviceId?: boolean
    type?: boolean
    positionNo?: boolean
    sn?: boolean
    installedAt?: boolean
    removedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type SensorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }
  export type SensorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }

  export type $SensorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sensor"
    objects: {
      device: Prisma.$DevicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deviceId: string
      type: string
      positionNo: number
      sn: string | null
      installedAt: Date | null
      removedAt: Date | null
      createdBy: string | null
      updatedBy: string | null
    }, ExtArgs["result"]["sensor"]>
    composites: {}
  }

  type SensorGetPayload<S extends boolean | null | undefined | SensorDefaultArgs> = $Result.GetResult<Prisma.$SensorPayload, S>

  type SensorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SensorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SensorCountAggregateInputType | true
    }

  export interface SensorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sensor'], meta: { name: 'Sensor' } }
    /**
     * Find zero or one Sensor that matches the filter.
     * @param {SensorFindUniqueArgs} args - Arguments to find a Sensor
     * @example
     * // Get one Sensor
     * const sensor = await prisma.sensor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SensorFindUniqueArgs>(args: SelectSubset<T, SensorFindUniqueArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Sensor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SensorFindUniqueOrThrowArgs} args - Arguments to find a Sensor
     * @example
     * // Get one Sensor
     * const sensor = await prisma.sensor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SensorFindUniqueOrThrowArgs>(args: SelectSubset<T, SensorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Sensor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorFindFirstArgs} args - Arguments to find a Sensor
     * @example
     * // Get one Sensor
     * const sensor = await prisma.sensor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SensorFindFirstArgs>(args?: SelectSubset<T, SensorFindFirstArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Sensor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorFindFirstOrThrowArgs} args - Arguments to find a Sensor
     * @example
     * // Get one Sensor
     * const sensor = await prisma.sensor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SensorFindFirstOrThrowArgs>(args?: SelectSubset<T, SensorFindFirstOrThrowArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sensors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sensors
     * const sensors = await prisma.sensor.findMany()
     * 
     * // Get first 10 Sensors
     * const sensors = await prisma.sensor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sensorWithIdOnly = await prisma.sensor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SensorFindManyArgs>(args?: SelectSubset<T, SensorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Sensor.
     * @param {SensorCreateArgs} args - Arguments to create a Sensor.
     * @example
     * // Create one Sensor
     * const Sensor = await prisma.sensor.create({
     *   data: {
     *     // ... data to create a Sensor
     *   }
     * })
     * 
     */
    create<T extends SensorCreateArgs>(args: SelectSubset<T, SensorCreateArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sensors.
     * @param {SensorCreateManyArgs} args - Arguments to create many Sensors.
     * @example
     * // Create many Sensors
     * const sensor = await prisma.sensor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SensorCreateManyArgs>(args?: SelectSubset<T, SensorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sensors and returns the data saved in the database.
     * @param {SensorCreateManyAndReturnArgs} args - Arguments to create many Sensors.
     * @example
     * // Create many Sensors
     * const sensor = await prisma.sensor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sensors and only return the `id`
     * const sensorWithIdOnly = await prisma.sensor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SensorCreateManyAndReturnArgs>(args?: SelectSubset<T, SensorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Sensor.
     * @param {SensorDeleteArgs} args - Arguments to delete one Sensor.
     * @example
     * // Delete one Sensor
     * const Sensor = await prisma.sensor.delete({
     *   where: {
     *     // ... filter to delete one Sensor
     *   }
     * })
     * 
     */
    delete<T extends SensorDeleteArgs>(args: SelectSubset<T, SensorDeleteArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Sensor.
     * @param {SensorUpdateArgs} args - Arguments to update one Sensor.
     * @example
     * // Update one Sensor
     * const sensor = await prisma.sensor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SensorUpdateArgs>(args: SelectSubset<T, SensorUpdateArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sensors.
     * @param {SensorDeleteManyArgs} args - Arguments to filter Sensors to delete.
     * @example
     * // Delete a few Sensors
     * const { count } = await prisma.sensor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SensorDeleteManyArgs>(args?: SelectSubset<T, SensorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sensors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sensors
     * const sensor = await prisma.sensor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SensorUpdateManyArgs>(args: SelectSubset<T, SensorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sensor.
     * @param {SensorUpsertArgs} args - Arguments to update or create a Sensor.
     * @example
     * // Update or create a Sensor
     * const sensor = await prisma.sensor.upsert({
     *   create: {
     *     // ... data to create a Sensor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sensor we want to update
     *   }
     * })
     */
    upsert<T extends SensorUpsertArgs>(args: SelectSubset<T, SensorUpsertArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sensors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorCountArgs} args - Arguments to filter Sensors to count.
     * @example
     * // Count the number of Sensors
     * const count = await prisma.sensor.count({
     *   where: {
     *     // ... the filter for the Sensors we want to count
     *   }
     * })
    **/
    count<T extends SensorCountArgs>(
      args?: Subset<T, SensorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SensorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sensor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SensorAggregateArgs>(args: Subset<T, SensorAggregateArgs>): Prisma.PrismaPromise<GetSensorAggregateType<T>>

    /**
     * Group by Sensor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SensorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SensorGroupByArgs['orderBy'] }
        : { orderBy?: SensorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SensorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSensorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sensor model
   */
  readonly fields: SensorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sensor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SensorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends DeviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceDefaultArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sensor model
   */ 
  interface SensorFieldRefs {
    readonly id: FieldRef<"Sensor", 'String'>
    readonly deviceId: FieldRef<"Sensor", 'String'>
    readonly type: FieldRef<"Sensor", 'String'>
    readonly positionNo: FieldRef<"Sensor", 'Int'>
    readonly sn: FieldRef<"Sensor", 'String'>
    readonly installedAt: FieldRef<"Sensor", 'DateTime'>
    readonly removedAt: FieldRef<"Sensor", 'DateTime'>
    readonly createdBy: FieldRef<"Sensor", 'String'>
    readonly updatedBy: FieldRef<"Sensor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Sensor findUnique
   */
  export type SensorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * Filter, which Sensor to fetch.
     */
    where: SensorWhereUniqueInput
  }

  /**
   * Sensor findUniqueOrThrow
   */
  export type SensorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * Filter, which Sensor to fetch.
     */
    where: SensorWhereUniqueInput
  }

  /**
   * Sensor findFirst
   */
  export type SensorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * Filter, which Sensor to fetch.
     */
    where?: SensorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sensors to fetch.
     */
    orderBy?: SensorOrderByWithRelationInput | SensorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sensors.
     */
    cursor?: SensorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sensors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sensors.
     */
    distinct?: SensorScalarFieldEnum | SensorScalarFieldEnum[]
  }

  /**
   * Sensor findFirstOrThrow
   */
  export type SensorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * Filter, which Sensor to fetch.
     */
    where?: SensorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sensors to fetch.
     */
    orderBy?: SensorOrderByWithRelationInput | SensorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sensors.
     */
    cursor?: SensorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sensors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sensors.
     */
    distinct?: SensorScalarFieldEnum | SensorScalarFieldEnum[]
  }

  /**
   * Sensor findMany
   */
  export type SensorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * Filter, which Sensors to fetch.
     */
    where?: SensorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sensors to fetch.
     */
    orderBy?: SensorOrderByWithRelationInput | SensorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sensors.
     */
    cursor?: SensorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sensors.
     */
    skip?: number
    distinct?: SensorScalarFieldEnum | SensorScalarFieldEnum[]
  }

  /**
   * Sensor create
   */
  export type SensorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * The data needed to create a Sensor.
     */
    data: XOR<SensorCreateInput, SensorUncheckedCreateInput>
  }

  /**
   * Sensor createMany
   */
  export type SensorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sensors.
     */
    data: SensorCreateManyInput | SensorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sensor createManyAndReturn
   */
  export type SensorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sensors.
     */
    data: SensorCreateManyInput | SensorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sensor update
   */
  export type SensorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * The data needed to update a Sensor.
     */
    data: XOR<SensorUpdateInput, SensorUncheckedUpdateInput>
    /**
     * Choose, which Sensor to update.
     */
    where: SensorWhereUniqueInput
  }

  /**
   * Sensor updateMany
   */
  export type SensorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sensors.
     */
    data: XOR<SensorUpdateManyMutationInput, SensorUncheckedUpdateManyInput>
    /**
     * Filter which Sensors to update
     */
    where?: SensorWhereInput
  }

  /**
   * Sensor upsert
   */
  export type SensorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * The filter to search for the Sensor to update in case it exists.
     */
    where: SensorWhereUniqueInput
    /**
     * In case the Sensor found by the `where` argument doesn't exist, create a new Sensor with this data.
     */
    create: XOR<SensorCreateInput, SensorUncheckedCreateInput>
    /**
     * In case the Sensor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SensorUpdateInput, SensorUncheckedUpdateInput>
  }

  /**
   * Sensor delete
   */
  export type SensorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * Filter which Sensor to delete.
     */
    where: SensorWhereUniqueInput
  }

  /**
   * Sensor deleteMany
   */
  export type SensorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sensors to delete
     */
    where?: SensorWhereInput
  }

  /**
   * Sensor without action
   */
  export type SensorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
  }


  /**
   * Model TruckStatusEvent
   */

  export type AggregateTruckStatusEvent = {
    _count: TruckStatusEventCountAggregateOutputType | null
    _min: TruckStatusEventMinAggregateOutputType | null
    _max: TruckStatusEventMaxAggregateOutputType | null
  }

  export type TruckStatusEventMinAggregateOutputType = {
    id: string | null
    truckId: string | null
    status: $Enums.TruckStatus | null
    note: string | null
    changedAt: Date | null
    createdBy: string | null
  }

  export type TruckStatusEventMaxAggregateOutputType = {
    id: string | null
    truckId: string | null
    status: $Enums.TruckStatus | null
    note: string | null
    changedAt: Date | null
    createdBy: string | null
  }

  export type TruckStatusEventCountAggregateOutputType = {
    id: number
    truckId: number
    status: number
    note: number
    changedAt: number
    createdBy: number
    _all: number
  }


  export type TruckStatusEventMinAggregateInputType = {
    id?: true
    truckId?: true
    status?: true
    note?: true
    changedAt?: true
    createdBy?: true
  }

  export type TruckStatusEventMaxAggregateInputType = {
    id?: true
    truckId?: true
    status?: true
    note?: true
    changedAt?: true
    createdBy?: true
  }

  export type TruckStatusEventCountAggregateInputType = {
    id?: true
    truckId?: true
    status?: true
    note?: true
    changedAt?: true
    createdBy?: true
    _all?: true
  }

  export type TruckStatusEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TruckStatusEvent to aggregate.
     */
    where?: TruckStatusEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TruckStatusEvents to fetch.
     */
    orderBy?: TruckStatusEventOrderByWithRelationInput | TruckStatusEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TruckStatusEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TruckStatusEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TruckStatusEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TruckStatusEvents
    **/
    _count?: true | TruckStatusEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TruckStatusEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TruckStatusEventMaxAggregateInputType
  }

  export type GetTruckStatusEventAggregateType<T extends TruckStatusEventAggregateArgs> = {
        [P in keyof T & keyof AggregateTruckStatusEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTruckStatusEvent[P]>
      : GetScalarType<T[P], AggregateTruckStatusEvent[P]>
  }




  export type TruckStatusEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TruckStatusEventWhereInput
    orderBy?: TruckStatusEventOrderByWithAggregationInput | TruckStatusEventOrderByWithAggregationInput[]
    by: TruckStatusEventScalarFieldEnum[] | TruckStatusEventScalarFieldEnum
    having?: TruckStatusEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TruckStatusEventCountAggregateInputType | true
    _min?: TruckStatusEventMinAggregateInputType
    _max?: TruckStatusEventMaxAggregateInputType
  }

  export type TruckStatusEventGroupByOutputType = {
    id: string
    truckId: string
    status: $Enums.TruckStatus
    note: string | null
    changedAt: Date
    createdBy: string | null
    _count: TruckStatusEventCountAggregateOutputType | null
    _min: TruckStatusEventMinAggregateOutputType | null
    _max: TruckStatusEventMaxAggregateOutputType | null
  }

  type GetTruckStatusEventGroupByPayload<T extends TruckStatusEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TruckStatusEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TruckStatusEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TruckStatusEventGroupByOutputType[P]>
            : GetScalarType<T[P], TruckStatusEventGroupByOutputType[P]>
        }
      >
    >


  export type TruckStatusEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    truckId?: boolean
    status?: boolean
    note?: boolean
    changedAt?: boolean
    createdBy?: boolean
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["truckStatusEvent"]>

  export type TruckStatusEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    truckId?: boolean
    status?: boolean
    note?: boolean
    changedAt?: boolean
    createdBy?: boolean
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["truckStatusEvent"]>

  export type TruckStatusEventSelectScalar = {
    id?: boolean
    truckId?: boolean
    status?: boolean
    note?: boolean
    changedAt?: boolean
    createdBy?: boolean
  }

  export type TruckStatusEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }
  export type TruckStatusEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }

  export type $TruckStatusEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TruckStatusEvent"
    objects: {
      truck: Prisma.$TruckPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      truckId: string
      status: $Enums.TruckStatus
      note: string | null
      changedAt: Date
      createdBy: string | null
    }, ExtArgs["result"]["truckStatusEvent"]>
    composites: {}
  }

  type TruckStatusEventGetPayload<S extends boolean | null | undefined | TruckStatusEventDefaultArgs> = $Result.GetResult<Prisma.$TruckStatusEventPayload, S>

  type TruckStatusEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TruckStatusEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TruckStatusEventCountAggregateInputType | true
    }

  export interface TruckStatusEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TruckStatusEvent'], meta: { name: 'TruckStatusEvent' } }
    /**
     * Find zero or one TruckStatusEvent that matches the filter.
     * @param {TruckStatusEventFindUniqueArgs} args - Arguments to find a TruckStatusEvent
     * @example
     * // Get one TruckStatusEvent
     * const truckStatusEvent = await prisma.truckStatusEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TruckStatusEventFindUniqueArgs>(args: SelectSubset<T, TruckStatusEventFindUniqueArgs<ExtArgs>>): Prisma__TruckStatusEventClient<$Result.GetResult<Prisma.$TruckStatusEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TruckStatusEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TruckStatusEventFindUniqueOrThrowArgs} args - Arguments to find a TruckStatusEvent
     * @example
     * // Get one TruckStatusEvent
     * const truckStatusEvent = await prisma.truckStatusEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TruckStatusEventFindUniqueOrThrowArgs>(args: SelectSubset<T, TruckStatusEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TruckStatusEventClient<$Result.GetResult<Prisma.$TruckStatusEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TruckStatusEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckStatusEventFindFirstArgs} args - Arguments to find a TruckStatusEvent
     * @example
     * // Get one TruckStatusEvent
     * const truckStatusEvent = await prisma.truckStatusEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TruckStatusEventFindFirstArgs>(args?: SelectSubset<T, TruckStatusEventFindFirstArgs<ExtArgs>>): Prisma__TruckStatusEventClient<$Result.GetResult<Prisma.$TruckStatusEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TruckStatusEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckStatusEventFindFirstOrThrowArgs} args - Arguments to find a TruckStatusEvent
     * @example
     * // Get one TruckStatusEvent
     * const truckStatusEvent = await prisma.truckStatusEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TruckStatusEventFindFirstOrThrowArgs>(args?: SelectSubset<T, TruckStatusEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__TruckStatusEventClient<$Result.GetResult<Prisma.$TruckStatusEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TruckStatusEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckStatusEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TruckStatusEvents
     * const truckStatusEvents = await prisma.truckStatusEvent.findMany()
     * 
     * // Get first 10 TruckStatusEvents
     * const truckStatusEvents = await prisma.truckStatusEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const truckStatusEventWithIdOnly = await prisma.truckStatusEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TruckStatusEventFindManyArgs>(args?: SelectSubset<T, TruckStatusEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TruckStatusEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TruckStatusEvent.
     * @param {TruckStatusEventCreateArgs} args - Arguments to create a TruckStatusEvent.
     * @example
     * // Create one TruckStatusEvent
     * const TruckStatusEvent = await prisma.truckStatusEvent.create({
     *   data: {
     *     // ... data to create a TruckStatusEvent
     *   }
     * })
     * 
     */
    create<T extends TruckStatusEventCreateArgs>(args: SelectSubset<T, TruckStatusEventCreateArgs<ExtArgs>>): Prisma__TruckStatusEventClient<$Result.GetResult<Prisma.$TruckStatusEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TruckStatusEvents.
     * @param {TruckStatusEventCreateManyArgs} args - Arguments to create many TruckStatusEvents.
     * @example
     * // Create many TruckStatusEvents
     * const truckStatusEvent = await prisma.truckStatusEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TruckStatusEventCreateManyArgs>(args?: SelectSubset<T, TruckStatusEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TruckStatusEvents and returns the data saved in the database.
     * @param {TruckStatusEventCreateManyAndReturnArgs} args - Arguments to create many TruckStatusEvents.
     * @example
     * // Create many TruckStatusEvents
     * const truckStatusEvent = await prisma.truckStatusEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TruckStatusEvents and only return the `id`
     * const truckStatusEventWithIdOnly = await prisma.truckStatusEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TruckStatusEventCreateManyAndReturnArgs>(args?: SelectSubset<T, TruckStatusEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TruckStatusEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TruckStatusEvent.
     * @param {TruckStatusEventDeleteArgs} args - Arguments to delete one TruckStatusEvent.
     * @example
     * // Delete one TruckStatusEvent
     * const TruckStatusEvent = await prisma.truckStatusEvent.delete({
     *   where: {
     *     // ... filter to delete one TruckStatusEvent
     *   }
     * })
     * 
     */
    delete<T extends TruckStatusEventDeleteArgs>(args: SelectSubset<T, TruckStatusEventDeleteArgs<ExtArgs>>): Prisma__TruckStatusEventClient<$Result.GetResult<Prisma.$TruckStatusEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TruckStatusEvent.
     * @param {TruckStatusEventUpdateArgs} args - Arguments to update one TruckStatusEvent.
     * @example
     * // Update one TruckStatusEvent
     * const truckStatusEvent = await prisma.truckStatusEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TruckStatusEventUpdateArgs>(args: SelectSubset<T, TruckStatusEventUpdateArgs<ExtArgs>>): Prisma__TruckStatusEventClient<$Result.GetResult<Prisma.$TruckStatusEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TruckStatusEvents.
     * @param {TruckStatusEventDeleteManyArgs} args - Arguments to filter TruckStatusEvents to delete.
     * @example
     * // Delete a few TruckStatusEvents
     * const { count } = await prisma.truckStatusEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TruckStatusEventDeleteManyArgs>(args?: SelectSubset<T, TruckStatusEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TruckStatusEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckStatusEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TruckStatusEvents
     * const truckStatusEvent = await prisma.truckStatusEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TruckStatusEventUpdateManyArgs>(args: SelectSubset<T, TruckStatusEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TruckStatusEvent.
     * @param {TruckStatusEventUpsertArgs} args - Arguments to update or create a TruckStatusEvent.
     * @example
     * // Update or create a TruckStatusEvent
     * const truckStatusEvent = await prisma.truckStatusEvent.upsert({
     *   create: {
     *     // ... data to create a TruckStatusEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TruckStatusEvent we want to update
     *   }
     * })
     */
    upsert<T extends TruckStatusEventUpsertArgs>(args: SelectSubset<T, TruckStatusEventUpsertArgs<ExtArgs>>): Prisma__TruckStatusEventClient<$Result.GetResult<Prisma.$TruckStatusEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TruckStatusEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckStatusEventCountArgs} args - Arguments to filter TruckStatusEvents to count.
     * @example
     * // Count the number of TruckStatusEvents
     * const count = await prisma.truckStatusEvent.count({
     *   where: {
     *     // ... the filter for the TruckStatusEvents we want to count
     *   }
     * })
    **/
    count<T extends TruckStatusEventCountArgs>(
      args?: Subset<T, TruckStatusEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TruckStatusEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TruckStatusEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckStatusEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TruckStatusEventAggregateArgs>(args: Subset<T, TruckStatusEventAggregateArgs>): Prisma.PrismaPromise<GetTruckStatusEventAggregateType<T>>

    /**
     * Group by TruckStatusEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckStatusEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TruckStatusEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TruckStatusEventGroupByArgs['orderBy'] }
        : { orderBy?: TruckStatusEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TruckStatusEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTruckStatusEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TruckStatusEvent model
   */
  readonly fields: TruckStatusEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TruckStatusEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TruckStatusEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    truck<T extends TruckDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TruckDefaultArgs<ExtArgs>>): Prisma__TruckClient<$Result.GetResult<Prisma.$TruckPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TruckStatusEvent model
   */ 
  interface TruckStatusEventFieldRefs {
    readonly id: FieldRef<"TruckStatusEvent", 'String'>
    readonly truckId: FieldRef<"TruckStatusEvent", 'String'>
    readonly status: FieldRef<"TruckStatusEvent", 'TruckStatus'>
    readonly note: FieldRef<"TruckStatusEvent", 'String'>
    readonly changedAt: FieldRef<"TruckStatusEvent", 'DateTime'>
    readonly createdBy: FieldRef<"TruckStatusEvent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TruckStatusEvent findUnique
   */
  export type TruckStatusEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckStatusEvent
     */
    select?: TruckStatusEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckStatusEventInclude<ExtArgs> | null
    /**
     * Filter, which TruckStatusEvent to fetch.
     */
    where: TruckStatusEventWhereUniqueInput
  }

  /**
   * TruckStatusEvent findUniqueOrThrow
   */
  export type TruckStatusEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckStatusEvent
     */
    select?: TruckStatusEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckStatusEventInclude<ExtArgs> | null
    /**
     * Filter, which TruckStatusEvent to fetch.
     */
    where: TruckStatusEventWhereUniqueInput
  }

  /**
   * TruckStatusEvent findFirst
   */
  export type TruckStatusEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckStatusEvent
     */
    select?: TruckStatusEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckStatusEventInclude<ExtArgs> | null
    /**
     * Filter, which TruckStatusEvent to fetch.
     */
    where?: TruckStatusEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TruckStatusEvents to fetch.
     */
    orderBy?: TruckStatusEventOrderByWithRelationInput | TruckStatusEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TruckStatusEvents.
     */
    cursor?: TruckStatusEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TruckStatusEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TruckStatusEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TruckStatusEvents.
     */
    distinct?: TruckStatusEventScalarFieldEnum | TruckStatusEventScalarFieldEnum[]
  }

  /**
   * TruckStatusEvent findFirstOrThrow
   */
  export type TruckStatusEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckStatusEvent
     */
    select?: TruckStatusEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckStatusEventInclude<ExtArgs> | null
    /**
     * Filter, which TruckStatusEvent to fetch.
     */
    where?: TruckStatusEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TruckStatusEvents to fetch.
     */
    orderBy?: TruckStatusEventOrderByWithRelationInput | TruckStatusEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TruckStatusEvents.
     */
    cursor?: TruckStatusEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TruckStatusEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TruckStatusEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TruckStatusEvents.
     */
    distinct?: TruckStatusEventScalarFieldEnum | TruckStatusEventScalarFieldEnum[]
  }

  /**
   * TruckStatusEvent findMany
   */
  export type TruckStatusEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckStatusEvent
     */
    select?: TruckStatusEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckStatusEventInclude<ExtArgs> | null
    /**
     * Filter, which TruckStatusEvents to fetch.
     */
    where?: TruckStatusEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TruckStatusEvents to fetch.
     */
    orderBy?: TruckStatusEventOrderByWithRelationInput | TruckStatusEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TruckStatusEvents.
     */
    cursor?: TruckStatusEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TruckStatusEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TruckStatusEvents.
     */
    skip?: number
    distinct?: TruckStatusEventScalarFieldEnum | TruckStatusEventScalarFieldEnum[]
  }

  /**
   * TruckStatusEvent create
   */
  export type TruckStatusEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckStatusEvent
     */
    select?: TruckStatusEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckStatusEventInclude<ExtArgs> | null
    /**
     * The data needed to create a TruckStatusEvent.
     */
    data: XOR<TruckStatusEventCreateInput, TruckStatusEventUncheckedCreateInput>
  }

  /**
   * TruckStatusEvent createMany
   */
  export type TruckStatusEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TruckStatusEvents.
     */
    data: TruckStatusEventCreateManyInput | TruckStatusEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TruckStatusEvent createManyAndReturn
   */
  export type TruckStatusEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckStatusEvent
     */
    select?: TruckStatusEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TruckStatusEvents.
     */
    data: TruckStatusEventCreateManyInput | TruckStatusEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckStatusEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TruckStatusEvent update
   */
  export type TruckStatusEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckStatusEvent
     */
    select?: TruckStatusEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckStatusEventInclude<ExtArgs> | null
    /**
     * The data needed to update a TruckStatusEvent.
     */
    data: XOR<TruckStatusEventUpdateInput, TruckStatusEventUncheckedUpdateInput>
    /**
     * Choose, which TruckStatusEvent to update.
     */
    where: TruckStatusEventWhereUniqueInput
  }

  /**
   * TruckStatusEvent updateMany
   */
  export type TruckStatusEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TruckStatusEvents.
     */
    data: XOR<TruckStatusEventUpdateManyMutationInput, TruckStatusEventUncheckedUpdateManyInput>
    /**
     * Filter which TruckStatusEvents to update
     */
    where?: TruckStatusEventWhereInput
  }

  /**
   * TruckStatusEvent upsert
   */
  export type TruckStatusEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckStatusEvent
     */
    select?: TruckStatusEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckStatusEventInclude<ExtArgs> | null
    /**
     * The filter to search for the TruckStatusEvent to update in case it exists.
     */
    where: TruckStatusEventWhereUniqueInput
    /**
     * In case the TruckStatusEvent found by the `where` argument doesn't exist, create a new TruckStatusEvent with this data.
     */
    create: XOR<TruckStatusEventCreateInput, TruckStatusEventUncheckedCreateInput>
    /**
     * In case the TruckStatusEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TruckStatusEventUpdateInput, TruckStatusEventUncheckedUpdateInput>
  }

  /**
   * TruckStatusEvent delete
   */
  export type TruckStatusEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckStatusEvent
     */
    select?: TruckStatusEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckStatusEventInclude<ExtArgs> | null
    /**
     * Filter which TruckStatusEvent to delete.
     */
    where: TruckStatusEventWhereUniqueInput
  }

  /**
   * TruckStatusEvent deleteMany
   */
  export type TruckStatusEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TruckStatusEvents to delete
     */
    where?: TruckStatusEventWhereInput
  }

  /**
   * TruckStatusEvent without action
   */
  export type TruckStatusEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckStatusEvent
     */
    select?: TruckStatusEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckStatusEventInclude<ExtArgs> | null
  }


  /**
   * Model Geofence
   */

  export type AggregateGeofence = {
    _count: GeofenceCountAggregateOutputType | null
    _min: GeofenceMinAggregateOutputType | null
    _max: GeofenceMaxAggregateOutputType | null
  }

  export type GeofenceMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type GeofenceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type GeofenceCountAggregateOutputType = {
    id: number
    name: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type GeofenceMinAggregateInputType = {
    id?: true
    name?: true
    createdBy?: true
    createdAt?: true
  }

  export type GeofenceMaxAggregateInputType = {
    id?: true
    name?: true
    createdBy?: true
    createdAt?: true
  }

  export type GeofenceCountAggregateInputType = {
    id?: true
    name?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type GeofenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Geofence to aggregate.
     */
    where?: GeofenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Geofences to fetch.
     */
    orderBy?: GeofenceOrderByWithRelationInput | GeofenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GeofenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Geofences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Geofences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Geofences
    **/
    _count?: true | GeofenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GeofenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GeofenceMaxAggregateInputType
  }

  export type GetGeofenceAggregateType<T extends GeofenceAggregateArgs> = {
        [P in keyof T & keyof AggregateGeofence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGeofence[P]>
      : GetScalarType<T[P], AggregateGeofence[P]>
  }




  export type GeofenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeofenceWhereInput
    orderBy?: GeofenceOrderByWithAggregationInput | GeofenceOrderByWithAggregationInput[]
    by: GeofenceScalarFieldEnum[] | GeofenceScalarFieldEnum
    having?: GeofenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GeofenceCountAggregateInputType | true
    _min?: GeofenceMinAggregateInputType
    _max?: GeofenceMaxAggregateInputType
  }

  export type GeofenceGroupByOutputType = {
    id: string
    name: string
    createdBy: string | null
    createdAt: Date
    _count: GeofenceCountAggregateOutputType | null
    _min: GeofenceMinAggregateOutputType | null
    _max: GeofenceMaxAggregateOutputType | null
  }

  type GetGeofenceGroupByPayload<T extends GeofenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GeofenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GeofenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GeofenceGroupByOutputType[P]>
            : GetScalarType<T[P], GeofenceGroupByOutputType[P]>
        }
      >
    >


  export type GeofenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["geofence"]>

  export type GeofenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["geofence"]>

  export type GeofenceSelectScalar = {
    id?: boolean
    name?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }


  export type $GeofencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Geofence"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["geofence"]>
    composites: {}
  }

  type GeofenceGetPayload<S extends boolean | null | undefined | GeofenceDefaultArgs> = $Result.GetResult<Prisma.$GeofencePayload, S>

  type GeofenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GeofenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GeofenceCountAggregateInputType | true
    }

  export interface GeofenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Geofence'], meta: { name: 'Geofence' } }
    /**
     * Find zero or one Geofence that matches the filter.
     * @param {GeofenceFindUniqueArgs} args - Arguments to find a Geofence
     * @example
     * // Get one Geofence
     * const geofence = await prisma.geofence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GeofenceFindUniqueArgs>(args: SelectSubset<T, GeofenceFindUniqueArgs<ExtArgs>>): Prisma__GeofenceClient<$Result.GetResult<Prisma.$GeofencePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Geofence that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GeofenceFindUniqueOrThrowArgs} args - Arguments to find a Geofence
     * @example
     * // Get one Geofence
     * const geofence = await prisma.geofence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GeofenceFindUniqueOrThrowArgs>(args: SelectSubset<T, GeofenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GeofenceClient<$Result.GetResult<Prisma.$GeofencePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Geofence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeofenceFindFirstArgs} args - Arguments to find a Geofence
     * @example
     * // Get one Geofence
     * const geofence = await prisma.geofence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GeofenceFindFirstArgs>(args?: SelectSubset<T, GeofenceFindFirstArgs<ExtArgs>>): Prisma__GeofenceClient<$Result.GetResult<Prisma.$GeofencePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Geofence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeofenceFindFirstOrThrowArgs} args - Arguments to find a Geofence
     * @example
     * // Get one Geofence
     * const geofence = await prisma.geofence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GeofenceFindFirstOrThrowArgs>(args?: SelectSubset<T, GeofenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__GeofenceClient<$Result.GetResult<Prisma.$GeofencePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Geofences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeofenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Geofences
     * const geofences = await prisma.geofence.findMany()
     * 
     * // Get first 10 Geofences
     * const geofences = await prisma.geofence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const geofenceWithIdOnly = await prisma.geofence.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GeofenceFindManyArgs>(args?: SelectSubset<T, GeofenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeofencePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Geofence.
     * @param {GeofenceCreateArgs} args - Arguments to create a Geofence.
     * @example
     * // Create one Geofence
     * const Geofence = await prisma.geofence.create({
     *   data: {
     *     // ... data to create a Geofence
     *   }
     * })
     * 
     */
    create<T extends GeofenceCreateArgs>(args: SelectSubset<T, GeofenceCreateArgs<ExtArgs>>): Prisma__GeofenceClient<$Result.GetResult<Prisma.$GeofencePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Geofences.
     * @param {GeofenceCreateManyArgs} args - Arguments to create many Geofences.
     * @example
     * // Create many Geofences
     * const geofence = await prisma.geofence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GeofenceCreateManyArgs>(args?: SelectSubset<T, GeofenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Geofences and returns the data saved in the database.
     * @param {GeofenceCreateManyAndReturnArgs} args - Arguments to create many Geofences.
     * @example
     * // Create many Geofences
     * const geofence = await prisma.geofence.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Geofences and only return the `id`
     * const geofenceWithIdOnly = await prisma.geofence.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GeofenceCreateManyAndReturnArgs>(args?: SelectSubset<T, GeofenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeofencePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Geofence.
     * @param {GeofenceDeleteArgs} args - Arguments to delete one Geofence.
     * @example
     * // Delete one Geofence
     * const Geofence = await prisma.geofence.delete({
     *   where: {
     *     // ... filter to delete one Geofence
     *   }
     * })
     * 
     */
    delete<T extends GeofenceDeleteArgs>(args: SelectSubset<T, GeofenceDeleteArgs<ExtArgs>>): Prisma__GeofenceClient<$Result.GetResult<Prisma.$GeofencePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Geofence.
     * @param {GeofenceUpdateArgs} args - Arguments to update one Geofence.
     * @example
     * // Update one Geofence
     * const geofence = await prisma.geofence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GeofenceUpdateArgs>(args: SelectSubset<T, GeofenceUpdateArgs<ExtArgs>>): Prisma__GeofenceClient<$Result.GetResult<Prisma.$GeofencePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Geofences.
     * @param {GeofenceDeleteManyArgs} args - Arguments to filter Geofences to delete.
     * @example
     * // Delete a few Geofences
     * const { count } = await prisma.geofence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GeofenceDeleteManyArgs>(args?: SelectSubset<T, GeofenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Geofences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeofenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Geofences
     * const geofence = await prisma.geofence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GeofenceUpdateManyArgs>(args: SelectSubset<T, GeofenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Geofence.
     * @param {GeofenceUpsertArgs} args - Arguments to update or create a Geofence.
     * @example
     * // Update or create a Geofence
     * const geofence = await prisma.geofence.upsert({
     *   create: {
     *     // ... data to create a Geofence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Geofence we want to update
     *   }
     * })
     */
    upsert<T extends GeofenceUpsertArgs>(args: SelectSubset<T, GeofenceUpsertArgs<ExtArgs>>): Prisma__GeofenceClient<$Result.GetResult<Prisma.$GeofencePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Geofences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeofenceCountArgs} args - Arguments to filter Geofences to count.
     * @example
     * // Count the number of Geofences
     * const count = await prisma.geofence.count({
     *   where: {
     *     // ... the filter for the Geofences we want to count
     *   }
     * })
    **/
    count<T extends GeofenceCountArgs>(
      args?: Subset<T, GeofenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GeofenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Geofence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeofenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GeofenceAggregateArgs>(args: Subset<T, GeofenceAggregateArgs>): Prisma.PrismaPromise<GetGeofenceAggregateType<T>>

    /**
     * Group by Geofence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeofenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GeofenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GeofenceGroupByArgs['orderBy'] }
        : { orderBy?: GeofenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GeofenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGeofenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Geofence model
   */
  readonly fields: GeofenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Geofence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GeofenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Geofence model
   */ 
  interface GeofenceFieldRefs {
    readonly id: FieldRef<"Geofence", 'String'>
    readonly name: FieldRef<"Geofence", 'String'>
    readonly createdBy: FieldRef<"Geofence", 'String'>
    readonly createdAt: FieldRef<"Geofence", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Geofence findUnique
   */
  export type GeofenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Geofence
     */
    select?: GeofenceSelect<ExtArgs> | null
    /**
     * Filter, which Geofence to fetch.
     */
    where: GeofenceWhereUniqueInput
  }

  /**
   * Geofence findUniqueOrThrow
   */
  export type GeofenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Geofence
     */
    select?: GeofenceSelect<ExtArgs> | null
    /**
     * Filter, which Geofence to fetch.
     */
    where: GeofenceWhereUniqueInput
  }

  /**
   * Geofence findFirst
   */
  export type GeofenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Geofence
     */
    select?: GeofenceSelect<ExtArgs> | null
    /**
     * Filter, which Geofence to fetch.
     */
    where?: GeofenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Geofences to fetch.
     */
    orderBy?: GeofenceOrderByWithRelationInput | GeofenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Geofences.
     */
    cursor?: GeofenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Geofences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Geofences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Geofences.
     */
    distinct?: GeofenceScalarFieldEnum | GeofenceScalarFieldEnum[]
  }

  /**
   * Geofence findFirstOrThrow
   */
  export type GeofenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Geofence
     */
    select?: GeofenceSelect<ExtArgs> | null
    /**
     * Filter, which Geofence to fetch.
     */
    where?: GeofenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Geofences to fetch.
     */
    orderBy?: GeofenceOrderByWithRelationInput | GeofenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Geofences.
     */
    cursor?: GeofenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Geofences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Geofences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Geofences.
     */
    distinct?: GeofenceScalarFieldEnum | GeofenceScalarFieldEnum[]
  }

  /**
   * Geofence findMany
   */
  export type GeofenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Geofence
     */
    select?: GeofenceSelect<ExtArgs> | null
    /**
     * Filter, which Geofences to fetch.
     */
    where?: GeofenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Geofences to fetch.
     */
    orderBy?: GeofenceOrderByWithRelationInput | GeofenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Geofences.
     */
    cursor?: GeofenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Geofences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Geofences.
     */
    skip?: number
    distinct?: GeofenceScalarFieldEnum | GeofenceScalarFieldEnum[]
  }

  /**
   * Geofence create
   */
  export type GeofenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Geofence
     */
    select?: GeofenceSelect<ExtArgs> | null
    /**
     * The data needed to create a Geofence.
     */
    data: XOR<GeofenceCreateInput, GeofenceUncheckedCreateInput>
  }

  /**
   * Geofence createMany
   */
  export type GeofenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Geofences.
     */
    data: GeofenceCreateManyInput | GeofenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Geofence createManyAndReturn
   */
  export type GeofenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Geofence
     */
    select?: GeofenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Geofences.
     */
    data: GeofenceCreateManyInput | GeofenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Geofence update
   */
  export type GeofenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Geofence
     */
    select?: GeofenceSelect<ExtArgs> | null
    /**
     * The data needed to update a Geofence.
     */
    data: XOR<GeofenceUpdateInput, GeofenceUncheckedUpdateInput>
    /**
     * Choose, which Geofence to update.
     */
    where: GeofenceWhereUniqueInput
  }

  /**
   * Geofence updateMany
   */
  export type GeofenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Geofences.
     */
    data: XOR<GeofenceUpdateManyMutationInput, GeofenceUncheckedUpdateManyInput>
    /**
     * Filter which Geofences to update
     */
    where?: GeofenceWhereInput
  }

  /**
   * Geofence upsert
   */
  export type GeofenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Geofence
     */
    select?: GeofenceSelect<ExtArgs> | null
    /**
     * The filter to search for the Geofence to update in case it exists.
     */
    where: GeofenceWhereUniqueInput
    /**
     * In case the Geofence found by the `where` argument doesn't exist, create a new Geofence with this data.
     */
    create: XOR<GeofenceCreateInput, GeofenceUncheckedCreateInput>
    /**
     * In case the Geofence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GeofenceUpdateInput, GeofenceUncheckedUpdateInput>
  }

  /**
   * Geofence delete
   */
  export type GeofenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Geofence
     */
    select?: GeofenceSelect<ExtArgs> | null
    /**
     * Filter which Geofence to delete.
     */
    where: GeofenceWhereUniqueInput
  }

  /**
   * Geofence deleteMany
   */
  export type GeofenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Geofences to delete
     */
    where?: GeofenceWhereInput
  }

  /**
   * Geofence without action
   */
  export type GeofenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Geofence
     */
    select?: GeofenceSelect<ExtArgs> | null
  }


  /**
   * Model GpsPosition
   */

  export type AggregateGpsPosition = {
    _count: GpsPositionCountAggregateOutputType | null
    _avg: GpsPositionAvgAggregateOutputType | null
    _sum: GpsPositionSumAggregateOutputType | null
    _min: GpsPositionMinAggregateOutputType | null
    _max: GpsPositionMaxAggregateOutputType | null
  }

  export type GpsPositionAvgAggregateOutputType = {
    id: number | null
    speedKph: number | null
    headingDeg: number | null
    hdop: number | null
  }

  export type GpsPositionSumAggregateOutputType = {
    id: bigint | null
    speedKph: number | null
    headingDeg: number | null
    hdop: number | null
  }

  export type GpsPositionMinAggregateOutputType = {
    id: bigint | null
    deviceId: string | null
    truckId: string | null
    ts: Date | null
    speedKph: number | null
    headingDeg: number | null
    hdop: number | null
    source: string | null
  }

  export type GpsPositionMaxAggregateOutputType = {
    id: bigint | null
    deviceId: string | null
    truckId: string | null
    ts: Date | null
    speedKph: number | null
    headingDeg: number | null
    hdop: number | null
    source: string | null
  }

  export type GpsPositionCountAggregateOutputType = {
    id: number
    deviceId: number
    truckId: number
    ts: number
    speedKph: number
    headingDeg: number
    hdop: number
    source: number
    _all: number
  }


  export type GpsPositionAvgAggregateInputType = {
    id?: true
    speedKph?: true
    headingDeg?: true
    hdop?: true
  }

  export type GpsPositionSumAggregateInputType = {
    id?: true
    speedKph?: true
    headingDeg?: true
    hdop?: true
  }

  export type GpsPositionMinAggregateInputType = {
    id?: true
    deviceId?: true
    truckId?: true
    ts?: true
    speedKph?: true
    headingDeg?: true
    hdop?: true
    source?: true
  }

  export type GpsPositionMaxAggregateInputType = {
    id?: true
    deviceId?: true
    truckId?: true
    ts?: true
    speedKph?: true
    headingDeg?: true
    hdop?: true
    source?: true
  }

  export type GpsPositionCountAggregateInputType = {
    id?: true
    deviceId?: true
    truckId?: true
    ts?: true
    speedKph?: true
    headingDeg?: true
    hdop?: true
    source?: true
    _all?: true
  }

  export type GpsPositionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GpsPosition to aggregate.
     */
    where?: GpsPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GpsPositions to fetch.
     */
    orderBy?: GpsPositionOrderByWithRelationInput | GpsPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GpsPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GpsPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GpsPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GpsPositions
    **/
    _count?: true | GpsPositionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GpsPositionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GpsPositionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GpsPositionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GpsPositionMaxAggregateInputType
  }

  export type GetGpsPositionAggregateType<T extends GpsPositionAggregateArgs> = {
        [P in keyof T & keyof AggregateGpsPosition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGpsPosition[P]>
      : GetScalarType<T[P], AggregateGpsPosition[P]>
  }




  export type GpsPositionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GpsPositionWhereInput
    orderBy?: GpsPositionOrderByWithAggregationInput | GpsPositionOrderByWithAggregationInput[]
    by: GpsPositionScalarFieldEnum[] | GpsPositionScalarFieldEnum
    having?: GpsPositionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GpsPositionCountAggregateInputType | true
    _avg?: GpsPositionAvgAggregateInputType
    _sum?: GpsPositionSumAggregateInputType
    _min?: GpsPositionMinAggregateInputType
    _max?: GpsPositionMaxAggregateInputType
  }

  export type GpsPositionGroupByOutputType = {
    id: bigint
    deviceId: string | null
    truckId: string
    ts: Date
    speedKph: number | null
    headingDeg: number | null
    hdop: number | null
    source: string | null
    _count: GpsPositionCountAggregateOutputType | null
    _avg: GpsPositionAvgAggregateOutputType | null
    _sum: GpsPositionSumAggregateOutputType | null
    _min: GpsPositionMinAggregateOutputType | null
    _max: GpsPositionMaxAggregateOutputType | null
  }

  type GetGpsPositionGroupByPayload<T extends GpsPositionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GpsPositionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GpsPositionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GpsPositionGroupByOutputType[P]>
            : GetScalarType<T[P], GpsPositionGroupByOutputType[P]>
        }
      >
    >


  export type GpsPositionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    truckId?: boolean
    ts?: boolean
    speedKph?: boolean
    headingDeg?: boolean
    hdop?: boolean
    source?: boolean
    device?: boolean | GpsPosition$deviceArgs<ExtArgs>
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gpsPosition"]>

  export type GpsPositionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    truckId?: boolean
    ts?: boolean
    speedKph?: boolean
    headingDeg?: boolean
    hdop?: boolean
    source?: boolean
    device?: boolean | GpsPosition$deviceArgs<ExtArgs>
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gpsPosition"]>

  export type GpsPositionSelectScalar = {
    id?: boolean
    deviceId?: boolean
    truckId?: boolean
    ts?: boolean
    speedKph?: boolean
    headingDeg?: boolean
    hdop?: boolean
    source?: boolean
  }

  export type GpsPositionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | GpsPosition$deviceArgs<ExtArgs>
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }
  export type GpsPositionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | GpsPosition$deviceArgs<ExtArgs>
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }

  export type $GpsPositionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GpsPosition"
    objects: {
      device: Prisma.$DevicePayload<ExtArgs> | null
      truck: Prisma.$TruckPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      deviceId: string | null
      truckId: string
      ts: Date
      speedKph: number | null
      headingDeg: number | null
      hdop: number | null
      source: string | null
    }, ExtArgs["result"]["gpsPosition"]>
    composites: {}
  }

  type GpsPositionGetPayload<S extends boolean | null | undefined | GpsPositionDefaultArgs> = $Result.GetResult<Prisma.$GpsPositionPayload, S>

  type GpsPositionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GpsPositionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GpsPositionCountAggregateInputType | true
    }

  export interface GpsPositionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GpsPosition'], meta: { name: 'GpsPosition' } }
    /**
     * Find zero or one GpsPosition that matches the filter.
     * @param {GpsPositionFindUniqueArgs} args - Arguments to find a GpsPosition
     * @example
     * // Get one GpsPosition
     * const gpsPosition = await prisma.gpsPosition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GpsPositionFindUniqueArgs>(args: SelectSubset<T, GpsPositionFindUniqueArgs<ExtArgs>>): Prisma__GpsPositionClient<$Result.GetResult<Prisma.$GpsPositionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GpsPosition that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GpsPositionFindUniqueOrThrowArgs} args - Arguments to find a GpsPosition
     * @example
     * // Get one GpsPosition
     * const gpsPosition = await prisma.gpsPosition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GpsPositionFindUniqueOrThrowArgs>(args: SelectSubset<T, GpsPositionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GpsPositionClient<$Result.GetResult<Prisma.$GpsPositionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GpsPosition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GpsPositionFindFirstArgs} args - Arguments to find a GpsPosition
     * @example
     * // Get one GpsPosition
     * const gpsPosition = await prisma.gpsPosition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GpsPositionFindFirstArgs>(args?: SelectSubset<T, GpsPositionFindFirstArgs<ExtArgs>>): Prisma__GpsPositionClient<$Result.GetResult<Prisma.$GpsPositionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GpsPosition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GpsPositionFindFirstOrThrowArgs} args - Arguments to find a GpsPosition
     * @example
     * // Get one GpsPosition
     * const gpsPosition = await prisma.gpsPosition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GpsPositionFindFirstOrThrowArgs>(args?: SelectSubset<T, GpsPositionFindFirstOrThrowArgs<ExtArgs>>): Prisma__GpsPositionClient<$Result.GetResult<Prisma.$GpsPositionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GpsPositions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GpsPositionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GpsPositions
     * const gpsPositions = await prisma.gpsPosition.findMany()
     * 
     * // Get first 10 GpsPositions
     * const gpsPositions = await prisma.gpsPosition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gpsPositionWithIdOnly = await prisma.gpsPosition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GpsPositionFindManyArgs>(args?: SelectSubset<T, GpsPositionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GpsPositionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GpsPosition.
     * @param {GpsPositionCreateArgs} args - Arguments to create a GpsPosition.
     * @example
     * // Create one GpsPosition
     * const GpsPosition = await prisma.gpsPosition.create({
     *   data: {
     *     // ... data to create a GpsPosition
     *   }
     * })
     * 
     */
    create<T extends GpsPositionCreateArgs>(args: SelectSubset<T, GpsPositionCreateArgs<ExtArgs>>): Prisma__GpsPositionClient<$Result.GetResult<Prisma.$GpsPositionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GpsPositions.
     * @param {GpsPositionCreateManyArgs} args - Arguments to create many GpsPositions.
     * @example
     * // Create many GpsPositions
     * const gpsPosition = await prisma.gpsPosition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GpsPositionCreateManyArgs>(args?: SelectSubset<T, GpsPositionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GpsPositions and returns the data saved in the database.
     * @param {GpsPositionCreateManyAndReturnArgs} args - Arguments to create many GpsPositions.
     * @example
     * // Create many GpsPositions
     * const gpsPosition = await prisma.gpsPosition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GpsPositions and only return the `id`
     * const gpsPositionWithIdOnly = await prisma.gpsPosition.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GpsPositionCreateManyAndReturnArgs>(args?: SelectSubset<T, GpsPositionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GpsPositionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GpsPosition.
     * @param {GpsPositionDeleteArgs} args - Arguments to delete one GpsPosition.
     * @example
     * // Delete one GpsPosition
     * const GpsPosition = await prisma.gpsPosition.delete({
     *   where: {
     *     // ... filter to delete one GpsPosition
     *   }
     * })
     * 
     */
    delete<T extends GpsPositionDeleteArgs>(args: SelectSubset<T, GpsPositionDeleteArgs<ExtArgs>>): Prisma__GpsPositionClient<$Result.GetResult<Prisma.$GpsPositionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GpsPosition.
     * @param {GpsPositionUpdateArgs} args - Arguments to update one GpsPosition.
     * @example
     * // Update one GpsPosition
     * const gpsPosition = await prisma.gpsPosition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GpsPositionUpdateArgs>(args: SelectSubset<T, GpsPositionUpdateArgs<ExtArgs>>): Prisma__GpsPositionClient<$Result.GetResult<Prisma.$GpsPositionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GpsPositions.
     * @param {GpsPositionDeleteManyArgs} args - Arguments to filter GpsPositions to delete.
     * @example
     * // Delete a few GpsPositions
     * const { count } = await prisma.gpsPosition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GpsPositionDeleteManyArgs>(args?: SelectSubset<T, GpsPositionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GpsPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GpsPositionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GpsPositions
     * const gpsPosition = await prisma.gpsPosition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GpsPositionUpdateManyArgs>(args: SelectSubset<T, GpsPositionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GpsPosition.
     * @param {GpsPositionUpsertArgs} args - Arguments to update or create a GpsPosition.
     * @example
     * // Update or create a GpsPosition
     * const gpsPosition = await prisma.gpsPosition.upsert({
     *   create: {
     *     // ... data to create a GpsPosition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GpsPosition we want to update
     *   }
     * })
     */
    upsert<T extends GpsPositionUpsertArgs>(args: SelectSubset<T, GpsPositionUpsertArgs<ExtArgs>>): Prisma__GpsPositionClient<$Result.GetResult<Prisma.$GpsPositionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GpsPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GpsPositionCountArgs} args - Arguments to filter GpsPositions to count.
     * @example
     * // Count the number of GpsPositions
     * const count = await prisma.gpsPosition.count({
     *   where: {
     *     // ... the filter for the GpsPositions we want to count
     *   }
     * })
    **/
    count<T extends GpsPositionCountArgs>(
      args?: Subset<T, GpsPositionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GpsPositionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GpsPosition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GpsPositionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GpsPositionAggregateArgs>(args: Subset<T, GpsPositionAggregateArgs>): Prisma.PrismaPromise<GetGpsPositionAggregateType<T>>

    /**
     * Group by GpsPosition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GpsPositionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GpsPositionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GpsPositionGroupByArgs['orderBy'] }
        : { orderBy?: GpsPositionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GpsPositionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGpsPositionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GpsPosition model
   */
  readonly fields: GpsPositionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GpsPosition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GpsPositionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends GpsPosition$deviceArgs<ExtArgs> = {}>(args?: Subset<T, GpsPosition$deviceArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    truck<T extends TruckDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TruckDefaultArgs<ExtArgs>>): Prisma__TruckClient<$Result.GetResult<Prisma.$TruckPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GpsPosition model
   */ 
  interface GpsPositionFieldRefs {
    readonly id: FieldRef<"GpsPosition", 'BigInt'>
    readonly deviceId: FieldRef<"GpsPosition", 'String'>
    readonly truckId: FieldRef<"GpsPosition", 'String'>
    readonly ts: FieldRef<"GpsPosition", 'DateTime'>
    readonly speedKph: FieldRef<"GpsPosition", 'Float'>
    readonly headingDeg: FieldRef<"GpsPosition", 'Float'>
    readonly hdop: FieldRef<"GpsPosition", 'Float'>
    readonly source: FieldRef<"GpsPosition", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GpsPosition findUnique
   */
  export type GpsPositionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GpsPosition
     */
    select?: GpsPositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GpsPositionInclude<ExtArgs> | null
    /**
     * Filter, which GpsPosition to fetch.
     */
    where: GpsPositionWhereUniqueInput
  }

  /**
   * GpsPosition findUniqueOrThrow
   */
  export type GpsPositionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GpsPosition
     */
    select?: GpsPositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GpsPositionInclude<ExtArgs> | null
    /**
     * Filter, which GpsPosition to fetch.
     */
    where: GpsPositionWhereUniqueInput
  }

  /**
   * GpsPosition findFirst
   */
  export type GpsPositionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GpsPosition
     */
    select?: GpsPositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GpsPositionInclude<ExtArgs> | null
    /**
     * Filter, which GpsPosition to fetch.
     */
    where?: GpsPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GpsPositions to fetch.
     */
    orderBy?: GpsPositionOrderByWithRelationInput | GpsPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GpsPositions.
     */
    cursor?: GpsPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GpsPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GpsPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GpsPositions.
     */
    distinct?: GpsPositionScalarFieldEnum | GpsPositionScalarFieldEnum[]
  }

  /**
   * GpsPosition findFirstOrThrow
   */
  export type GpsPositionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GpsPosition
     */
    select?: GpsPositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GpsPositionInclude<ExtArgs> | null
    /**
     * Filter, which GpsPosition to fetch.
     */
    where?: GpsPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GpsPositions to fetch.
     */
    orderBy?: GpsPositionOrderByWithRelationInput | GpsPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GpsPositions.
     */
    cursor?: GpsPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GpsPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GpsPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GpsPositions.
     */
    distinct?: GpsPositionScalarFieldEnum | GpsPositionScalarFieldEnum[]
  }

  /**
   * GpsPosition findMany
   */
  export type GpsPositionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GpsPosition
     */
    select?: GpsPositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GpsPositionInclude<ExtArgs> | null
    /**
     * Filter, which GpsPositions to fetch.
     */
    where?: GpsPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GpsPositions to fetch.
     */
    orderBy?: GpsPositionOrderByWithRelationInput | GpsPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GpsPositions.
     */
    cursor?: GpsPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GpsPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GpsPositions.
     */
    skip?: number
    distinct?: GpsPositionScalarFieldEnum | GpsPositionScalarFieldEnum[]
  }

  /**
   * GpsPosition create
   */
  export type GpsPositionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GpsPosition
     */
    select?: GpsPositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GpsPositionInclude<ExtArgs> | null
    /**
     * The data needed to create a GpsPosition.
     */
    data: XOR<GpsPositionCreateInput, GpsPositionUncheckedCreateInput>
  }

  /**
   * GpsPosition createMany
   */
  export type GpsPositionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GpsPositions.
     */
    data: GpsPositionCreateManyInput | GpsPositionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GpsPosition createManyAndReturn
   */
  export type GpsPositionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GpsPosition
     */
    select?: GpsPositionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GpsPositions.
     */
    data: GpsPositionCreateManyInput | GpsPositionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GpsPositionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GpsPosition update
   */
  export type GpsPositionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GpsPosition
     */
    select?: GpsPositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GpsPositionInclude<ExtArgs> | null
    /**
     * The data needed to update a GpsPosition.
     */
    data: XOR<GpsPositionUpdateInput, GpsPositionUncheckedUpdateInput>
    /**
     * Choose, which GpsPosition to update.
     */
    where: GpsPositionWhereUniqueInput
  }

  /**
   * GpsPosition updateMany
   */
  export type GpsPositionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GpsPositions.
     */
    data: XOR<GpsPositionUpdateManyMutationInput, GpsPositionUncheckedUpdateManyInput>
    /**
     * Filter which GpsPositions to update
     */
    where?: GpsPositionWhereInput
  }

  /**
   * GpsPosition upsert
   */
  export type GpsPositionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GpsPosition
     */
    select?: GpsPositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GpsPositionInclude<ExtArgs> | null
    /**
     * The filter to search for the GpsPosition to update in case it exists.
     */
    where: GpsPositionWhereUniqueInput
    /**
     * In case the GpsPosition found by the `where` argument doesn't exist, create a new GpsPosition with this data.
     */
    create: XOR<GpsPositionCreateInput, GpsPositionUncheckedCreateInput>
    /**
     * In case the GpsPosition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GpsPositionUpdateInput, GpsPositionUncheckedUpdateInput>
  }

  /**
   * GpsPosition delete
   */
  export type GpsPositionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GpsPosition
     */
    select?: GpsPositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GpsPositionInclude<ExtArgs> | null
    /**
     * Filter which GpsPosition to delete.
     */
    where: GpsPositionWhereUniqueInput
  }

  /**
   * GpsPosition deleteMany
   */
  export type GpsPositionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GpsPositions to delete
     */
    where?: GpsPositionWhereInput
  }

  /**
   * GpsPosition.device
   */
  export type GpsPosition$deviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    where?: DeviceWhereInput
  }

  /**
   * GpsPosition without action
   */
  export type GpsPositionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GpsPosition
     */
    select?: GpsPositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GpsPositionInclude<ExtArgs> | null
  }


  /**
   * Model Trip
   */

  export type AggregateTrip = {
    _count: TripCountAggregateOutputType | null
    _min: TripMinAggregateOutputType | null
    _max: TripMaxAggregateOutputType | null
  }

  export type TripMinAggregateOutputType = {
    id: string | null
    truckId: string | null
    startTs: Date | null
    endTs: Date | null
  }

  export type TripMaxAggregateOutputType = {
    id: string | null
    truckId: string | null
    startTs: Date | null
    endTs: Date | null
  }

  export type TripCountAggregateOutputType = {
    id: number
    truckId: number
    startTs: number
    endTs: number
    _all: number
  }


  export type TripMinAggregateInputType = {
    id?: true
    truckId?: true
    startTs?: true
    endTs?: true
  }

  export type TripMaxAggregateInputType = {
    id?: true
    truckId?: true
    startTs?: true
    endTs?: true
  }

  export type TripCountAggregateInputType = {
    id?: true
    truckId?: true
    startTs?: true
    endTs?: true
    _all?: true
  }

  export type TripAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trip to aggregate.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trips
    **/
    _count?: true | TripCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TripMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TripMaxAggregateInputType
  }

  export type GetTripAggregateType<T extends TripAggregateArgs> = {
        [P in keyof T & keyof AggregateTrip]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrip[P]>
      : GetScalarType<T[P], AggregateTrip[P]>
  }




  export type TripGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripWhereInput
    orderBy?: TripOrderByWithAggregationInput | TripOrderByWithAggregationInput[]
    by: TripScalarFieldEnum[] | TripScalarFieldEnum
    having?: TripScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TripCountAggregateInputType | true
    _min?: TripMinAggregateInputType
    _max?: TripMaxAggregateInputType
  }

  export type TripGroupByOutputType = {
    id: string
    truckId: string
    startTs: Date
    endTs: Date | null
    _count: TripCountAggregateOutputType | null
    _min: TripMinAggregateOutputType | null
    _max: TripMaxAggregateOutputType | null
  }

  type GetTripGroupByPayload<T extends TripGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TripGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TripGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TripGroupByOutputType[P]>
            : GetScalarType<T[P], TripGroupByOutputType[P]>
        }
      >
    >


  export type TripSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    truckId?: boolean
    startTs?: boolean
    endTs?: boolean
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trip"]>

  export type TripSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    truckId?: boolean
    startTs?: boolean
    endTs?: boolean
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trip"]>

  export type TripSelectScalar = {
    id?: boolean
    truckId?: boolean
    startTs?: boolean
    endTs?: boolean
  }

  export type TripInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }
  export type TripIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }

  export type $TripPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Trip"
    objects: {
      truck: Prisma.$TruckPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      truckId: string
      startTs: Date
      endTs: Date | null
    }, ExtArgs["result"]["trip"]>
    composites: {}
  }

  type TripGetPayload<S extends boolean | null | undefined | TripDefaultArgs> = $Result.GetResult<Prisma.$TripPayload, S>

  type TripCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TripFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TripCountAggregateInputType | true
    }

  export interface TripDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Trip'], meta: { name: 'Trip' } }
    /**
     * Find zero or one Trip that matches the filter.
     * @param {TripFindUniqueArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TripFindUniqueArgs>(args: SelectSubset<T, TripFindUniqueArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Trip that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TripFindUniqueOrThrowArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TripFindUniqueOrThrowArgs>(args: SelectSubset<T, TripFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Trip that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripFindFirstArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TripFindFirstArgs>(args?: SelectSubset<T, TripFindFirstArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Trip that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripFindFirstOrThrowArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TripFindFirstOrThrowArgs>(args?: SelectSubset<T, TripFindFirstOrThrowArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Trips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trips
     * const trips = await prisma.trip.findMany()
     * 
     * // Get first 10 Trips
     * const trips = await prisma.trip.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tripWithIdOnly = await prisma.trip.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TripFindManyArgs>(args?: SelectSubset<T, TripFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Trip.
     * @param {TripCreateArgs} args - Arguments to create a Trip.
     * @example
     * // Create one Trip
     * const Trip = await prisma.trip.create({
     *   data: {
     *     // ... data to create a Trip
     *   }
     * })
     * 
     */
    create<T extends TripCreateArgs>(args: SelectSubset<T, TripCreateArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Trips.
     * @param {TripCreateManyArgs} args - Arguments to create many Trips.
     * @example
     * // Create many Trips
     * const trip = await prisma.trip.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TripCreateManyArgs>(args?: SelectSubset<T, TripCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Trips and returns the data saved in the database.
     * @param {TripCreateManyAndReturnArgs} args - Arguments to create many Trips.
     * @example
     * // Create many Trips
     * const trip = await prisma.trip.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Trips and only return the `id`
     * const tripWithIdOnly = await prisma.trip.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TripCreateManyAndReturnArgs>(args?: SelectSubset<T, TripCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Trip.
     * @param {TripDeleteArgs} args - Arguments to delete one Trip.
     * @example
     * // Delete one Trip
     * const Trip = await prisma.trip.delete({
     *   where: {
     *     // ... filter to delete one Trip
     *   }
     * })
     * 
     */
    delete<T extends TripDeleteArgs>(args: SelectSubset<T, TripDeleteArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Trip.
     * @param {TripUpdateArgs} args - Arguments to update one Trip.
     * @example
     * // Update one Trip
     * const trip = await prisma.trip.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TripUpdateArgs>(args: SelectSubset<T, TripUpdateArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Trips.
     * @param {TripDeleteManyArgs} args - Arguments to filter Trips to delete.
     * @example
     * // Delete a few Trips
     * const { count } = await prisma.trip.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TripDeleteManyArgs>(args?: SelectSubset<T, TripDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trips
     * const trip = await prisma.trip.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TripUpdateManyArgs>(args: SelectSubset<T, TripUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Trip.
     * @param {TripUpsertArgs} args - Arguments to update or create a Trip.
     * @example
     * // Update or create a Trip
     * const trip = await prisma.trip.upsert({
     *   create: {
     *     // ... data to create a Trip
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trip we want to update
     *   }
     * })
     */
    upsert<T extends TripUpsertArgs>(args: SelectSubset<T, TripUpsertArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Trips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripCountArgs} args - Arguments to filter Trips to count.
     * @example
     * // Count the number of Trips
     * const count = await prisma.trip.count({
     *   where: {
     *     // ... the filter for the Trips we want to count
     *   }
     * })
    **/
    count<T extends TripCountArgs>(
      args?: Subset<T, TripCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TripCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TripAggregateArgs>(args: Subset<T, TripAggregateArgs>): Prisma.PrismaPromise<GetTripAggregateType<T>>

    /**
     * Group by Trip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TripGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TripGroupByArgs['orderBy'] }
        : { orderBy?: TripGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TripGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTripGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Trip model
   */
  readonly fields: TripFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Trip.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TripClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    truck<T extends TruckDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TruckDefaultArgs<ExtArgs>>): Prisma__TruckClient<$Result.GetResult<Prisma.$TruckPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Trip model
   */ 
  interface TripFieldRefs {
    readonly id: FieldRef<"Trip", 'String'>
    readonly truckId: FieldRef<"Trip", 'String'>
    readonly startTs: FieldRef<"Trip", 'DateTime'>
    readonly endTs: FieldRef<"Trip", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Trip findUnique
   */
  export type TripFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip findUniqueOrThrow
   */
  export type TripFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip findFirst
   */
  export type TripFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trips.
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trips.
     */
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Trip findFirstOrThrow
   */
  export type TripFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trips.
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trips.
     */
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Trip findMany
   */
  export type TripFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trips to fetch.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trips.
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Trip create
   */
  export type TripCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * The data needed to create a Trip.
     */
    data: XOR<TripCreateInput, TripUncheckedCreateInput>
  }

  /**
   * Trip createMany
   */
  export type TripCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Trips.
     */
    data: TripCreateManyInput | TripCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Trip createManyAndReturn
   */
  export type TripCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Trips.
     */
    data: TripCreateManyInput | TripCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Trip update
   */
  export type TripUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * The data needed to update a Trip.
     */
    data: XOR<TripUpdateInput, TripUncheckedUpdateInput>
    /**
     * Choose, which Trip to update.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip updateMany
   */
  export type TripUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Trips.
     */
    data: XOR<TripUpdateManyMutationInput, TripUncheckedUpdateManyInput>
    /**
     * Filter which Trips to update
     */
    where?: TripWhereInput
  }

  /**
   * Trip upsert
   */
  export type TripUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * The filter to search for the Trip to update in case it exists.
     */
    where: TripWhereUniqueInput
    /**
     * In case the Trip found by the `where` argument doesn't exist, create a new Trip with this data.
     */
    create: XOR<TripCreateInput, TripUncheckedCreateInput>
    /**
     * In case the Trip was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TripUpdateInput, TripUncheckedUpdateInput>
  }

  /**
   * Trip delete
   */
  export type TripDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter which Trip to delete.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip deleteMany
   */
  export type TripDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trips to delete
     */
    where?: TripWhereInput
  }

  /**
   * Trip without action
   */
  export type TripDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
  }


  /**
   * Model TirePressureEvent
   */

  export type AggregateTirePressureEvent = {
    _count: TirePressureEventCountAggregateOutputType | null
    _avg: TirePressureEventAvgAggregateOutputType | null
    _sum: TirePressureEventSumAggregateOutputType | null
    _min: TirePressureEventMinAggregateOutputType | null
    _max: TirePressureEventMaxAggregateOutputType | null
  }

  export type TirePressureEventAvgAggregateOutputType = {
    tireNo: number | null
    pressureKpa: number | null
    tempCelsius: number | null
    batteryLevel: number | null
  }

  export type TirePressureEventSumAggregateOutputType = {
    tireNo: number | null
    pressureKpa: number | null
    tempCelsius: number | null
    batteryLevel: number | null
  }

  export type TirePressureEventMinAggregateOutputType = {
    id: string | null
    deviceId: string | null
    truckId: string | null
    tireNo: number | null
    pressureKpa: number | null
    tempCelsius: number | null
    exType: string | null
    batteryLevel: number | null
    changedAt: Date | null
    createdBy: string | null
  }

  export type TirePressureEventMaxAggregateOutputType = {
    id: string | null
    deviceId: string | null
    truckId: string | null
    tireNo: number | null
    pressureKpa: number | null
    tempCelsius: number | null
    exType: string | null
    batteryLevel: number | null
    changedAt: Date | null
    createdBy: string | null
  }

  export type TirePressureEventCountAggregateOutputType = {
    id: number
    deviceId: number
    truckId: number
    tireNo: number
    pressureKpa: number
    tempCelsius: number
    exType: number
    batteryLevel: number
    changedAt: number
    createdBy: number
    _all: number
  }


  export type TirePressureEventAvgAggregateInputType = {
    tireNo?: true
    pressureKpa?: true
    tempCelsius?: true
    batteryLevel?: true
  }

  export type TirePressureEventSumAggregateInputType = {
    tireNo?: true
    pressureKpa?: true
    tempCelsius?: true
    batteryLevel?: true
  }

  export type TirePressureEventMinAggregateInputType = {
    id?: true
    deviceId?: true
    truckId?: true
    tireNo?: true
    pressureKpa?: true
    tempCelsius?: true
    exType?: true
    batteryLevel?: true
    changedAt?: true
    createdBy?: true
  }

  export type TirePressureEventMaxAggregateInputType = {
    id?: true
    deviceId?: true
    truckId?: true
    tireNo?: true
    pressureKpa?: true
    tempCelsius?: true
    exType?: true
    batteryLevel?: true
    changedAt?: true
    createdBy?: true
  }

  export type TirePressureEventCountAggregateInputType = {
    id?: true
    deviceId?: true
    truckId?: true
    tireNo?: true
    pressureKpa?: true
    tempCelsius?: true
    exType?: true
    batteryLevel?: true
    changedAt?: true
    createdBy?: true
    _all?: true
  }

  export type TirePressureEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TirePressureEvent to aggregate.
     */
    where?: TirePressureEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TirePressureEvents to fetch.
     */
    orderBy?: TirePressureEventOrderByWithRelationInput | TirePressureEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TirePressureEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TirePressureEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TirePressureEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TirePressureEvents
    **/
    _count?: true | TirePressureEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TirePressureEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TirePressureEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TirePressureEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TirePressureEventMaxAggregateInputType
  }

  export type GetTirePressureEventAggregateType<T extends TirePressureEventAggregateArgs> = {
        [P in keyof T & keyof AggregateTirePressureEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTirePressureEvent[P]>
      : GetScalarType<T[P], AggregateTirePressureEvent[P]>
  }




  export type TirePressureEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TirePressureEventWhereInput
    orderBy?: TirePressureEventOrderByWithAggregationInput | TirePressureEventOrderByWithAggregationInput[]
    by: TirePressureEventScalarFieldEnum[] | TirePressureEventScalarFieldEnum
    having?: TirePressureEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TirePressureEventCountAggregateInputType | true
    _avg?: TirePressureEventAvgAggregateInputType
    _sum?: TirePressureEventSumAggregateInputType
    _min?: TirePressureEventMinAggregateInputType
    _max?: TirePressureEventMaxAggregateInputType
  }

  export type TirePressureEventGroupByOutputType = {
    id: string
    deviceId: string
    truckId: string
    tireNo: number
    pressureKpa: number | null
    tempCelsius: number | null
    exType: string | null
    batteryLevel: number | null
    changedAt: Date
    createdBy: string | null
    _count: TirePressureEventCountAggregateOutputType | null
    _avg: TirePressureEventAvgAggregateOutputType | null
    _sum: TirePressureEventSumAggregateOutputType | null
    _min: TirePressureEventMinAggregateOutputType | null
    _max: TirePressureEventMaxAggregateOutputType | null
  }

  type GetTirePressureEventGroupByPayload<T extends TirePressureEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TirePressureEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TirePressureEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TirePressureEventGroupByOutputType[P]>
            : GetScalarType<T[P], TirePressureEventGroupByOutputType[P]>
        }
      >
    >


  export type TirePressureEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    truckId?: boolean
    tireNo?: boolean
    pressureKpa?: boolean
    tempCelsius?: boolean
    exType?: boolean
    batteryLevel?: boolean
    changedAt?: boolean
    createdBy?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tirePressureEvent"]>

  export type TirePressureEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    truckId?: boolean
    tireNo?: boolean
    pressureKpa?: boolean
    tempCelsius?: boolean
    exType?: boolean
    batteryLevel?: boolean
    changedAt?: boolean
    createdBy?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tirePressureEvent"]>

  export type TirePressureEventSelectScalar = {
    id?: boolean
    deviceId?: boolean
    truckId?: boolean
    tireNo?: boolean
    pressureKpa?: boolean
    tempCelsius?: boolean
    exType?: boolean
    batteryLevel?: boolean
    changedAt?: boolean
    createdBy?: boolean
  }

  export type TirePressureEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }
  export type TirePressureEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }

  export type $TirePressureEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TirePressureEvent"
    objects: {
      device: Prisma.$DevicePayload<ExtArgs>
      truck: Prisma.$TruckPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deviceId: string
      truckId: string
      tireNo: number
      pressureKpa: number | null
      tempCelsius: number | null
      exType: string | null
      batteryLevel: number | null
      changedAt: Date
      createdBy: string | null
    }, ExtArgs["result"]["tirePressureEvent"]>
    composites: {}
  }

  type TirePressureEventGetPayload<S extends boolean | null | undefined | TirePressureEventDefaultArgs> = $Result.GetResult<Prisma.$TirePressureEventPayload, S>

  type TirePressureEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TirePressureEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TirePressureEventCountAggregateInputType | true
    }

  export interface TirePressureEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TirePressureEvent'], meta: { name: 'TirePressureEvent' } }
    /**
     * Find zero or one TirePressureEvent that matches the filter.
     * @param {TirePressureEventFindUniqueArgs} args - Arguments to find a TirePressureEvent
     * @example
     * // Get one TirePressureEvent
     * const tirePressureEvent = await prisma.tirePressureEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TirePressureEventFindUniqueArgs>(args: SelectSubset<T, TirePressureEventFindUniqueArgs<ExtArgs>>): Prisma__TirePressureEventClient<$Result.GetResult<Prisma.$TirePressureEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TirePressureEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TirePressureEventFindUniqueOrThrowArgs} args - Arguments to find a TirePressureEvent
     * @example
     * // Get one TirePressureEvent
     * const tirePressureEvent = await prisma.tirePressureEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TirePressureEventFindUniqueOrThrowArgs>(args: SelectSubset<T, TirePressureEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TirePressureEventClient<$Result.GetResult<Prisma.$TirePressureEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TirePressureEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TirePressureEventFindFirstArgs} args - Arguments to find a TirePressureEvent
     * @example
     * // Get one TirePressureEvent
     * const tirePressureEvent = await prisma.tirePressureEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TirePressureEventFindFirstArgs>(args?: SelectSubset<T, TirePressureEventFindFirstArgs<ExtArgs>>): Prisma__TirePressureEventClient<$Result.GetResult<Prisma.$TirePressureEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TirePressureEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TirePressureEventFindFirstOrThrowArgs} args - Arguments to find a TirePressureEvent
     * @example
     * // Get one TirePressureEvent
     * const tirePressureEvent = await prisma.tirePressureEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TirePressureEventFindFirstOrThrowArgs>(args?: SelectSubset<T, TirePressureEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__TirePressureEventClient<$Result.GetResult<Prisma.$TirePressureEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TirePressureEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TirePressureEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TirePressureEvents
     * const tirePressureEvents = await prisma.tirePressureEvent.findMany()
     * 
     * // Get first 10 TirePressureEvents
     * const tirePressureEvents = await prisma.tirePressureEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tirePressureEventWithIdOnly = await prisma.tirePressureEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TirePressureEventFindManyArgs>(args?: SelectSubset<T, TirePressureEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TirePressureEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TirePressureEvent.
     * @param {TirePressureEventCreateArgs} args - Arguments to create a TirePressureEvent.
     * @example
     * // Create one TirePressureEvent
     * const TirePressureEvent = await prisma.tirePressureEvent.create({
     *   data: {
     *     // ... data to create a TirePressureEvent
     *   }
     * })
     * 
     */
    create<T extends TirePressureEventCreateArgs>(args: SelectSubset<T, TirePressureEventCreateArgs<ExtArgs>>): Prisma__TirePressureEventClient<$Result.GetResult<Prisma.$TirePressureEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TirePressureEvents.
     * @param {TirePressureEventCreateManyArgs} args - Arguments to create many TirePressureEvents.
     * @example
     * // Create many TirePressureEvents
     * const tirePressureEvent = await prisma.tirePressureEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TirePressureEventCreateManyArgs>(args?: SelectSubset<T, TirePressureEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TirePressureEvents and returns the data saved in the database.
     * @param {TirePressureEventCreateManyAndReturnArgs} args - Arguments to create many TirePressureEvents.
     * @example
     * // Create many TirePressureEvents
     * const tirePressureEvent = await prisma.tirePressureEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TirePressureEvents and only return the `id`
     * const tirePressureEventWithIdOnly = await prisma.tirePressureEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TirePressureEventCreateManyAndReturnArgs>(args?: SelectSubset<T, TirePressureEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TirePressureEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TirePressureEvent.
     * @param {TirePressureEventDeleteArgs} args - Arguments to delete one TirePressureEvent.
     * @example
     * // Delete one TirePressureEvent
     * const TirePressureEvent = await prisma.tirePressureEvent.delete({
     *   where: {
     *     // ... filter to delete one TirePressureEvent
     *   }
     * })
     * 
     */
    delete<T extends TirePressureEventDeleteArgs>(args: SelectSubset<T, TirePressureEventDeleteArgs<ExtArgs>>): Prisma__TirePressureEventClient<$Result.GetResult<Prisma.$TirePressureEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TirePressureEvent.
     * @param {TirePressureEventUpdateArgs} args - Arguments to update one TirePressureEvent.
     * @example
     * // Update one TirePressureEvent
     * const tirePressureEvent = await prisma.tirePressureEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TirePressureEventUpdateArgs>(args: SelectSubset<T, TirePressureEventUpdateArgs<ExtArgs>>): Prisma__TirePressureEventClient<$Result.GetResult<Prisma.$TirePressureEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TirePressureEvents.
     * @param {TirePressureEventDeleteManyArgs} args - Arguments to filter TirePressureEvents to delete.
     * @example
     * // Delete a few TirePressureEvents
     * const { count } = await prisma.tirePressureEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TirePressureEventDeleteManyArgs>(args?: SelectSubset<T, TirePressureEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TirePressureEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TirePressureEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TirePressureEvents
     * const tirePressureEvent = await prisma.tirePressureEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TirePressureEventUpdateManyArgs>(args: SelectSubset<T, TirePressureEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TirePressureEvent.
     * @param {TirePressureEventUpsertArgs} args - Arguments to update or create a TirePressureEvent.
     * @example
     * // Update or create a TirePressureEvent
     * const tirePressureEvent = await prisma.tirePressureEvent.upsert({
     *   create: {
     *     // ... data to create a TirePressureEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TirePressureEvent we want to update
     *   }
     * })
     */
    upsert<T extends TirePressureEventUpsertArgs>(args: SelectSubset<T, TirePressureEventUpsertArgs<ExtArgs>>): Prisma__TirePressureEventClient<$Result.GetResult<Prisma.$TirePressureEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TirePressureEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TirePressureEventCountArgs} args - Arguments to filter TirePressureEvents to count.
     * @example
     * // Count the number of TirePressureEvents
     * const count = await prisma.tirePressureEvent.count({
     *   where: {
     *     // ... the filter for the TirePressureEvents we want to count
     *   }
     * })
    **/
    count<T extends TirePressureEventCountArgs>(
      args?: Subset<T, TirePressureEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TirePressureEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TirePressureEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TirePressureEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TirePressureEventAggregateArgs>(args: Subset<T, TirePressureEventAggregateArgs>): Prisma.PrismaPromise<GetTirePressureEventAggregateType<T>>

    /**
     * Group by TirePressureEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TirePressureEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TirePressureEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TirePressureEventGroupByArgs['orderBy'] }
        : { orderBy?: TirePressureEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TirePressureEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTirePressureEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TirePressureEvent model
   */
  readonly fields: TirePressureEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TirePressureEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TirePressureEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends DeviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceDefaultArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    truck<T extends TruckDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TruckDefaultArgs<ExtArgs>>): Prisma__TruckClient<$Result.GetResult<Prisma.$TruckPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TirePressureEvent model
   */ 
  interface TirePressureEventFieldRefs {
    readonly id: FieldRef<"TirePressureEvent", 'String'>
    readonly deviceId: FieldRef<"TirePressureEvent", 'String'>
    readonly truckId: FieldRef<"TirePressureEvent", 'String'>
    readonly tireNo: FieldRef<"TirePressureEvent", 'Int'>
    readonly pressureKpa: FieldRef<"TirePressureEvent", 'Float'>
    readonly tempCelsius: FieldRef<"TirePressureEvent", 'Float'>
    readonly exType: FieldRef<"TirePressureEvent", 'String'>
    readonly batteryLevel: FieldRef<"TirePressureEvent", 'Int'>
    readonly changedAt: FieldRef<"TirePressureEvent", 'DateTime'>
    readonly createdBy: FieldRef<"TirePressureEvent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TirePressureEvent findUnique
   */
  export type TirePressureEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TirePressureEvent
     */
    select?: TirePressureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TirePressureEventInclude<ExtArgs> | null
    /**
     * Filter, which TirePressureEvent to fetch.
     */
    where: TirePressureEventWhereUniqueInput
  }

  /**
   * TirePressureEvent findUniqueOrThrow
   */
  export type TirePressureEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TirePressureEvent
     */
    select?: TirePressureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TirePressureEventInclude<ExtArgs> | null
    /**
     * Filter, which TirePressureEvent to fetch.
     */
    where: TirePressureEventWhereUniqueInput
  }

  /**
   * TirePressureEvent findFirst
   */
  export type TirePressureEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TirePressureEvent
     */
    select?: TirePressureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TirePressureEventInclude<ExtArgs> | null
    /**
     * Filter, which TirePressureEvent to fetch.
     */
    where?: TirePressureEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TirePressureEvents to fetch.
     */
    orderBy?: TirePressureEventOrderByWithRelationInput | TirePressureEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TirePressureEvents.
     */
    cursor?: TirePressureEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TirePressureEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TirePressureEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TirePressureEvents.
     */
    distinct?: TirePressureEventScalarFieldEnum | TirePressureEventScalarFieldEnum[]
  }

  /**
   * TirePressureEvent findFirstOrThrow
   */
  export type TirePressureEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TirePressureEvent
     */
    select?: TirePressureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TirePressureEventInclude<ExtArgs> | null
    /**
     * Filter, which TirePressureEvent to fetch.
     */
    where?: TirePressureEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TirePressureEvents to fetch.
     */
    orderBy?: TirePressureEventOrderByWithRelationInput | TirePressureEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TirePressureEvents.
     */
    cursor?: TirePressureEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TirePressureEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TirePressureEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TirePressureEvents.
     */
    distinct?: TirePressureEventScalarFieldEnum | TirePressureEventScalarFieldEnum[]
  }

  /**
   * TirePressureEvent findMany
   */
  export type TirePressureEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TirePressureEvent
     */
    select?: TirePressureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TirePressureEventInclude<ExtArgs> | null
    /**
     * Filter, which TirePressureEvents to fetch.
     */
    where?: TirePressureEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TirePressureEvents to fetch.
     */
    orderBy?: TirePressureEventOrderByWithRelationInput | TirePressureEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TirePressureEvents.
     */
    cursor?: TirePressureEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TirePressureEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TirePressureEvents.
     */
    skip?: number
    distinct?: TirePressureEventScalarFieldEnum | TirePressureEventScalarFieldEnum[]
  }

  /**
   * TirePressureEvent create
   */
  export type TirePressureEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TirePressureEvent
     */
    select?: TirePressureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TirePressureEventInclude<ExtArgs> | null
    /**
     * The data needed to create a TirePressureEvent.
     */
    data: XOR<TirePressureEventCreateInput, TirePressureEventUncheckedCreateInput>
  }

  /**
   * TirePressureEvent createMany
   */
  export type TirePressureEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TirePressureEvents.
     */
    data: TirePressureEventCreateManyInput | TirePressureEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TirePressureEvent createManyAndReturn
   */
  export type TirePressureEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TirePressureEvent
     */
    select?: TirePressureEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TirePressureEvents.
     */
    data: TirePressureEventCreateManyInput | TirePressureEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TirePressureEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TirePressureEvent update
   */
  export type TirePressureEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TirePressureEvent
     */
    select?: TirePressureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TirePressureEventInclude<ExtArgs> | null
    /**
     * The data needed to update a TirePressureEvent.
     */
    data: XOR<TirePressureEventUpdateInput, TirePressureEventUncheckedUpdateInput>
    /**
     * Choose, which TirePressureEvent to update.
     */
    where: TirePressureEventWhereUniqueInput
  }

  /**
   * TirePressureEvent updateMany
   */
  export type TirePressureEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TirePressureEvents.
     */
    data: XOR<TirePressureEventUpdateManyMutationInput, TirePressureEventUncheckedUpdateManyInput>
    /**
     * Filter which TirePressureEvents to update
     */
    where?: TirePressureEventWhereInput
  }

  /**
   * TirePressureEvent upsert
   */
  export type TirePressureEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TirePressureEvent
     */
    select?: TirePressureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TirePressureEventInclude<ExtArgs> | null
    /**
     * The filter to search for the TirePressureEvent to update in case it exists.
     */
    where: TirePressureEventWhereUniqueInput
    /**
     * In case the TirePressureEvent found by the `where` argument doesn't exist, create a new TirePressureEvent with this data.
     */
    create: XOR<TirePressureEventCreateInput, TirePressureEventUncheckedCreateInput>
    /**
     * In case the TirePressureEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TirePressureEventUpdateInput, TirePressureEventUncheckedUpdateInput>
  }

  /**
   * TirePressureEvent delete
   */
  export type TirePressureEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TirePressureEvent
     */
    select?: TirePressureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TirePressureEventInclude<ExtArgs> | null
    /**
     * Filter which TirePressureEvent to delete.
     */
    where: TirePressureEventWhereUniqueInput
  }

  /**
   * TirePressureEvent deleteMany
   */
  export type TirePressureEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TirePressureEvents to delete
     */
    where?: TirePressureEventWhereInput
  }

  /**
   * TirePressureEvent without action
   */
  export type TirePressureEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TirePressureEvent
     */
    select?: TirePressureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TirePressureEventInclude<ExtArgs> | null
  }


  /**
   * Model TireErrorCode
   */

  export type AggregateTireErrorCode = {
    _count: TireErrorCodeCountAggregateOutputType | null
    _avg: TireErrorCodeAvgAggregateOutputType | null
    _sum: TireErrorCodeSumAggregateOutputType | null
    _min: TireErrorCodeMinAggregateOutputType | null
    _max: TireErrorCodeMaxAggregateOutputType | null
  }

  export type TireErrorCodeAvgAggregateOutputType = {
    code: number | null
  }

  export type TireErrorCodeSumAggregateOutputType = {
    code: number | null
  }

  export type TireErrorCodeMinAggregateOutputType = {
    code: number | null
    description: string | null
  }

  export type TireErrorCodeMaxAggregateOutputType = {
    code: number | null
    description: string | null
  }

  export type TireErrorCodeCountAggregateOutputType = {
    code: number
    description: number
    _all: number
  }


  export type TireErrorCodeAvgAggregateInputType = {
    code?: true
  }

  export type TireErrorCodeSumAggregateInputType = {
    code?: true
  }

  export type TireErrorCodeMinAggregateInputType = {
    code?: true
    description?: true
  }

  export type TireErrorCodeMaxAggregateInputType = {
    code?: true
    description?: true
  }

  export type TireErrorCodeCountAggregateInputType = {
    code?: true
    description?: true
    _all?: true
  }

  export type TireErrorCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TireErrorCode to aggregate.
     */
    where?: TireErrorCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TireErrorCodes to fetch.
     */
    orderBy?: TireErrorCodeOrderByWithRelationInput | TireErrorCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TireErrorCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TireErrorCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TireErrorCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TireErrorCodes
    **/
    _count?: true | TireErrorCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TireErrorCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TireErrorCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TireErrorCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TireErrorCodeMaxAggregateInputType
  }

  export type GetTireErrorCodeAggregateType<T extends TireErrorCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateTireErrorCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTireErrorCode[P]>
      : GetScalarType<T[P], AggregateTireErrorCode[P]>
  }




  export type TireErrorCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TireErrorCodeWhereInput
    orderBy?: TireErrorCodeOrderByWithAggregationInput | TireErrorCodeOrderByWithAggregationInput[]
    by: TireErrorCodeScalarFieldEnum[] | TireErrorCodeScalarFieldEnum
    having?: TireErrorCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TireErrorCodeCountAggregateInputType | true
    _avg?: TireErrorCodeAvgAggregateInputType
    _sum?: TireErrorCodeSumAggregateInputType
    _min?: TireErrorCodeMinAggregateInputType
    _max?: TireErrorCodeMaxAggregateInputType
  }

  export type TireErrorCodeGroupByOutputType = {
    code: number
    description: string | null
    _count: TireErrorCodeCountAggregateOutputType | null
    _avg: TireErrorCodeAvgAggregateOutputType | null
    _sum: TireErrorCodeSumAggregateOutputType | null
    _min: TireErrorCodeMinAggregateOutputType | null
    _max: TireErrorCodeMaxAggregateOutputType | null
  }

  type GetTireErrorCodeGroupByPayload<T extends TireErrorCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TireErrorCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TireErrorCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TireErrorCodeGroupByOutputType[P]>
            : GetScalarType<T[P], TireErrorCodeGroupByOutputType[P]>
        }
      >
    >


  export type TireErrorCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    description?: boolean
  }, ExtArgs["result"]["tireErrorCode"]>

  export type TireErrorCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    description?: boolean
  }, ExtArgs["result"]["tireErrorCode"]>

  export type TireErrorCodeSelectScalar = {
    code?: boolean
    description?: boolean
  }


  export type $TireErrorCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TireErrorCode"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      code: number
      description: string | null
    }, ExtArgs["result"]["tireErrorCode"]>
    composites: {}
  }

  type TireErrorCodeGetPayload<S extends boolean | null | undefined | TireErrorCodeDefaultArgs> = $Result.GetResult<Prisma.$TireErrorCodePayload, S>

  type TireErrorCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TireErrorCodeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TireErrorCodeCountAggregateInputType | true
    }

  export interface TireErrorCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TireErrorCode'], meta: { name: 'TireErrorCode' } }
    /**
     * Find zero or one TireErrorCode that matches the filter.
     * @param {TireErrorCodeFindUniqueArgs} args - Arguments to find a TireErrorCode
     * @example
     * // Get one TireErrorCode
     * const tireErrorCode = await prisma.tireErrorCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TireErrorCodeFindUniqueArgs>(args: SelectSubset<T, TireErrorCodeFindUniqueArgs<ExtArgs>>): Prisma__TireErrorCodeClient<$Result.GetResult<Prisma.$TireErrorCodePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TireErrorCode that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TireErrorCodeFindUniqueOrThrowArgs} args - Arguments to find a TireErrorCode
     * @example
     * // Get one TireErrorCode
     * const tireErrorCode = await prisma.tireErrorCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TireErrorCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, TireErrorCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TireErrorCodeClient<$Result.GetResult<Prisma.$TireErrorCodePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TireErrorCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TireErrorCodeFindFirstArgs} args - Arguments to find a TireErrorCode
     * @example
     * // Get one TireErrorCode
     * const tireErrorCode = await prisma.tireErrorCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TireErrorCodeFindFirstArgs>(args?: SelectSubset<T, TireErrorCodeFindFirstArgs<ExtArgs>>): Prisma__TireErrorCodeClient<$Result.GetResult<Prisma.$TireErrorCodePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TireErrorCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TireErrorCodeFindFirstOrThrowArgs} args - Arguments to find a TireErrorCode
     * @example
     * // Get one TireErrorCode
     * const tireErrorCode = await prisma.tireErrorCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TireErrorCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, TireErrorCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__TireErrorCodeClient<$Result.GetResult<Prisma.$TireErrorCodePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TireErrorCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TireErrorCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TireErrorCodes
     * const tireErrorCodes = await prisma.tireErrorCode.findMany()
     * 
     * // Get first 10 TireErrorCodes
     * const tireErrorCodes = await prisma.tireErrorCode.findMany({ take: 10 })
     * 
     * // Only select the `code`
     * const tireErrorCodeWithCodeOnly = await prisma.tireErrorCode.findMany({ select: { code: true } })
     * 
     */
    findMany<T extends TireErrorCodeFindManyArgs>(args?: SelectSubset<T, TireErrorCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TireErrorCodePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TireErrorCode.
     * @param {TireErrorCodeCreateArgs} args - Arguments to create a TireErrorCode.
     * @example
     * // Create one TireErrorCode
     * const TireErrorCode = await prisma.tireErrorCode.create({
     *   data: {
     *     // ... data to create a TireErrorCode
     *   }
     * })
     * 
     */
    create<T extends TireErrorCodeCreateArgs>(args: SelectSubset<T, TireErrorCodeCreateArgs<ExtArgs>>): Prisma__TireErrorCodeClient<$Result.GetResult<Prisma.$TireErrorCodePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TireErrorCodes.
     * @param {TireErrorCodeCreateManyArgs} args - Arguments to create many TireErrorCodes.
     * @example
     * // Create many TireErrorCodes
     * const tireErrorCode = await prisma.tireErrorCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TireErrorCodeCreateManyArgs>(args?: SelectSubset<T, TireErrorCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TireErrorCodes and returns the data saved in the database.
     * @param {TireErrorCodeCreateManyAndReturnArgs} args - Arguments to create many TireErrorCodes.
     * @example
     * // Create many TireErrorCodes
     * const tireErrorCode = await prisma.tireErrorCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TireErrorCodes and only return the `code`
     * const tireErrorCodeWithCodeOnly = await prisma.tireErrorCode.createManyAndReturn({ 
     *   select: { code: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TireErrorCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, TireErrorCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TireErrorCodePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TireErrorCode.
     * @param {TireErrorCodeDeleteArgs} args - Arguments to delete one TireErrorCode.
     * @example
     * // Delete one TireErrorCode
     * const TireErrorCode = await prisma.tireErrorCode.delete({
     *   where: {
     *     // ... filter to delete one TireErrorCode
     *   }
     * })
     * 
     */
    delete<T extends TireErrorCodeDeleteArgs>(args: SelectSubset<T, TireErrorCodeDeleteArgs<ExtArgs>>): Prisma__TireErrorCodeClient<$Result.GetResult<Prisma.$TireErrorCodePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TireErrorCode.
     * @param {TireErrorCodeUpdateArgs} args - Arguments to update one TireErrorCode.
     * @example
     * // Update one TireErrorCode
     * const tireErrorCode = await prisma.tireErrorCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TireErrorCodeUpdateArgs>(args: SelectSubset<T, TireErrorCodeUpdateArgs<ExtArgs>>): Prisma__TireErrorCodeClient<$Result.GetResult<Prisma.$TireErrorCodePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TireErrorCodes.
     * @param {TireErrorCodeDeleteManyArgs} args - Arguments to filter TireErrorCodes to delete.
     * @example
     * // Delete a few TireErrorCodes
     * const { count } = await prisma.tireErrorCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TireErrorCodeDeleteManyArgs>(args?: SelectSubset<T, TireErrorCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TireErrorCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TireErrorCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TireErrorCodes
     * const tireErrorCode = await prisma.tireErrorCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TireErrorCodeUpdateManyArgs>(args: SelectSubset<T, TireErrorCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TireErrorCode.
     * @param {TireErrorCodeUpsertArgs} args - Arguments to update or create a TireErrorCode.
     * @example
     * // Update or create a TireErrorCode
     * const tireErrorCode = await prisma.tireErrorCode.upsert({
     *   create: {
     *     // ... data to create a TireErrorCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TireErrorCode we want to update
     *   }
     * })
     */
    upsert<T extends TireErrorCodeUpsertArgs>(args: SelectSubset<T, TireErrorCodeUpsertArgs<ExtArgs>>): Prisma__TireErrorCodeClient<$Result.GetResult<Prisma.$TireErrorCodePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TireErrorCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TireErrorCodeCountArgs} args - Arguments to filter TireErrorCodes to count.
     * @example
     * // Count the number of TireErrorCodes
     * const count = await prisma.tireErrorCode.count({
     *   where: {
     *     // ... the filter for the TireErrorCodes we want to count
     *   }
     * })
    **/
    count<T extends TireErrorCodeCountArgs>(
      args?: Subset<T, TireErrorCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TireErrorCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TireErrorCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TireErrorCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TireErrorCodeAggregateArgs>(args: Subset<T, TireErrorCodeAggregateArgs>): Prisma.PrismaPromise<GetTireErrorCodeAggregateType<T>>

    /**
     * Group by TireErrorCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TireErrorCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TireErrorCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TireErrorCodeGroupByArgs['orderBy'] }
        : { orderBy?: TireErrorCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TireErrorCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTireErrorCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TireErrorCode model
   */
  readonly fields: TireErrorCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TireErrorCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TireErrorCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TireErrorCode model
   */ 
  interface TireErrorCodeFieldRefs {
    readonly code: FieldRef<"TireErrorCode", 'Int'>
    readonly description: FieldRef<"TireErrorCode", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TireErrorCode findUnique
   */
  export type TireErrorCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TireErrorCode
     */
    select?: TireErrorCodeSelect<ExtArgs> | null
    /**
     * Filter, which TireErrorCode to fetch.
     */
    where: TireErrorCodeWhereUniqueInput
  }

  /**
   * TireErrorCode findUniqueOrThrow
   */
  export type TireErrorCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TireErrorCode
     */
    select?: TireErrorCodeSelect<ExtArgs> | null
    /**
     * Filter, which TireErrorCode to fetch.
     */
    where: TireErrorCodeWhereUniqueInput
  }

  /**
   * TireErrorCode findFirst
   */
  export type TireErrorCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TireErrorCode
     */
    select?: TireErrorCodeSelect<ExtArgs> | null
    /**
     * Filter, which TireErrorCode to fetch.
     */
    where?: TireErrorCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TireErrorCodes to fetch.
     */
    orderBy?: TireErrorCodeOrderByWithRelationInput | TireErrorCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TireErrorCodes.
     */
    cursor?: TireErrorCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TireErrorCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TireErrorCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TireErrorCodes.
     */
    distinct?: TireErrorCodeScalarFieldEnum | TireErrorCodeScalarFieldEnum[]
  }

  /**
   * TireErrorCode findFirstOrThrow
   */
  export type TireErrorCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TireErrorCode
     */
    select?: TireErrorCodeSelect<ExtArgs> | null
    /**
     * Filter, which TireErrorCode to fetch.
     */
    where?: TireErrorCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TireErrorCodes to fetch.
     */
    orderBy?: TireErrorCodeOrderByWithRelationInput | TireErrorCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TireErrorCodes.
     */
    cursor?: TireErrorCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TireErrorCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TireErrorCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TireErrorCodes.
     */
    distinct?: TireErrorCodeScalarFieldEnum | TireErrorCodeScalarFieldEnum[]
  }

  /**
   * TireErrorCode findMany
   */
  export type TireErrorCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TireErrorCode
     */
    select?: TireErrorCodeSelect<ExtArgs> | null
    /**
     * Filter, which TireErrorCodes to fetch.
     */
    where?: TireErrorCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TireErrorCodes to fetch.
     */
    orderBy?: TireErrorCodeOrderByWithRelationInput | TireErrorCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TireErrorCodes.
     */
    cursor?: TireErrorCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TireErrorCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TireErrorCodes.
     */
    skip?: number
    distinct?: TireErrorCodeScalarFieldEnum | TireErrorCodeScalarFieldEnum[]
  }

  /**
   * TireErrorCode create
   */
  export type TireErrorCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TireErrorCode
     */
    select?: TireErrorCodeSelect<ExtArgs> | null
    /**
     * The data needed to create a TireErrorCode.
     */
    data: XOR<TireErrorCodeCreateInput, TireErrorCodeUncheckedCreateInput>
  }

  /**
   * TireErrorCode createMany
   */
  export type TireErrorCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TireErrorCodes.
     */
    data: TireErrorCodeCreateManyInput | TireErrorCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TireErrorCode createManyAndReturn
   */
  export type TireErrorCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TireErrorCode
     */
    select?: TireErrorCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TireErrorCodes.
     */
    data: TireErrorCodeCreateManyInput | TireErrorCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TireErrorCode update
   */
  export type TireErrorCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TireErrorCode
     */
    select?: TireErrorCodeSelect<ExtArgs> | null
    /**
     * The data needed to update a TireErrorCode.
     */
    data: XOR<TireErrorCodeUpdateInput, TireErrorCodeUncheckedUpdateInput>
    /**
     * Choose, which TireErrorCode to update.
     */
    where: TireErrorCodeWhereUniqueInput
  }

  /**
   * TireErrorCode updateMany
   */
  export type TireErrorCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TireErrorCodes.
     */
    data: XOR<TireErrorCodeUpdateManyMutationInput, TireErrorCodeUncheckedUpdateManyInput>
    /**
     * Filter which TireErrorCodes to update
     */
    where?: TireErrorCodeWhereInput
  }

  /**
   * TireErrorCode upsert
   */
  export type TireErrorCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TireErrorCode
     */
    select?: TireErrorCodeSelect<ExtArgs> | null
    /**
     * The filter to search for the TireErrorCode to update in case it exists.
     */
    where: TireErrorCodeWhereUniqueInput
    /**
     * In case the TireErrorCode found by the `where` argument doesn't exist, create a new TireErrorCode with this data.
     */
    create: XOR<TireErrorCodeCreateInput, TireErrorCodeUncheckedCreateInput>
    /**
     * In case the TireErrorCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TireErrorCodeUpdateInput, TireErrorCodeUncheckedUpdateInput>
  }

  /**
   * TireErrorCode delete
   */
  export type TireErrorCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TireErrorCode
     */
    select?: TireErrorCodeSelect<ExtArgs> | null
    /**
     * Filter which TireErrorCode to delete.
     */
    where: TireErrorCodeWhereUniqueInput
  }

  /**
   * TireErrorCode deleteMany
   */
  export type TireErrorCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TireErrorCodes to delete
     */
    where?: TireErrorCodeWhereInput
  }

  /**
   * TireErrorCode without action
   */
  export type TireErrorCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TireErrorCode
     */
    select?: TireErrorCodeSelect<ExtArgs> | null
  }


  /**
   * Model HubTemperatureEvent
   */

  export type AggregateHubTemperatureEvent = {
    _count: HubTemperatureEventCountAggregateOutputType | null
    _avg: HubTemperatureEventAvgAggregateOutputType | null
    _sum: HubTemperatureEventSumAggregateOutputType | null
    _min: HubTemperatureEventMinAggregateOutputType | null
    _max: HubTemperatureEventMaxAggregateOutputType | null
  }

  export type HubTemperatureEventAvgAggregateOutputType = {
    hubNo: number | null
    tempCelsius: number | null
    batteryLevel: number | null
  }

  export type HubTemperatureEventSumAggregateOutputType = {
    hubNo: number | null
    tempCelsius: number | null
    batteryLevel: number | null
  }

  export type HubTemperatureEventMinAggregateOutputType = {
    id: string | null
    deviceId: string | null
    truckId: string | null
    hubNo: number | null
    tempCelsius: number | null
    exType: string | null
    batteryLevel: number | null
    changedAt: Date | null
    createdBy: string | null
  }

  export type HubTemperatureEventMaxAggregateOutputType = {
    id: string | null
    deviceId: string | null
    truckId: string | null
    hubNo: number | null
    tempCelsius: number | null
    exType: string | null
    batteryLevel: number | null
    changedAt: Date | null
    createdBy: string | null
  }

  export type HubTemperatureEventCountAggregateOutputType = {
    id: number
    deviceId: number
    truckId: number
    hubNo: number
    tempCelsius: number
    exType: number
    batteryLevel: number
    changedAt: number
    createdBy: number
    _all: number
  }


  export type HubTemperatureEventAvgAggregateInputType = {
    hubNo?: true
    tempCelsius?: true
    batteryLevel?: true
  }

  export type HubTemperatureEventSumAggregateInputType = {
    hubNo?: true
    tempCelsius?: true
    batteryLevel?: true
  }

  export type HubTemperatureEventMinAggregateInputType = {
    id?: true
    deviceId?: true
    truckId?: true
    hubNo?: true
    tempCelsius?: true
    exType?: true
    batteryLevel?: true
    changedAt?: true
    createdBy?: true
  }

  export type HubTemperatureEventMaxAggregateInputType = {
    id?: true
    deviceId?: true
    truckId?: true
    hubNo?: true
    tempCelsius?: true
    exType?: true
    batteryLevel?: true
    changedAt?: true
    createdBy?: true
  }

  export type HubTemperatureEventCountAggregateInputType = {
    id?: true
    deviceId?: true
    truckId?: true
    hubNo?: true
    tempCelsius?: true
    exType?: true
    batteryLevel?: true
    changedAt?: true
    createdBy?: true
    _all?: true
  }

  export type HubTemperatureEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HubTemperatureEvent to aggregate.
     */
    where?: HubTemperatureEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HubTemperatureEvents to fetch.
     */
    orderBy?: HubTemperatureEventOrderByWithRelationInput | HubTemperatureEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HubTemperatureEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HubTemperatureEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HubTemperatureEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HubTemperatureEvents
    **/
    _count?: true | HubTemperatureEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HubTemperatureEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HubTemperatureEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HubTemperatureEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HubTemperatureEventMaxAggregateInputType
  }

  export type GetHubTemperatureEventAggregateType<T extends HubTemperatureEventAggregateArgs> = {
        [P in keyof T & keyof AggregateHubTemperatureEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHubTemperatureEvent[P]>
      : GetScalarType<T[P], AggregateHubTemperatureEvent[P]>
  }




  export type HubTemperatureEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HubTemperatureEventWhereInput
    orderBy?: HubTemperatureEventOrderByWithAggregationInput | HubTemperatureEventOrderByWithAggregationInput[]
    by: HubTemperatureEventScalarFieldEnum[] | HubTemperatureEventScalarFieldEnum
    having?: HubTemperatureEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HubTemperatureEventCountAggregateInputType | true
    _avg?: HubTemperatureEventAvgAggregateInputType
    _sum?: HubTemperatureEventSumAggregateInputType
    _min?: HubTemperatureEventMinAggregateInputType
    _max?: HubTemperatureEventMaxAggregateInputType
  }

  export type HubTemperatureEventGroupByOutputType = {
    id: string
    deviceId: string
    truckId: string
    hubNo: number | null
    tempCelsius: number | null
    exType: string | null
    batteryLevel: number | null
    changedAt: Date
    createdBy: string | null
    _count: HubTemperatureEventCountAggregateOutputType | null
    _avg: HubTemperatureEventAvgAggregateOutputType | null
    _sum: HubTemperatureEventSumAggregateOutputType | null
    _min: HubTemperatureEventMinAggregateOutputType | null
    _max: HubTemperatureEventMaxAggregateOutputType | null
  }

  type GetHubTemperatureEventGroupByPayload<T extends HubTemperatureEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HubTemperatureEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HubTemperatureEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HubTemperatureEventGroupByOutputType[P]>
            : GetScalarType<T[P], HubTemperatureEventGroupByOutputType[P]>
        }
      >
    >


  export type HubTemperatureEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    truckId?: boolean
    hubNo?: boolean
    tempCelsius?: boolean
    exType?: boolean
    batteryLevel?: boolean
    changedAt?: boolean
    createdBy?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hubTemperatureEvent"]>

  export type HubTemperatureEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    truckId?: boolean
    hubNo?: boolean
    tempCelsius?: boolean
    exType?: boolean
    batteryLevel?: boolean
    changedAt?: boolean
    createdBy?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hubTemperatureEvent"]>

  export type HubTemperatureEventSelectScalar = {
    id?: boolean
    deviceId?: boolean
    truckId?: boolean
    hubNo?: boolean
    tempCelsius?: boolean
    exType?: boolean
    batteryLevel?: boolean
    changedAt?: boolean
    createdBy?: boolean
  }

  export type HubTemperatureEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }
  export type HubTemperatureEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }

  export type $HubTemperatureEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HubTemperatureEvent"
    objects: {
      device: Prisma.$DevicePayload<ExtArgs>
      truck: Prisma.$TruckPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deviceId: string
      truckId: string
      hubNo: number | null
      tempCelsius: number | null
      exType: string | null
      batteryLevel: number | null
      changedAt: Date
      createdBy: string | null
    }, ExtArgs["result"]["hubTemperatureEvent"]>
    composites: {}
  }

  type HubTemperatureEventGetPayload<S extends boolean | null | undefined | HubTemperatureEventDefaultArgs> = $Result.GetResult<Prisma.$HubTemperatureEventPayload, S>

  type HubTemperatureEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HubTemperatureEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HubTemperatureEventCountAggregateInputType | true
    }

  export interface HubTemperatureEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HubTemperatureEvent'], meta: { name: 'HubTemperatureEvent' } }
    /**
     * Find zero or one HubTemperatureEvent that matches the filter.
     * @param {HubTemperatureEventFindUniqueArgs} args - Arguments to find a HubTemperatureEvent
     * @example
     * // Get one HubTemperatureEvent
     * const hubTemperatureEvent = await prisma.hubTemperatureEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HubTemperatureEventFindUniqueArgs>(args: SelectSubset<T, HubTemperatureEventFindUniqueArgs<ExtArgs>>): Prisma__HubTemperatureEventClient<$Result.GetResult<Prisma.$HubTemperatureEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HubTemperatureEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HubTemperatureEventFindUniqueOrThrowArgs} args - Arguments to find a HubTemperatureEvent
     * @example
     * // Get one HubTemperatureEvent
     * const hubTemperatureEvent = await prisma.hubTemperatureEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HubTemperatureEventFindUniqueOrThrowArgs>(args: SelectSubset<T, HubTemperatureEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HubTemperatureEventClient<$Result.GetResult<Prisma.$HubTemperatureEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HubTemperatureEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HubTemperatureEventFindFirstArgs} args - Arguments to find a HubTemperatureEvent
     * @example
     * // Get one HubTemperatureEvent
     * const hubTemperatureEvent = await prisma.hubTemperatureEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HubTemperatureEventFindFirstArgs>(args?: SelectSubset<T, HubTemperatureEventFindFirstArgs<ExtArgs>>): Prisma__HubTemperatureEventClient<$Result.GetResult<Prisma.$HubTemperatureEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HubTemperatureEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HubTemperatureEventFindFirstOrThrowArgs} args - Arguments to find a HubTemperatureEvent
     * @example
     * // Get one HubTemperatureEvent
     * const hubTemperatureEvent = await prisma.hubTemperatureEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HubTemperatureEventFindFirstOrThrowArgs>(args?: SelectSubset<T, HubTemperatureEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__HubTemperatureEventClient<$Result.GetResult<Prisma.$HubTemperatureEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HubTemperatureEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HubTemperatureEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HubTemperatureEvents
     * const hubTemperatureEvents = await prisma.hubTemperatureEvent.findMany()
     * 
     * // Get first 10 HubTemperatureEvents
     * const hubTemperatureEvents = await prisma.hubTemperatureEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hubTemperatureEventWithIdOnly = await prisma.hubTemperatureEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HubTemperatureEventFindManyArgs>(args?: SelectSubset<T, HubTemperatureEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HubTemperatureEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HubTemperatureEvent.
     * @param {HubTemperatureEventCreateArgs} args - Arguments to create a HubTemperatureEvent.
     * @example
     * // Create one HubTemperatureEvent
     * const HubTemperatureEvent = await prisma.hubTemperatureEvent.create({
     *   data: {
     *     // ... data to create a HubTemperatureEvent
     *   }
     * })
     * 
     */
    create<T extends HubTemperatureEventCreateArgs>(args: SelectSubset<T, HubTemperatureEventCreateArgs<ExtArgs>>): Prisma__HubTemperatureEventClient<$Result.GetResult<Prisma.$HubTemperatureEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HubTemperatureEvents.
     * @param {HubTemperatureEventCreateManyArgs} args - Arguments to create many HubTemperatureEvents.
     * @example
     * // Create many HubTemperatureEvents
     * const hubTemperatureEvent = await prisma.hubTemperatureEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HubTemperatureEventCreateManyArgs>(args?: SelectSubset<T, HubTemperatureEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HubTemperatureEvents and returns the data saved in the database.
     * @param {HubTemperatureEventCreateManyAndReturnArgs} args - Arguments to create many HubTemperatureEvents.
     * @example
     * // Create many HubTemperatureEvents
     * const hubTemperatureEvent = await prisma.hubTemperatureEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HubTemperatureEvents and only return the `id`
     * const hubTemperatureEventWithIdOnly = await prisma.hubTemperatureEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HubTemperatureEventCreateManyAndReturnArgs>(args?: SelectSubset<T, HubTemperatureEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HubTemperatureEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HubTemperatureEvent.
     * @param {HubTemperatureEventDeleteArgs} args - Arguments to delete one HubTemperatureEvent.
     * @example
     * // Delete one HubTemperatureEvent
     * const HubTemperatureEvent = await prisma.hubTemperatureEvent.delete({
     *   where: {
     *     // ... filter to delete one HubTemperatureEvent
     *   }
     * })
     * 
     */
    delete<T extends HubTemperatureEventDeleteArgs>(args: SelectSubset<T, HubTemperatureEventDeleteArgs<ExtArgs>>): Prisma__HubTemperatureEventClient<$Result.GetResult<Prisma.$HubTemperatureEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HubTemperatureEvent.
     * @param {HubTemperatureEventUpdateArgs} args - Arguments to update one HubTemperatureEvent.
     * @example
     * // Update one HubTemperatureEvent
     * const hubTemperatureEvent = await prisma.hubTemperatureEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HubTemperatureEventUpdateArgs>(args: SelectSubset<T, HubTemperatureEventUpdateArgs<ExtArgs>>): Prisma__HubTemperatureEventClient<$Result.GetResult<Prisma.$HubTemperatureEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HubTemperatureEvents.
     * @param {HubTemperatureEventDeleteManyArgs} args - Arguments to filter HubTemperatureEvents to delete.
     * @example
     * // Delete a few HubTemperatureEvents
     * const { count } = await prisma.hubTemperatureEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HubTemperatureEventDeleteManyArgs>(args?: SelectSubset<T, HubTemperatureEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HubTemperatureEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HubTemperatureEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HubTemperatureEvents
     * const hubTemperatureEvent = await prisma.hubTemperatureEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HubTemperatureEventUpdateManyArgs>(args: SelectSubset<T, HubTemperatureEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HubTemperatureEvent.
     * @param {HubTemperatureEventUpsertArgs} args - Arguments to update or create a HubTemperatureEvent.
     * @example
     * // Update or create a HubTemperatureEvent
     * const hubTemperatureEvent = await prisma.hubTemperatureEvent.upsert({
     *   create: {
     *     // ... data to create a HubTemperatureEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HubTemperatureEvent we want to update
     *   }
     * })
     */
    upsert<T extends HubTemperatureEventUpsertArgs>(args: SelectSubset<T, HubTemperatureEventUpsertArgs<ExtArgs>>): Prisma__HubTemperatureEventClient<$Result.GetResult<Prisma.$HubTemperatureEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HubTemperatureEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HubTemperatureEventCountArgs} args - Arguments to filter HubTemperatureEvents to count.
     * @example
     * // Count the number of HubTemperatureEvents
     * const count = await prisma.hubTemperatureEvent.count({
     *   where: {
     *     // ... the filter for the HubTemperatureEvents we want to count
     *   }
     * })
    **/
    count<T extends HubTemperatureEventCountArgs>(
      args?: Subset<T, HubTemperatureEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HubTemperatureEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HubTemperatureEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HubTemperatureEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HubTemperatureEventAggregateArgs>(args: Subset<T, HubTemperatureEventAggregateArgs>): Prisma.PrismaPromise<GetHubTemperatureEventAggregateType<T>>

    /**
     * Group by HubTemperatureEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HubTemperatureEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HubTemperatureEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HubTemperatureEventGroupByArgs['orderBy'] }
        : { orderBy?: HubTemperatureEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HubTemperatureEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHubTemperatureEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HubTemperatureEvent model
   */
  readonly fields: HubTemperatureEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HubTemperatureEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HubTemperatureEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends DeviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceDefaultArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    truck<T extends TruckDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TruckDefaultArgs<ExtArgs>>): Prisma__TruckClient<$Result.GetResult<Prisma.$TruckPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HubTemperatureEvent model
   */ 
  interface HubTemperatureEventFieldRefs {
    readonly id: FieldRef<"HubTemperatureEvent", 'String'>
    readonly deviceId: FieldRef<"HubTemperatureEvent", 'String'>
    readonly truckId: FieldRef<"HubTemperatureEvent", 'String'>
    readonly hubNo: FieldRef<"HubTemperatureEvent", 'Int'>
    readonly tempCelsius: FieldRef<"HubTemperatureEvent", 'Float'>
    readonly exType: FieldRef<"HubTemperatureEvent", 'String'>
    readonly batteryLevel: FieldRef<"HubTemperatureEvent", 'Int'>
    readonly changedAt: FieldRef<"HubTemperatureEvent", 'DateTime'>
    readonly createdBy: FieldRef<"HubTemperatureEvent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * HubTemperatureEvent findUnique
   */
  export type HubTemperatureEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HubTemperatureEvent
     */
    select?: HubTemperatureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HubTemperatureEventInclude<ExtArgs> | null
    /**
     * Filter, which HubTemperatureEvent to fetch.
     */
    where: HubTemperatureEventWhereUniqueInput
  }

  /**
   * HubTemperatureEvent findUniqueOrThrow
   */
  export type HubTemperatureEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HubTemperatureEvent
     */
    select?: HubTemperatureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HubTemperatureEventInclude<ExtArgs> | null
    /**
     * Filter, which HubTemperatureEvent to fetch.
     */
    where: HubTemperatureEventWhereUniqueInput
  }

  /**
   * HubTemperatureEvent findFirst
   */
  export type HubTemperatureEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HubTemperatureEvent
     */
    select?: HubTemperatureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HubTemperatureEventInclude<ExtArgs> | null
    /**
     * Filter, which HubTemperatureEvent to fetch.
     */
    where?: HubTemperatureEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HubTemperatureEvents to fetch.
     */
    orderBy?: HubTemperatureEventOrderByWithRelationInput | HubTemperatureEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HubTemperatureEvents.
     */
    cursor?: HubTemperatureEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HubTemperatureEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HubTemperatureEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HubTemperatureEvents.
     */
    distinct?: HubTemperatureEventScalarFieldEnum | HubTemperatureEventScalarFieldEnum[]
  }

  /**
   * HubTemperatureEvent findFirstOrThrow
   */
  export type HubTemperatureEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HubTemperatureEvent
     */
    select?: HubTemperatureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HubTemperatureEventInclude<ExtArgs> | null
    /**
     * Filter, which HubTemperatureEvent to fetch.
     */
    where?: HubTemperatureEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HubTemperatureEvents to fetch.
     */
    orderBy?: HubTemperatureEventOrderByWithRelationInput | HubTemperatureEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HubTemperatureEvents.
     */
    cursor?: HubTemperatureEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HubTemperatureEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HubTemperatureEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HubTemperatureEvents.
     */
    distinct?: HubTemperatureEventScalarFieldEnum | HubTemperatureEventScalarFieldEnum[]
  }

  /**
   * HubTemperatureEvent findMany
   */
  export type HubTemperatureEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HubTemperatureEvent
     */
    select?: HubTemperatureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HubTemperatureEventInclude<ExtArgs> | null
    /**
     * Filter, which HubTemperatureEvents to fetch.
     */
    where?: HubTemperatureEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HubTemperatureEvents to fetch.
     */
    orderBy?: HubTemperatureEventOrderByWithRelationInput | HubTemperatureEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HubTemperatureEvents.
     */
    cursor?: HubTemperatureEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HubTemperatureEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HubTemperatureEvents.
     */
    skip?: number
    distinct?: HubTemperatureEventScalarFieldEnum | HubTemperatureEventScalarFieldEnum[]
  }

  /**
   * HubTemperatureEvent create
   */
  export type HubTemperatureEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HubTemperatureEvent
     */
    select?: HubTemperatureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HubTemperatureEventInclude<ExtArgs> | null
    /**
     * The data needed to create a HubTemperatureEvent.
     */
    data: XOR<HubTemperatureEventCreateInput, HubTemperatureEventUncheckedCreateInput>
  }

  /**
   * HubTemperatureEvent createMany
   */
  export type HubTemperatureEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HubTemperatureEvents.
     */
    data: HubTemperatureEventCreateManyInput | HubTemperatureEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HubTemperatureEvent createManyAndReturn
   */
  export type HubTemperatureEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HubTemperatureEvent
     */
    select?: HubTemperatureEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HubTemperatureEvents.
     */
    data: HubTemperatureEventCreateManyInput | HubTemperatureEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HubTemperatureEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HubTemperatureEvent update
   */
  export type HubTemperatureEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HubTemperatureEvent
     */
    select?: HubTemperatureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HubTemperatureEventInclude<ExtArgs> | null
    /**
     * The data needed to update a HubTemperatureEvent.
     */
    data: XOR<HubTemperatureEventUpdateInput, HubTemperatureEventUncheckedUpdateInput>
    /**
     * Choose, which HubTemperatureEvent to update.
     */
    where: HubTemperatureEventWhereUniqueInput
  }

  /**
   * HubTemperatureEvent updateMany
   */
  export type HubTemperatureEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HubTemperatureEvents.
     */
    data: XOR<HubTemperatureEventUpdateManyMutationInput, HubTemperatureEventUncheckedUpdateManyInput>
    /**
     * Filter which HubTemperatureEvents to update
     */
    where?: HubTemperatureEventWhereInput
  }

  /**
   * HubTemperatureEvent upsert
   */
  export type HubTemperatureEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HubTemperatureEvent
     */
    select?: HubTemperatureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HubTemperatureEventInclude<ExtArgs> | null
    /**
     * The filter to search for the HubTemperatureEvent to update in case it exists.
     */
    where: HubTemperatureEventWhereUniqueInput
    /**
     * In case the HubTemperatureEvent found by the `where` argument doesn't exist, create a new HubTemperatureEvent with this data.
     */
    create: XOR<HubTemperatureEventCreateInput, HubTemperatureEventUncheckedCreateInput>
    /**
     * In case the HubTemperatureEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HubTemperatureEventUpdateInput, HubTemperatureEventUncheckedUpdateInput>
  }

  /**
   * HubTemperatureEvent delete
   */
  export type HubTemperatureEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HubTemperatureEvent
     */
    select?: HubTemperatureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HubTemperatureEventInclude<ExtArgs> | null
    /**
     * Filter which HubTemperatureEvent to delete.
     */
    where: HubTemperatureEventWhereUniqueInput
  }

  /**
   * HubTemperatureEvent deleteMany
   */
  export type HubTemperatureEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HubTemperatureEvents to delete
     */
    where?: HubTemperatureEventWhereInput
  }

  /**
   * HubTemperatureEvent without action
   */
  export type HubTemperatureEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HubTemperatureEvent
     */
    select?: HubTemperatureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HubTemperatureEventInclude<ExtArgs> | null
  }


  /**
   * Model FuelLevelEvent
   */

  export type AggregateFuelLevelEvent = {
    _count: FuelLevelEventCountAggregateOutputType | null
    _avg: FuelLevelEventAvgAggregateOutputType | null
    _sum: FuelLevelEventSumAggregateOutputType | null
    _min: FuelLevelEventMinAggregateOutputType | null
    _max: FuelLevelEventMaxAggregateOutputType | null
  }

  export type FuelLevelEventAvgAggregateOutputType = {
    fuelPercent: number | null
  }

  export type FuelLevelEventSumAggregateOutputType = {
    fuelPercent: number | null
  }

  export type FuelLevelEventMinAggregateOutputType = {
    id: string | null
    truckId: string | null
    fuelPercent: number | null
    changedAt: Date | null
    source: string | null
    createdBy: string | null
  }

  export type FuelLevelEventMaxAggregateOutputType = {
    id: string | null
    truckId: string | null
    fuelPercent: number | null
    changedAt: Date | null
    source: string | null
    createdBy: string | null
  }

  export type FuelLevelEventCountAggregateOutputType = {
    id: number
    truckId: number
    fuelPercent: number
    changedAt: number
    source: number
    createdBy: number
    _all: number
  }


  export type FuelLevelEventAvgAggregateInputType = {
    fuelPercent?: true
  }

  export type FuelLevelEventSumAggregateInputType = {
    fuelPercent?: true
  }

  export type FuelLevelEventMinAggregateInputType = {
    id?: true
    truckId?: true
    fuelPercent?: true
    changedAt?: true
    source?: true
    createdBy?: true
  }

  export type FuelLevelEventMaxAggregateInputType = {
    id?: true
    truckId?: true
    fuelPercent?: true
    changedAt?: true
    source?: true
    createdBy?: true
  }

  export type FuelLevelEventCountAggregateInputType = {
    id?: true
    truckId?: true
    fuelPercent?: true
    changedAt?: true
    source?: true
    createdBy?: true
    _all?: true
  }

  export type FuelLevelEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FuelLevelEvent to aggregate.
     */
    where?: FuelLevelEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FuelLevelEvents to fetch.
     */
    orderBy?: FuelLevelEventOrderByWithRelationInput | FuelLevelEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FuelLevelEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FuelLevelEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FuelLevelEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FuelLevelEvents
    **/
    _count?: true | FuelLevelEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FuelLevelEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FuelLevelEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FuelLevelEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FuelLevelEventMaxAggregateInputType
  }

  export type GetFuelLevelEventAggregateType<T extends FuelLevelEventAggregateArgs> = {
        [P in keyof T & keyof AggregateFuelLevelEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFuelLevelEvent[P]>
      : GetScalarType<T[P], AggregateFuelLevelEvent[P]>
  }




  export type FuelLevelEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FuelLevelEventWhereInput
    orderBy?: FuelLevelEventOrderByWithAggregationInput | FuelLevelEventOrderByWithAggregationInput[]
    by: FuelLevelEventScalarFieldEnum[] | FuelLevelEventScalarFieldEnum
    having?: FuelLevelEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FuelLevelEventCountAggregateInputType | true
    _avg?: FuelLevelEventAvgAggregateInputType
    _sum?: FuelLevelEventSumAggregateInputType
    _min?: FuelLevelEventMinAggregateInputType
    _max?: FuelLevelEventMaxAggregateInputType
  }

  export type FuelLevelEventGroupByOutputType = {
    id: string
    truckId: string
    fuelPercent: number | null
    changedAt: Date
    source: string | null
    createdBy: string | null
    _count: FuelLevelEventCountAggregateOutputType | null
    _avg: FuelLevelEventAvgAggregateOutputType | null
    _sum: FuelLevelEventSumAggregateOutputType | null
    _min: FuelLevelEventMinAggregateOutputType | null
    _max: FuelLevelEventMaxAggregateOutputType | null
  }

  type GetFuelLevelEventGroupByPayload<T extends FuelLevelEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FuelLevelEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FuelLevelEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FuelLevelEventGroupByOutputType[P]>
            : GetScalarType<T[P], FuelLevelEventGroupByOutputType[P]>
        }
      >
    >


  export type FuelLevelEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    truckId?: boolean
    fuelPercent?: boolean
    changedAt?: boolean
    source?: boolean
    createdBy?: boolean
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fuelLevelEvent"]>

  export type FuelLevelEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    truckId?: boolean
    fuelPercent?: boolean
    changedAt?: boolean
    source?: boolean
    createdBy?: boolean
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fuelLevelEvent"]>

  export type FuelLevelEventSelectScalar = {
    id?: boolean
    truckId?: boolean
    fuelPercent?: boolean
    changedAt?: boolean
    source?: boolean
    createdBy?: boolean
  }

  export type FuelLevelEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }
  export type FuelLevelEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }

  export type $FuelLevelEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FuelLevelEvent"
    objects: {
      truck: Prisma.$TruckPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      truckId: string
      fuelPercent: number | null
      changedAt: Date
      source: string | null
      createdBy: string | null
    }, ExtArgs["result"]["fuelLevelEvent"]>
    composites: {}
  }

  type FuelLevelEventGetPayload<S extends boolean | null | undefined | FuelLevelEventDefaultArgs> = $Result.GetResult<Prisma.$FuelLevelEventPayload, S>

  type FuelLevelEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FuelLevelEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FuelLevelEventCountAggregateInputType | true
    }

  export interface FuelLevelEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FuelLevelEvent'], meta: { name: 'FuelLevelEvent' } }
    /**
     * Find zero or one FuelLevelEvent that matches the filter.
     * @param {FuelLevelEventFindUniqueArgs} args - Arguments to find a FuelLevelEvent
     * @example
     * // Get one FuelLevelEvent
     * const fuelLevelEvent = await prisma.fuelLevelEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FuelLevelEventFindUniqueArgs>(args: SelectSubset<T, FuelLevelEventFindUniqueArgs<ExtArgs>>): Prisma__FuelLevelEventClient<$Result.GetResult<Prisma.$FuelLevelEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FuelLevelEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FuelLevelEventFindUniqueOrThrowArgs} args - Arguments to find a FuelLevelEvent
     * @example
     * // Get one FuelLevelEvent
     * const fuelLevelEvent = await prisma.fuelLevelEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FuelLevelEventFindUniqueOrThrowArgs>(args: SelectSubset<T, FuelLevelEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FuelLevelEventClient<$Result.GetResult<Prisma.$FuelLevelEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FuelLevelEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FuelLevelEventFindFirstArgs} args - Arguments to find a FuelLevelEvent
     * @example
     * // Get one FuelLevelEvent
     * const fuelLevelEvent = await prisma.fuelLevelEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FuelLevelEventFindFirstArgs>(args?: SelectSubset<T, FuelLevelEventFindFirstArgs<ExtArgs>>): Prisma__FuelLevelEventClient<$Result.GetResult<Prisma.$FuelLevelEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FuelLevelEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FuelLevelEventFindFirstOrThrowArgs} args - Arguments to find a FuelLevelEvent
     * @example
     * // Get one FuelLevelEvent
     * const fuelLevelEvent = await prisma.fuelLevelEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FuelLevelEventFindFirstOrThrowArgs>(args?: SelectSubset<T, FuelLevelEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__FuelLevelEventClient<$Result.GetResult<Prisma.$FuelLevelEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FuelLevelEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FuelLevelEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FuelLevelEvents
     * const fuelLevelEvents = await prisma.fuelLevelEvent.findMany()
     * 
     * // Get first 10 FuelLevelEvents
     * const fuelLevelEvents = await prisma.fuelLevelEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fuelLevelEventWithIdOnly = await prisma.fuelLevelEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FuelLevelEventFindManyArgs>(args?: SelectSubset<T, FuelLevelEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FuelLevelEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FuelLevelEvent.
     * @param {FuelLevelEventCreateArgs} args - Arguments to create a FuelLevelEvent.
     * @example
     * // Create one FuelLevelEvent
     * const FuelLevelEvent = await prisma.fuelLevelEvent.create({
     *   data: {
     *     // ... data to create a FuelLevelEvent
     *   }
     * })
     * 
     */
    create<T extends FuelLevelEventCreateArgs>(args: SelectSubset<T, FuelLevelEventCreateArgs<ExtArgs>>): Prisma__FuelLevelEventClient<$Result.GetResult<Prisma.$FuelLevelEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FuelLevelEvents.
     * @param {FuelLevelEventCreateManyArgs} args - Arguments to create many FuelLevelEvents.
     * @example
     * // Create many FuelLevelEvents
     * const fuelLevelEvent = await prisma.fuelLevelEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FuelLevelEventCreateManyArgs>(args?: SelectSubset<T, FuelLevelEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FuelLevelEvents and returns the data saved in the database.
     * @param {FuelLevelEventCreateManyAndReturnArgs} args - Arguments to create many FuelLevelEvents.
     * @example
     * // Create many FuelLevelEvents
     * const fuelLevelEvent = await prisma.fuelLevelEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FuelLevelEvents and only return the `id`
     * const fuelLevelEventWithIdOnly = await prisma.fuelLevelEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FuelLevelEventCreateManyAndReturnArgs>(args?: SelectSubset<T, FuelLevelEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FuelLevelEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FuelLevelEvent.
     * @param {FuelLevelEventDeleteArgs} args - Arguments to delete one FuelLevelEvent.
     * @example
     * // Delete one FuelLevelEvent
     * const FuelLevelEvent = await prisma.fuelLevelEvent.delete({
     *   where: {
     *     // ... filter to delete one FuelLevelEvent
     *   }
     * })
     * 
     */
    delete<T extends FuelLevelEventDeleteArgs>(args: SelectSubset<T, FuelLevelEventDeleteArgs<ExtArgs>>): Prisma__FuelLevelEventClient<$Result.GetResult<Prisma.$FuelLevelEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FuelLevelEvent.
     * @param {FuelLevelEventUpdateArgs} args - Arguments to update one FuelLevelEvent.
     * @example
     * // Update one FuelLevelEvent
     * const fuelLevelEvent = await prisma.fuelLevelEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FuelLevelEventUpdateArgs>(args: SelectSubset<T, FuelLevelEventUpdateArgs<ExtArgs>>): Prisma__FuelLevelEventClient<$Result.GetResult<Prisma.$FuelLevelEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FuelLevelEvents.
     * @param {FuelLevelEventDeleteManyArgs} args - Arguments to filter FuelLevelEvents to delete.
     * @example
     * // Delete a few FuelLevelEvents
     * const { count } = await prisma.fuelLevelEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FuelLevelEventDeleteManyArgs>(args?: SelectSubset<T, FuelLevelEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FuelLevelEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FuelLevelEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FuelLevelEvents
     * const fuelLevelEvent = await prisma.fuelLevelEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FuelLevelEventUpdateManyArgs>(args: SelectSubset<T, FuelLevelEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FuelLevelEvent.
     * @param {FuelLevelEventUpsertArgs} args - Arguments to update or create a FuelLevelEvent.
     * @example
     * // Update or create a FuelLevelEvent
     * const fuelLevelEvent = await prisma.fuelLevelEvent.upsert({
     *   create: {
     *     // ... data to create a FuelLevelEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FuelLevelEvent we want to update
     *   }
     * })
     */
    upsert<T extends FuelLevelEventUpsertArgs>(args: SelectSubset<T, FuelLevelEventUpsertArgs<ExtArgs>>): Prisma__FuelLevelEventClient<$Result.GetResult<Prisma.$FuelLevelEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FuelLevelEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FuelLevelEventCountArgs} args - Arguments to filter FuelLevelEvents to count.
     * @example
     * // Count the number of FuelLevelEvents
     * const count = await prisma.fuelLevelEvent.count({
     *   where: {
     *     // ... the filter for the FuelLevelEvents we want to count
     *   }
     * })
    **/
    count<T extends FuelLevelEventCountArgs>(
      args?: Subset<T, FuelLevelEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FuelLevelEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FuelLevelEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FuelLevelEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FuelLevelEventAggregateArgs>(args: Subset<T, FuelLevelEventAggregateArgs>): Prisma.PrismaPromise<GetFuelLevelEventAggregateType<T>>

    /**
     * Group by FuelLevelEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FuelLevelEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FuelLevelEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FuelLevelEventGroupByArgs['orderBy'] }
        : { orderBy?: FuelLevelEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FuelLevelEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFuelLevelEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FuelLevelEvent model
   */
  readonly fields: FuelLevelEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FuelLevelEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FuelLevelEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    truck<T extends TruckDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TruckDefaultArgs<ExtArgs>>): Prisma__TruckClient<$Result.GetResult<Prisma.$TruckPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FuelLevelEvent model
   */ 
  interface FuelLevelEventFieldRefs {
    readonly id: FieldRef<"FuelLevelEvent", 'String'>
    readonly truckId: FieldRef<"FuelLevelEvent", 'String'>
    readonly fuelPercent: FieldRef<"FuelLevelEvent", 'Float'>
    readonly changedAt: FieldRef<"FuelLevelEvent", 'DateTime'>
    readonly source: FieldRef<"FuelLevelEvent", 'String'>
    readonly createdBy: FieldRef<"FuelLevelEvent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FuelLevelEvent findUnique
   */
  export type FuelLevelEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FuelLevelEvent
     */
    select?: FuelLevelEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FuelLevelEventInclude<ExtArgs> | null
    /**
     * Filter, which FuelLevelEvent to fetch.
     */
    where: FuelLevelEventWhereUniqueInput
  }

  /**
   * FuelLevelEvent findUniqueOrThrow
   */
  export type FuelLevelEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FuelLevelEvent
     */
    select?: FuelLevelEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FuelLevelEventInclude<ExtArgs> | null
    /**
     * Filter, which FuelLevelEvent to fetch.
     */
    where: FuelLevelEventWhereUniqueInput
  }

  /**
   * FuelLevelEvent findFirst
   */
  export type FuelLevelEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FuelLevelEvent
     */
    select?: FuelLevelEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FuelLevelEventInclude<ExtArgs> | null
    /**
     * Filter, which FuelLevelEvent to fetch.
     */
    where?: FuelLevelEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FuelLevelEvents to fetch.
     */
    orderBy?: FuelLevelEventOrderByWithRelationInput | FuelLevelEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FuelLevelEvents.
     */
    cursor?: FuelLevelEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FuelLevelEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FuelLevelEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FuelLevelEvents.
     */
    distinct?: FuelLevelEventScalarFieldEnum | FuelLevelEventScalarFieldEnum[]
  }

  /**
   * FuelLevelEvent findFirstOrThrow
   */
  export type FuelLevelEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FuelLevelEvent
     */
    select?: FuelLevelEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FuelLevelEventInclude<ExtArgs> | null
    /**
     * Filter, which FuelLevelEvent to fetch.
     */
    where?: FuelLevelEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FuelLevelEvents to fetch.
     */
    orderBy?: FuelLevelEventOrderByWithRelationInput | FuelLevelEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FuelLevelEvents.
     */
    cursor?: FuelLevelEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FuelLevelEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FuelLevelEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FuelLevelEvents.
     */
    distinct?: FuelLevelEventScalarFieldEnum | FuelLevelEventScalarFieldEnum[]
  }

  /**
   * FuelLevelEvent findMany
   */
  export type FuelLevelEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FuelLevelEvent
     */
    select?: FuelLevelEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FuelLevelEventInclude<ExtArgs> | null
    /**
     * Filter, which FuelLevelEvents to fetch.
     */
    where?: FuelLevelEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FuelLevelEvents to fetch.
     */
    orderBy?: FuelLevelEventOrderByWithRelationInput | FuelLevelEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FuelLevelEvents.
     */
    cursor?: FuelLevelEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FuelLevelEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FuelLevelEvents.
     */
    skip?: number
    distinct?: FuelLevelEventScalarFieldEnum | FuelLevelEventScalarFieldEnum[]
  }

  /**
   * FuelLevelEvent create
   */
  export type FuelLevelEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FuelLevelEvent
     */
    select?: FuelLevelEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FuelLevelEventInclude<ExtArgs> | null
    /**
     * The data needed to create a FuelLevelEvent.
     */
    data: XOR<FuelLevelEventCreateInput, FuelLevelEventUncheckedCreateInput>
  }

  /**
   * FuelLevelEvent createMany
   */
  export type FuelLevelEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FuelLevelEvents.
     */
    data: FuelLevelEventCreateManyInput | FuelLevelEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FuelLevelEvent createManyAndReturn
   */
  export type FuelLevelEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FuelLevelEvent
     */
    select?: FuelLevelEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FuelLevelEvents.
     */
    data: FuelLevelEventCreateManyInput | FuelLevelEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FuelLevelEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FuelLevelEvent update
   */
  export type FuelLevelEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FuelLevelEvent
     */
    select?: FuelLevelEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FuelLevelEventInclude<ExtArgs> | null
    /**
     * The data needed to update a FuelLevelEvent.
     */
    data: XOR<FuelLevelEventUpdateInput, FuelLevelEventUncheckedUpdateInput>
    /**
     * Choose, which FuelLevelEvent to update.
     */
    where: FuelLevelEventWhereUniqueInput
  }

  /**
   * FuelLevelEvent updateMany
   */
  export type FuelLevelEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FuelLevelEvents.
     */
    data: XOR<FuelLevelEventUpdateManyMutationInput, FuelLevelEventUncheckedUpdateManyInput>
    /**
     * Filter which FuelLevelEvents to update
     */
    where?: FuelLevelEventWhereInput
  }

  /**
   * FuelLevelEvent upsert
   */
  export type FuelLevelEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FuelLevelEvent
     */
    select?: FuelLevelEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FuelLevelEventInclude<ExtArgs> | null
    /**
     * The filter to search for the FuelLevelEvent to update in case it exists.
     */
    where: FuelLevelEventWhereUniqueInput
    /**
     * In case the FuelLevelEvent found by the `where` argument doesn't exist, create a new FuelLevelEvent with this data.
     */
    create: XOR<FuelLevelEventCreateInput, FuelLevelEventUncheckedCreateInput>
    /**
     * In case the FuelLevelEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FuelLevelEventUpdateInput, FuelLevelEventUncheckedUpdateInput>
  }

  /**
   * FuelLevelEvent delete
   */
  export type FuelLevelEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FuelLevelEvent
     */
    select?: FuelLevelEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FuelLevelEventInclude<ExtArgs> | null
    /**
     * Filter which FuelLevelEvent to delete.
     */
    where: FuelLevelEventWhereUniqueInput
  }

  /**
   * FuelLevelEvent deleteMany
   */
  export type FuelLevelEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FuelLevelEvents to delete
     */
    where?: FuelLevelEventWhereInput
  }

  /**
   * FuelLevelEvent without action
   */
  export type FuelLevelEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FuelLevelEvent
     */
    select?: FuelLevelEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FuelLevelEventInclude<ExtArgs> | null
  }


  /**
   * Model SpeedEvent
   */

  export type AggregateSpeedEvent = {
    _count: SpeedEventCountAggregateOutputType | null
    _avg: SpeedEventAvgAggregateOutputType | null
    _sum: SpeedEventSumAggregateOutputType | null
    _min: SpeedEventMinAggregateOutputType | null
    _max: SpeedEventMaxAggregateOutputType | null
  }

  export type SpeedEventAvgAggregateOutputType = {
    speedKph: number | null
  }

  export type SpeedEventSumAggregateOutputType = {
    speedKph: number | null
  }

  export type SpeedEventMinAggregateOutputType = {
    id: string | null
    truckId: string | null
    speedKph: number | null
    changedAt: Date | null
    source: string | null
    createdBy: string | null
  }

  export type SpeedEventMaxAggregateOutputType = {
    id: string | null
    truckId: string | null
    speedKph: number | null
    changedAt: Date | null
    source: string | null
    createdBy: string | null
  }

  export type SpeedEventCountAggregateOutputType = {
    id: number
    truckId: number
    speedKph: number
    changedAt: number
    source: number
    createdBy: number
    _all: number
  }


  export type SpeedEventAvgAggregateInputType = {
    speedKph?: true
  }

  export type SpeedEventSumAggregateInputType = {
    speedKph?: true
  }

  export type SpeedEventMinAggregateInputType = {
    id?: true
    truckId?: true
    speedKph?: true
    changedAt?: true
    source?: true
    createdBy?: true
  }

  export type SpeedEventMaxAggregateInputType = {
    id?: true
    truckId?: true
    speedKph?: true
    changedAt?: true
    source?: true
    createdBy?: true
  }

  export type SpeedEventCountAggregateInputType = {
    id?: true
    truckId?: true
    speedKph?: true
    changedAt?: true
    source?: true
    createdBy?: true
    _all?: true
  }

  export type SpeedEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpeedEvent to aggregate.
     */
    where?: SpeedEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeedEvents to fetch.
     */
    orderBy?: SpeedEventOrderByWithRelationInput | SpeedEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpeedEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeedEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeedEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpeedEvents
    **/
    _count?: true | SpeedEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpeedEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpeedEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpeedEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpeedEventMaxAggregateInputType
  }

  export type GetSpeedEventAggregateType<T extends SpeedEventAggregateArgs> = {
        [P in keyof T & keyof AggregateSpeedEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpeedEvent[P]>
      : GetScalarType<T[P], AggregateSpeedEvent[P]>
  }




  export type SpeedEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpeedEventWhereInput
    orderBy?: SpeedEventOrderByWithAggregationInput | SpeedEventOrderByWithAggregationInput[]
    by: SpeedEventScalarFieldEnum[] | SpeedEventScalarFieldEnum
    having?: SpeedEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpeedEventCountAggregateInputType | true
    _avg?: SpeedEventAvgAggregateInputType
    _sum?: SpeedEventSumAggregateInputType
    _min?: SpeedEventMinAggregateInputType
    _max?: SpeedEventMaxAggregateInputType
  }

  export type SpeedEventGroupByOutputType = {
    id: string
    truckId: string
    speedKph: number | null
    changedAt: Date
    source: string | null
    createdBy: string | null
    _count: SpeedEventCountAggregateOutputType | null
    _avg: SpeedEventAvgAggregateOutputType | null
    _sum: SpeedEventSumAggregateOutputType | null
    _min: SpeedEventMinAggregateOutputType | null
    _max: SpeedEventMaxAggregateOutputType | null
  }

  type GetSpeedEventGroupByPayload<T extends SpeedEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpeedEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpeedEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpeedEventGroupByOutputType[P]>
            : GetScalarType<T[P], SpeedEventGroupByOutputType[P]>
        }
      >
    >


  export type SpeedEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    truckId?: boolean
    speedKph?: boolean
    changedAt?: boolean
    source?: boolean
    createdBy?: boolean
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["speedEvent"]>

  export type SpeedEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    truckId?: boolean
    speedKph?: boolean
    changedAt?: boolean
    source?: boolean
    createdBy?: boolean
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["speedEvent"]>

  export type SpeedEventSelectScalar = {
    id?: boolean
    truckId?: boolean
    speedKph?: boolean
    changedAt?: boolean
    source?: boolean
    createdBy?: boolean
  }

  export type SpeedEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }
  export type SpeedEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }

  export type $SpeedEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpeedEvent"
    objects: {
      truck: Prisma.$TruckPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      truckId: string
      speedKph: number | null
      changedAt: Date
      source: string | null
      createdBy: string | null
    }, ExtArgs["result"]["speedEvent"]>
    composites: {}
  }

  type SpeedEventGetPayload<S extends boolean | null | undefined | SpeedEventDefaultArgs> = $Result.GetResult<Prisma.$SpeedEventPayload, S>

  type SpeedEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpeedEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SpeedEventCountAggregateInputType | true
    }

  export interface SpeedEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpeedEvent'], meta: { name: 'SpeedEvent' } }
    /**
     * Find zero or one SpeedEvent that matches the filter.
     * @param {SpeedEventFindUniqueArgs} args - Arguments to find a SpeedEvent
     * @example
     * // Get one SpeedEvent
     * const speedEvent = await prisma.speedEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpeedEventFindUniqueArgs>(args: SelectSubset<T, SpeedEventFindUniqueArgs<ExtArgs>>): Prisma__SpeedEventClient<$Result.GetResult<Prisma.$SpeedEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SpeedEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SpeedEventFindUniqueOrThrowArgs} args - Arguments to find a SpeedEvent
     * @example
     * // Get one SpeedEvent
     * const speedEvent = await prisma.speedEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpeedEventFindUniqueOrThrowArgs>(args: SelectSubset<T, SpeedEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpeedEventClient<$Result.GetResult<Prisma.$SpeedEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SpeedEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeedEventFindFirstArgs} args - Arguments to find a SpeedEvent
     * @example
     * // Get one SpeedEvent
     * const speedEvent = await prisma.speedEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpeedEventFindFirstArgs>(args?: SelectSubset<T, SpeedEventFindFirstArgs<ExtArgs>>): Prisma__SpeedEventClient<$Result.GetResult<Prisma.$SpeedEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SpeedEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeedEventFindFirstOrThrowArgs} args - Arguments to find a SpeedEvent
     * @example
     * // Get one SpeedEvent
     * const speedEvent = await prisma.speedEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpeedEventFindFirstOrThrowArgs>(args?: SelectSubset<T, SpeedEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpeedEventClient<$Result.GetResult<Prisma.$SpeedEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SpeedEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeedEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpeedEvents
     * const speedEvents = await prisma.speedEvent.findMany()
     * 
     * // Get first 10 SpeedEvents
     * const speedEvents = await prisma.speedEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const speedEventWithIdOnly = await prisma.speedEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpeedEventFindManyArgs>(args?: SelectSubset<T, SpeedEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeedEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SpeedEvent.
     * @param {SpeedEventCreateArgs} args - Arguments to create a SpeedEvent.
     * @example
     * // Create one SpeedEvent
     * const SpeedEvent = await prisma.speedEvent.create({
     *   data: {
     *     // ... data to create a SpeedEvent
     *   }
     * })
     * 
     */
    create<T extends SpeedEventCreateArgs>(args: SelectSubset<T, SpeedEventCreateArgs<ExtArgs>>): Prisma__SpeedEventClient<$Result.GetResult<Prisma.$SpeedEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SpeedEvents.
     * @param {SpeedEventCreateManyArgs} args - Arguments to create many SpeedEvents.
     * @example
     * // Create many SpeedEvents
     * const speedEvent = await prisma.speedEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpeedEventCreateManyArgs>(args?: SelectSubset<T, SpeedEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpeedEvents and returns the data saved in the database.
     * @param {SpeedEventCreateManyAndReturnArgs} args - Arguments to create many SpeedEvents.
     * @example
     * // Create many SpeedEvents
     * const speedEvent = await prisma.speedEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpeedEvents and only return the `id`
     * const speedEventWithIdOnly = await prisma.speedEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpeedEventCreateManyAndReturnArgs>(args?: SelectSubset<T, SpeedEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeedEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SpeedEvent.
     * @param {SpeedEventDeleteArgs} args - Arguments to delete one SpeedEvent.
     * @example
     * // Delete one SpeedEvent
     * const SpeedEvent = await prisma.speedEvent.delete({
     *   where: {
     *     // ... filter to delete one SpeedEvent
     *   }
     * })
     * 
     */
    delete<T extends SpeedEventDeleteArgs>(args: SelectSubset<T, SpeedEventDeleteArgs<ExtArgs>>): Prisma__SpeedEventClient<$Result.GetResult<Prisma.$SpeedEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SpeedEvent.
     * @param {SpeedEventUpdateArgs} args - Arguments to update one SpeedEvent.
     * @example
     * // Update one SpeedEvent
     * const speedEvent = await prisma.speedEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpeedEventUpdateArgs>(args: SelectSubset<T, SpeedEventUpdateArgs<ExtArgs>>): Prisma__SpeedEventClient<$Result.GetResult<Prisma.$SpeedEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SpeedEvents.
     * @param {SpeedEventDeleteManyArgs} args - Arguments to filter SpeedEvents to delete.
     * @example
     * // Delete a few SpeedEvents
     * const { count } = await prisma.speedEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpeedEventDeleteManyArgs>(args?: SelectSubset<T, SpeedEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpeedEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeedEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpeedEvents
     * const speedEvent = await prisma.speedEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpeedEventUpdateManyArgs>(args: SelectSubset<T, SpeedEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpeedEvent.
     * @param {SpeedEventUpsertArgs} args - Arguments to update or create a SpeedEvent.
     * @example
     * // Update or create a SpeedEvent
     * const speedEvent = await prisma.speedEvent.upsert({
     *   create: {
     *     // ... data to create a SpeedEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpeedEvent we want to update
     *   }
     * })
     */
    upsert<T extends SpeedEventUpsertArgs>(args: SelectSubset<T, SpeedEventUpsertArgs<ExtArgs>>): Prisma__SpeedEventClient<$Result.GetResult<Prisma.$SpeedEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SpeedEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeedEventCountArgs} args - Arguments to filter SpeedEvents to count.
     * @example
     * // Count the number of SpeedEvents
     * const count = await prisma.speedEvent.count({
     *   where: {
     *     // ... the filter for the SpeedEvents we want to count
     *   }
     * })
    **/
    count<T extends SpeedEventCountArgs>(
      args?: Subset<T, SpeedEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpeedEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpeedEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeedEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpeedEventAggregateArgs>(args: Subset<T, SpeedEventAggregateArgs>): Prisma.PrismaPromise<GetSpeedEventAggregateType<T>>

    /**
     * Group by SpeedEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeedEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpeedEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpeedEventGroupByArgs['orderBy'] }
        : { orderBy?: SpeedEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpeedEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpeedEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpeedEvent model
   */
  readonly fields: SpeedEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpeedEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpeedEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    truck<T extends TruckDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TruckDefaultArgs<ExtArgs>>): Prisma__TruckClient<$Result.GetResult<Prisma.$TruckPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpeedEvent model
   */ 
  interface SpeedEventFieldRefs {
    readonly id: FieldRef<"SpeedEvent", 'String'>
    readonly truckId: FieldRef<"SpeedEvent", 'String'>
    readonly speedKph: FieldRef<"SpeedEvent", 'Float'>
    readonly changedAt: FieldRef<"SpeedEvent", 'DateTime'>
    readonly source: FieldRef<"SpeedEvent", 'String'>
    readonly createdBy: FieldRef<"SpeedEvent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SpeedEvent findUnique
   */
  export type SpeedEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeedEvent
     */
    select?: SpeedEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeedEventInclude<ExtArgs> | null
    /**
     * Filter, which SpeedEvent to fetch.
     */
    where: SpeedEventWhereUniqueInput
  }

  /**
   * SpeedEvent findUniqueOrThrow
   */
  export type SpeedEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeedEvent
     */
    select?: SpeedEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeedEventInclude<ExtArgs> | null
    /**
     * Filter, which SpeedEvent to fetch.
     */
    where: SpeedEventWhereUniqueInput
  }

  /**
   * SpeedEvent findFirst
   */
  export type SpeedEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeedEvent
     */
    select?: SpeedEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeedEventInclude<ExtArgs> | null
    /**
     * Filter, which SpeedEvent to fetch.
     */
    where?: SpeedEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeedEvents to fetch.
     */
    orderBy?: SpeedEventOrderByWithRelationInput | SpeedEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpeedEvents.
     */
    cursor?: SpeedEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeedEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeedEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpeedEvents.
     */
    distinct?: SpeedEventScalarFieldEnum | SpeedEventScalarFieldEnum[]
  }

  /**
   * SpeedEvent findFirstOrThrow
   */
  export type SpeedEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeedEvent
     */
    select?: SpeedEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeedEventInclude<ExtArgs> | null
    /**
     * Filter, which SpeedEvent to fetch.
     */
    where?: SpeedEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeedEvents to fetch.
     */
    orderBy?: SpeedEventOrderByWithRelationInput | SpeedEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpeedEvents.
     */
    cursor?: SpeedEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeedEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeedEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpeedEvents.
     */
    distinct?: SpeedEventScalarFieldEnum | SpeedEventScalarFieldEnum[]
  }

  /**
   * SpeedEvent findMany
   */
  export type SpeedEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeedEvent
     */
    select?: SpeedEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeedEventInclude<ExtArgs> | null
    /**
     * Filter, which SpeedEvents to fetch.
     */
    where?: SpeedEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeedEvents to fetch.
     */
    orderBy?: SpeedEventOrderByWithRelationInput | SpeedEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpeedEvents.
     */
    cursor?: SpeedEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeedEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeedEvents.
     */
    skip?: number
    distinct?: SpeedEventScalarFieldEnum | SpeedEventScalarFieldEnum[]
  }

  /**
   * SpeedEvent create
   */
  export type SpeedEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeedEvent
     */
    select?: SpeedEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeedEventInclude<ExtArgs> | null
    /**
     * The data needed to create a SpeedEvent.
     */
    data: XOR<SpeedEventCreateInput, SpeedEventUncheckedCreateInput>
  }

  /**
   * SpeedEvent createMany
   */
  export type SpeedEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpeedEvents.
     */
    data: SpeedEventCreateManyInput | SpeedEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpeedEvent createManyAndReturn
   */
  export type SpeedEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeedEvent
     */
    select?: SpeedEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SpeedEvents.
     */
    data: SpeedEventCreateManyInput | SpeedEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeedEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpeedEvent update
   */
  export type SpeedEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeedEvent
     */
    select?: SpeedEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeedEventInclude<ExtArgs> | null
    /**
     * The data needed to update a SpeedEvent.
     */
    data: XOR<SpeedEventUpdateInput, SpeedEventUncheckedUpdateInput>
    /**
     * Choose, which SpeedEvent to update.
     */
    where: SpeedEventWhereUniqueInput
  }

  /**
   * SpeedEvent updateMany
   */
  export type SpeedEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpeedEvents.
     */
    data: XOR<SpeedEventUpdateManyMutationInput, SpeedEventUncheckedUpdateManyInput>
    /**
     * Filter which SpeedEvents to update
     */
    where?: SpeedEventWhereInput
  }

  /**
   * SpeedEvent upsert
   */
  export type SpeedEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeedEvent
     */
    select?: SpeedEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeedEventInclude<ExtArgs> | null
    /**
     * The filter to search for the SpeedEvent to update in case it exists.
     */
    where: SpeedEventWhereUniqueInput
    /**
     * In case the SpeedEvent found by the `where` argument doesn't exist, create a new SpeedEvent with this data.
     */
    create: XOR<SpeedEventCreateInput, SpeedEventUncheckedCreateInput>
    /**
     * In case the SpeedEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpeedEventUpdateInput, SpeedEventUncheckedUpdateInput>
  }

  /**
   * SpeedEvent delete
   */
  export type SpeedEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeedEvent
     */
    select?: SpeedEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeedEventInclude<ExtArgs> | null
    /**
     * Filter which SpeedEvent to delete.
     */
    where: SpeedEventWhereUniqueInput
  }

  /**
   * SpeedEvent deleteMany
   */
  export type SpeedEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpeedEvents to delete
     */
    where?: SpeedEventWhereInput
  }

  /**
   * SpeedEvent without action
   */
  export type SpeedEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeedEvent
     */
    select?: SpeedEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeedEventInclude<ExtArgs> | null
  }


  /**
   * Model AlertEvent
   */

  export type AggregateAlertEvent = {
    _count: AlertEventCountAggregateOutputType | null
    _avg: AlertEventAvgAggregateOutputType | null
    _sum: AlertEventSumAggregateOutputType | null
    _min: AlertEventMinAggregateOutputType | null
    _max: AlertEventMaxAggregateOutputType | null
  }

  export type AlertEventAvgAggregateOutputType = {
    severity: number | null
  }

  export type AlertEventSumAggregateOutputType = {
    severity: number | null
  }

  export type AlertEventMinAggregateOutputType = {
    id: string | null
    truckId: string | null
    type: $Enums.AlertType | null
    severity: number | null
    occurredAt: Date | null
    acknowledged: boolean | null
    createdBy: string | null
  }

  export type AlertEventMaxAggregateOutputType = {
    id: string | null
    truckId: string | null
    type: $Enums.AlertType | null
    severity: number | null
    occurredAt: Date | null
    acknowledged: boolean | null
    createdBy: string | null
  }

  export type AlertEventCountAggregateOutputType = {
    id: number
    truckId: number
    type: number
    severity: number
    detail: number
    occurredAt: number
    acknowledged: number
    createdBy: number
    _all: number
  }


  export type AlertEventAvgAggregateInputType = {
    severity?: true
  }

  export type AlertEventSumAggregateInputType = {
    severity?: true
  }

  export type AlertEventMinAggregateInputType = {
    id?: true
    truckId?: true
    type?: true
    severity?: true
    occurredAt?: true
    acknowledged?: true
    createdBy?: true
  }

  export type AlertEventMaxAggregateInputType = {
    id?: true
    truckId?: true
    type?: true
    severity?: true
    occurredAt?: true
    acknowledged?: true
    createdBy?: true
  }

  export type AlertEventCountAggregateInputType = {
    id?: true
    truckId?: true
    type?: true
    severity?: true
    detail?: true
    occurredAt?: true
    acknowledged?: true
    createdBy?: true
    _all?: true
  }

  export type AlertEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlertEvent to aggregate.
     */
    where?: AlertEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertEvents to fetch.
     */
    orderBy?: AlertEventOrderByWithRelationInput | AlertEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AlertEvents
    **/
    _count?: true | AlertEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlertEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlertEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertEventMaxAggregateInputType
  }

  export type GetAlertEventAggregateType<T extends AlertEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAlertEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlertEvent[P]>
      : GetScalarType<T[P], AggregateAlertEvent[P]>
  }




  export type AlertEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertEventWhereInput
    orderBy?: AlertEventOrderByWithAggregationInput | AlertEventOrderByWithAggregationInput[]
    by: AlertEventScalarFieldEnum[] | AlertEventScalarFieldEnum
    having?: AlertEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertEventCountAggregateInputType | true
    _avg?: AlertEventAvgAggregateInputType
    _sum?: AlertEventSumAggregateInputType
    _min?: AlertEventMinAggregateInputType
    _max?: AlertEventMaxAggregateInputType
  }

  export type AlertEventGroupByOutputType = {
    id: string
    truckId: string
    type: $Enums.AlertType
    severity: number | null
    detail: JsonValue | null
    occurredAt: Date
    acknowledged: boolean
    createdBy: string | null
    _count: AlertEventCountAggregateOutputType | null
    _avg: AlertEventAvgAggregateOutputType | null
    _sum: AlertEventSumAggregateOutputType | null
    _min: AlertEventMinAggregateOutputType | null
    _max: AlertEventMaxAggregateOutputType | null
  }

  type GetAlertEventGroupByPayload<T extends AlertEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertEventGroupByOutputType[P]>
            : GetScalarType<T[P], AlertEventGroupByOutputType[P]>
        }
      >
    >


  export type AlertEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    truckId?: boolean
    type?: boolean
    severity?: boolean
    detail?: boolean
    occurredAt?: boolean
    acknowledged?: boolean
    createdBy?: boolean
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alertEvent"]>

  export type AlertEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    truckId?: boolean
    type?: boolean
    severity?: boolean
    detail?: boolean
    occurredAt?: boolean
    acknowledged?: boolean
    createdBy?: boolean
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alertEvent"]>

  export type AlertEventSelectScalar = {
    id?: boolean
    truckId?: boolean
    type?: boolean
    severity?: boolean
    detail?: boolean
    occurredAt?: boolean
    acknowledged?: boolean
    createdBy?: boolean
  }

  export type AlertEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }
  export type AlertEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }

  export type $AlertEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AlertEvent"
    objects: {
      truck: Prisma.$TruckPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      truckId: string
      type: $Enums.AlertType
      severity: number | null
      detail: Prisma.JsonValue | null
      occurredAt: Date
      acknowledged: boolean
      createdBy: string | null
    }, ExtArgs["result"]["alertEvent"]>
    composites: {}
  }

  type AlertEventGetPayload<S extends boolean | null | undefined | AlertEventDefaultArgs> = $Result.GetResult<Prisma.$AlertEventPayload, S>

  type AlertEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AlertEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AlertEventCountAggregateInputType | true
    }

  export interface AlertEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AlertEvent'], meta: { name: 'AlertEvent' } }
    /**
     * Find zero or one AlertEvent that matches the filter.
     * @param {AlertEventFindUniqueArgs} args - Arguments to find a AlertEvent
     * @example
     * // Get one AlertEvent
     * const alertEvent = await prisma.alertEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlertEventFindUniqueArgs>(args: SelectSubset<T, AlertEventFindUniqueArgs<ExtArgs>>): Prisma__AlertEventClient<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AlertEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AlertEventFindUniqueOrThrowArgs} args - Arguments to find a AlertEvent
     * @example
     * // Get one AlertEvent
     * const alertEvent = await prisma.alertEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlertEventFindUniqueOrThrowArgs>(args: SelectSubset<T, AlertEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlertEventClient<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AlertEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertEventFindFirstArgs} args - Arguments to find a AlertEvent
     * @example
     * // Get one AlertEvent
     * const alertEvent = await prisma.alertEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlertEventFindFirstArgs>(args?: SelectSubset<T, AlertEventFindFirstArgs<ExtArgs>>): Prisma__AlertEventClient<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AlertEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertEventFindFirstOrThrowArgs} args - Arguments to find a AlertEvent
     * @example
     * // Get one AlertEvent
     * const alertEvent = await prisma.alertEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlertEventFindFirstOrThrowArgs>(args?: SelectSubset<T, AlertEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlertEventClient<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AlertEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AlertEvents
     * const alertEvents = await prisma.alertEvent.findMany()
     * 
     * // Get first 10 AlertEvents
     * const alertEvents = await prisma.alertEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertEventWithIdOnly = await prisma.alertEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlertEventFindManyArgs>(args?: SelectSubset<T, AlertEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AlertEvent.
     * @param {AlertEventCreateArgs} args - Arguments to create a AlertEvent.
     * @example
     * // Create one AlertEvent
     * const AlertEvent = await prisma.alertEvent.create({
     *   data: {
     *     // ... data to create a AlertEvent
     *   }
     * })
     * 
     */
    create<T extends AlertEventCreateArgs>(args: SelectSubset<T, AlertEventCreateArgs<ExtArgs>>): Prisma__AlertEventClient<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AlertEvents.
     * @param {AlertEventCreateManyArgs} args - Arguments to create many AlertEvents.
     * @example
     * // Create many AlertEvents
     * const alertEvent = await prisma.alertEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlertEventCreateManyArgs>(args?: SelectSubset<T, AlertEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AlertEvents and returns the data saved in the database.
     * @param {AlertEventCreateManyAndReturnArgs} args - Arguments to create many AlertEvents.
     * @example
     * // Create many AlertEvents
     * const alertEvent = await prisma.alertEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AlertEvents and only return the `id`
     * const alertEventWithIdOnly = await prisma.alertEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlertEventCreateManyAndReturnArgs>(args?: SelectSubset<T, AlertEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AlertEvent.
     * @param {AlertEventDeleteArgs} args - Arguments to delete one AlertEvent.
     * @example
     * // Delete one AlertEvent
     * const AlertEvent = await prisma.alertEvent.delete({
     *   where: {
     *     // ... filter to delete one AlertEvent
     *   }
     * })
     * 
     */
    delete<T extends AlertEventDeleteArgs>(args: SelectSubset<T, AlertEventDeleteArgs<ExtArgs>>): Prisma__AlertEventClient<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AlertEvent.
     * @param {AlertEventUpdateArgs} args - Arguments to update one AlertEvent.
     * @example
     * // Update one AlertEvent
     * const alertEvent = await prisma.alertEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlertEventUpdateArgs>(args: SelectSubset<T, AlertEventUpdateArgs<ExtArgs>>): Prisma__AlertEventClient<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AlertEvents.
     * @param {AlertEventDeleteManyArgs} args - Arguments to filter AlertEvents to delete.
     * @example
     * // Delete a few AlertEvents
     * const { count } = await prisma.alertEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlertEventDeleteManyArgs>(args?: SelectSubset<T, AlertEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlertEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AlertEvents
     * const alertEvent = await prisma.alertEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlertEventUpdateManyArgs>(args: SelectSubset<T, AlertEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AlertEvent.
     * @param {AlertEventUpsertArgs} args - Arguments to update or create a AlertEvent.
     * @example
     * // Update or create a AlertEvent
     * const alertEvent = await prisma.alertEvent.upsert({
     *   create: {
     *     // ... data to create a AlertEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AlertEvent we want to update
     *   }
     * })
     */
    upsert<T extends AlertEventUpsertArgs>(args: SelectSubset<T, AlertEventUpsertArgs<ExtArgs>>): Prisma__AlertEventClient<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AlertEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertEventCountArgs} args - Arguments to filter AlertEvents to count.
     * @example
     * // Count the number of AlertEvents
     * const count = await prisma.alertEvent.count({
     *   where: {
     *     // ... the filter for the AlertEvents we want to count
     *   }
     * })
    **/
    count<T extends AlertEventCountArgs>(
      args?: Subset<T, AlertEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AlertEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertEventAggregateArgs>(args: Subset<T, AlertEventAggregateArgs>): Prisma.PrismaPromise<GetAlertEventAggregateType<T>>

    /**
     * Group by AlertEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertEventGroupByArgs['orderBy'] }
        : { orderBy?: AlertEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AlertEvent model
   */
  readonly fields: AlertEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AlertEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlertEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    truck<T extends TruckDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TruckDefaultArgs<ExtArgs>>): Prisma__TruckClient<$Result.GetResult<Prisma.$TruckPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AlertEvent model
   */ 
  interface AlertEventFieldRefs {
    readonly id: FieldRef<"AlertEvent", 'String'>
    readonly truckId: FieldRef<"AlertEvent", 'String'>
    readonly type: FieldRef<"AlertEvent", 'AlertType'>
    readonly severity: FieldRef<"AlertEvent", 'Int'>
    readonly detail: FieldRef<"AlertEvent", 'Json'>
    readonly occurredAt: FieldRef<"AlertEvent", 'DateTime'>
    readonly acknowledged: FieldRef<"AlertEvent", 'Boolean'>
    readonly createdBy: FieldRef<"AlertEvent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AlertEvent findUnique
   */
  export type AlertEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    /**
     * Filter, which AlertEvent to fetch.
     */
    where: AlertEventWhereUniqueInput
  }

  /**
   * AlertEvent findUniqueOrThrow
   */
  export type AlertEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    /**
     * Filter, which AlertEvent to fetch.
     */
    where: AlertEventWhereUniqueInput
  }

  /**
   * AlertEvent findFirst
   */
  export type AlertEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    /**
     * Filter, which AlertEvent to fetch.
     */
    where?: AlertEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertEvents to fetch.
     */
    orderBy?: AlertEventOrderByWithRelationInput | AlertEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlertEvents.
     */
    cursor?: AlertEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlertEvents.
     */
    distinct?: AlertEventScalarFieldEnum | AlertEventScalarFieldEnum[]
  }

  /**
   * AlertEvent findFirstOrThrow
   */
  export type AlertEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    /**
     * Filter, which AlertEvent to fetch.
     */
    where?: AlertEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertEvents to fetch.
     */
    orderBy?: AlertEventOrderByWithRelationInput | AlertEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlertEvents.
     */
    cursor?: AlertEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlertEvents.
     */
    distinct?: AlertEventScalarFieldEnum | AlertEventScalarFieldEnum[]
  }

  /**
   * AlertEvent findMany
   */
  export type AlertEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    /**
     * Filter, which AlertEvents to fetch.
     */
    where?: AlertEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertEvents to fetch.
     */
    orderBy?: AlertEventOrderByWithRelationInput | AlertEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AlertEvents.
     */
    cursor?: AlertEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertEvents.
     */
    skip?: number
    distinct?: AlertEventScalarFieldEnum | AlertEventScalarFieldEnum[]
  }

  /**
   * AlertEvent create
   */
  export type AlertEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    /**
     * The data needed to create a AlertEvent.
     */
    data: XOR<AlertEventCreateInput, AlertEventUncheckedCreateInput>
  }

  /**
   * AlertEvent createMany
   */
  export type AlertEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AlertEvents.
     */
    data: AlertEventCreateManyInput | AlertEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AlertEvent createManyAndReturn
   */
  export type AlertEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AlertEvents.
     */
    data: AlertEventCreateManyInput | AlertEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AlertEvent update
   */
  export type AlertEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    /**
     * The data needed to update a AlertEvent.
     */
    data: XOR<AlertEventUpdateInput, AlertEventUncheckedUpdateInput>
    /**
     * Choose, which AlertEvent to update.
     */
    where: AlertEventWhereUniqueInput
  }

  /**
   * AlertEvent updateMany
   */
  export type AlertEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AlertEvents.
     */
    data: XOR<AlertEventUpdateManyMutationInput, AlertEventUncheckedUpdateManyInput>
    /**
     * Filter which AlertEvents to update
     */
    where?: AlertEventWhereInput
  }

  /**
   * AlertEvent upsert
   */
  export type AlertEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    /**
     * The filter to search for the AlertEvent to update in case it exists.
     */
    where: AlertEventWhereUniqueInput
    /**
     * In case the AlertEvent found by the `where` argument doesn't exist, create a new AlertEvent with this data.
     */
    create: XOR<AlertEventCreateInput, AlertEventUncheckedCreateInput>
    /**
     * In case the AlertEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertEventUpdateInput, AlertEventUncheckedUpdateInput>
  }

  /**
   * AlertEvent delete
   */
  export type AlertEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    /**
     * Filter which AlertEvent to delete.
     */
    where: AlertEventWhereUniqueInput
  }

  /**
   * AlertEvent deleteMany
   */
  export type AlertEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlertEvents to delete
     */
    where?: AlertEventWhereInput
  }

  /**
   * AlertEvent without action
   */
  export type AlertEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
  }


  /**
   * Model DeviceStatusEvent
   */

  export type AggregateDeviceStatusEvent = {
    _count: DeviceStatusEventCountAggregateOutputType | null
    _avg: DeviceStatusEventAvgAggregateOutputType | null
    _sum: DeviceStatusEventSumAggregateOutputType | null
    _min: DeviceStatusEventMinAggregateOutputType | null
    _max: DeviceStatusEventMaxAggregateOutputType | null
  }

  export type DeviceStatusEventAvgAggregateOutputType = {
    hostBat: number | null
    repeater1Bat: number | null
    repeater2Bat: number | null
    lockState: number | null
  }

  export type DeviceStatusEventSumAggregateOutputType = {
    hostBat: number | null
    repeater1Bat: number | null
    repeater2Bat: number | null
    lockState: number | null
  }

  export type DeviceStatusEventMinAggregateOutputType = {
    id: string | null
    deviceId: string | null
    truckId: string | null
    hostBat: number | null
    repeater1Bat: number | null
    repeater2Bat: number | null
    lockState: number | null
    reportedAt: Date | null
    createdBy: string | null
  }

  export type DeviceStatusEventMaxAggregateOutputType = {
    id: string | null
    deviceId: string | null
    truckId: string | null
    hostBat: number | null
    repeater1Bat: number | null
    repeater2Bat: number | null
    lockState: number | null
    reportedAt: Date | null
    createdBy: string | null
  }

  export type DeviceStatusEventCountAggregateOutputType = {
    id: number
    deviceId: number
    truckId: number
    hostBat: number
    repeater1Bat: number
    repeater2Bat: number
    lockState: number
    reportedAt: number
    createdBy: number
    _all: number
  }


  export type DeviceStatusEventAvgAggregateInputType = {
    hostBat?: true
    repeater1Bat?: true
    repeater2Bat?: true
    lockState?: true
  }

  export type DeviceStatusEventSumAggregateInputType = {
    hostBat?: true
    repeater1Bat?: true
    repeater2Bat?: true
    lockState?: true
  }

  export type DeviceStatusEventMinAggregateInputType = {
    id?: true
    deviceId?: true
    truckId?: true
    hostBat?: true
    repeater1Bat?: true
    repeater2Bat?: true
    lockState?: true
    reportedAt?: true
    createdBy?: true
  }

  export type DeviceStatusEventMaxAggregateInputType = {
    id?: true
    deviceId?: true
    truckId?: true
    hostBat?: true
    repeater1Bat?: true
    repeater2Bat?: true
    lockState?: true
    reportedAt?: true
    createdBy?: true
  }

  export type DeviceStatusEventCountAggregateInputType = {
    id?: true
    deviceId?: true
    truckId?: true
    hostBat?: true
    repeater1Bat?: true
    repeater2Bat?: true
    lockState?: true
    reportedAt?: true
    createdBy?: true
    _all?: true
  }

  export type DeviceStatusEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceStatusEvent to aggregate.
     */
    where?: DeviceStatusEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceStatusEvents to fetch.
     */
    orderBy?: DeviceStatusEventOrderByWithRelationInput | DeviceStatusEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceStatusEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceStatusEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceStatusEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceStatusEvents
    **/
    _count?: true | DeviceStatusEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceStatusEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceStatusEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceStatusEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceStatusEventMaxAggregateInputType
  }

  export type GetDeviceStatusEventAggregateType<T extends DeviceStatusEventAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceStatusEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceStatusEvent[P]>
      : GetScalarType<T[P], AggregateDeviceStatusEvent[P]>
  }




  export type DeviceStatusEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceStatusEventWhereInput
    orderBy?: DeviceStatusEventOrderByWithAggregationInput | DeviceStatusEventOrderByWithAggregationInput[]
    by: DeviceStatusEventScalarFieldEnum[] | DeviceStatusEventScalarFieldEnum
    having?: DeviceStatusEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceStatusEventCountAggregateInputType | true
    _avg?: DeviceStatusEventAvgAggregateInputType
    _sum?: DeviceStatusEventSumAggregateInputType
    _min?: DeviceStatusEventMinAggregateInputType
    _max?: DeviceStatusEventMaxAggregateInputType
  }

  export type DeviceStatusEventGroupByOutputType = {
    id: string
    deviceId: string
    truckId: string
    hostBat: number | null
    repeater1Bat: number | null
    repeater2Bat: number | null
    lockState: number | null
    reportedAt: Date
    createdBy: string | null
    _count: DeviceStatusEventCountAggregateOutputType | null
    _avg: DeviceStatusEventAvgAggregateOutputType | null
    _sum: DeviceStatusEventSumAggregateOutputType | null
    _min: DeviceStatusEventMinAggregateOutputType | null
    _max: DeviceStatusEventMaxAggregateOutputType | null
  }

  type GetDeviceStatusEventGroupByPayload<T extends DeviceStatusEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceStatusEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceStatusEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceStatusEventGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceStatusEventGroupByOutputType[P]>
        }
      >
    >


  export type DeviceStatusEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    truckId?: boolean
    hostBat?: boolean
    repeater1Bat?: boolean
    repeater2Bat?: boolean
    lockState?: boolean
    reportedAt?: boolean
    createdBy?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceStatusEvent"]>

  export type DeviceStatusEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    truckId?: boolean
    hostBat?: boolean
    repeater1Bat?: boolean
    repeater2Bat?: boolean
    lockState?: boolean
    reportedAt?: boolean
    createdBy?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceStatusEvent"]>

  export type DeviceStatusEventSelectScalar = {
    id?: boolean
    deviceId?: boolean
    truckId?: boolean
    hostBat?: boolean
    repeater1Bat?: boolean
    repeater2Bat?: boolean
    lockState?: boolean
    reportedAt?: boolean
    createdBy?: boolean
  }

  export type DeviceStatusEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }
  export type DeviceStatusEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }

  export type $DeviceStatusEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceStatusEvent"
    objects: {
      device: Prisma.$DevicePayload<ExtArgs>
      truck: Prisma.$TruckPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deviceId: string
      truckId: string
      hostBat: number | null
      repeater1Bat: number | null
      repeater2Bat: number | null
      lockState: number | null
      reportedAt: Date
      createdBy: string | null
    }, ExtArgs["result"]["deviceStatusEvent"]>
    composites: {}
  }

  type DeviceStatusEventGetPayload<S extends boolean | null | undefined | DeviceStatusEventDefaultArgs> = $Result.GetResult<Prisma.$DeviceStatusEventPayload, S>

  type DeviceStatusEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeviceStatusEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeviceStatusEventCountAggregateInputType | true
    }

  export interface DeviceStatusEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceStatusEvent'], meta: { name: 'DeviceStatusEvent' } }
    /**
     * Find zero or one DeviceStatusEvent that matches the filter.
     * @param {DeviceStatusEventFindUniqueArgs} args - Arguments to find a DeviceStatusEvent
     * @example
     * // Get one DeviceStatusEvent
     * const deviceStatusEvent = await prisma.deviceStatusEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceStatusEventFindUniqueArgs>(args: SelectSubset<T, DeviceStatusEventFindUniqueArgs<ExtArgs>>): Prisma__DeviceStatusEventClient<$Result.GetResult<Prisma.$DeviceStatusEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DeviceStatusEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeviceStatusEventFindUniqueOrThrowArgs} args - Arguments to find a DeviceStatusEvent
     * @example
     * // Get one DeviceStatusEvent
     * const deviceStatusEvent = await prisma.deviceStatusEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceStatusEventFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceStatusEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceStatusEventClient<$Result.GetResult<Prisma.$DeviceStatusEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DeviceStatusEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceStatusEventFindFirstArgs} args - Arguments to find a DeviceStatusEvent
     * @example
     * // Get one DeviceStatusEvent
     * const deviceStatusEvent = await prisma.deviceStatusEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceStatusEventFindFirstArgs>(args?: SelectSubset<T, DeviceStatusEventFindFirstArgs<ExtArgs>>): Prisma__DeviceStatusEventClient<$Result.GetResult<Prisma.$DeviceStatusEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DeviceStatusEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceStatusEventFindFirstOrThrowArgs} args - Arguments to find a DeviceStatusEvent
     * @example
     * // Get one DeviceStatusEvent
     * const deviceStatusEvent = await prisma.deviceStatusEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceStatusEventFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceStatusEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceStatusEventClient<$Result.GetResult<Prisma.$DeviceStatusEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DeviceStatusEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceStatusEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceStatusEvents
     * const deviceStatusEvents = await prisma.deviceStatusEvent.findMany()
     * 
     * // Get first 10 DeviceStatusEvents
     * const deviceStatusEvents = await prisma.deviceStatusEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceStatusEventWithIdOnly = await prisma.deviceStatusEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceStatusEventFindManyArgs>(args?: SelectSubset<T, DeviceStatusEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceStatusEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DeviceStatusEvent.
     * @param {DeviceStatusEventCreateArgs} args - Arguments to create a DeviceStatusEvent.
     * @example
     * // Create one DeviceStatusEvent
     * const DeviceStatusEvent = await prisma.deviceStatusEvent.create({
     *   data: {
     *     // ... data to create a DeviceStatusEvent
     *   }
     * })
     * 
     */
    create<T extends DeviceStatusEventCreateArgs>(args: SelectSubset<T, DeviceStatusEventCreateArgs<ExtArgs>>): Prisma__DeviceStatusEventClient<$Result.GetResult<Prisma.$DeviceStatusEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DeviceStatusEvents.
     * @param {DeviceStatusEventCreateManyArgs} args - Arguments to create many DeviceStatusEvents.
     * @example
     * // Create many DeviceStatusEvents
     * const deviceStatusEvent = await prisma.deviceStatusEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceStatusEventCreateManyArgs>(args?: SelectSubset<T, DeviceStatusEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceStatusEvents and returns the data saved in the database.
     * @param {DeviceStatusEventCreateManyAndReturnArgs} args - Arguments to create many DeviceStatusEvents.
     * @example
     * // Create many DeviceStatusEvents
     * const deviceStatusEvent = await prisma.deviceStatusEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceStatusEvents and only return the `id`
     * const deviceStatusEventWithIdOnly = await prisma.deviceStatusEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceStatusEventCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceStatusEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceStatusEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DeviceStatusEvent.
     * @param {DeviceStatusEventDeleteArgs} args - Arguments to delete one DeviceStatusEvent.
     * @example
     * // Delete one DeviceStatusEvent
     * const DeviceStatusEvent = await prisma.deviceStatusEvent.delete({
     *   where: {
     *     // ... filter to delete one DeviceStatusEvent
     *   }
     * })
     * 
     */
    delete<T extends DeviceStatusEventDeleteArgs>(args: SelectSubset<T, DeviceStatusEventDeleteArgs<ExtArgs>>): Prisma__DeviceStatusEventClient<$Result.GetResult<Prisma.$DeviceStatusEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DeviceStatusEvent.
     * @param {DeviceStatusEventUpdateArgs} args - Arguments to update one DeviceStatusEvent.
     * @example
     * // Update one DeviceStatusEvent
     * const deviceStatusEvent = await prisma.deviceStatusEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceStatusEventUpdateArgs>(args: SelectSubset<T, DeviceStatusEventUpdateArgs<ExtArgs>>): Prisma__DeviceStatusEventClient<$Result.GetResult<Prisma.$DeviceStatusEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DeviceStatusEvents.
     * @param {DeviceStatusEventDeleteManyArgs} args - Arguments to filter DeviceStatusEvents to delete.
     * @example
     * // Delete a few DeviceStatusEvents
     * const { count } = await prisma.deviceStatusEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceStatusEventDeleteManyArgs>(args?: SelectSubset<T, DeviceStatusEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceStatusEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceStatusEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceStatusEvents
     * const deviceStatusEvent = await prisma.deviceStatusEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceStatusEventUpdateManyArgs>(args: SelectSubset<T, DeviceStatusEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeviceStatusEvent.
     * @param {DeviceStatusEventUpsertArgs} args - Arguments to update or create a DeviceStatusEvent.
     * @example
     * // Update or create a DeviceStatusEvent
     * const deviceStatusEvent = await prisma.deviceStatusEvent.upsert({
     *   create: {
     *     // ... data to create a DeviceStatusEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceStatusEvent we want to update
     *   }
     * })
     */
    upsert<T extends DeviceStatusEventUpsertArgs>(args: SelectSubset<T, DeviceStatusEventUpsertArgs<ExtArgs>>): Prisma__DeviceStatusEventClient<$Result.GetResult<Prisma.$DeviceStatusEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DeviceStatusEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceStatusEventCountArgs} args - Arguments to filter DeviceStatusEvents to count.
     * @example
     * // Count the number of DeviceStatusEvents
     * const count = await prisma.deviceStatusEvent.count({
     *   where: {
     *     // ... the filter for the DeviceStatusEvents we want to count
     *   }
     * })
    **/
    count<T extends DeviceStatusEventCountArgs>(
      args?: Subset<T, DeviceStatusEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceStatusEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceStatusEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceStatusEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceStatusEventAggregateArgs>(args: Subset<T, DeviceStatusEventAggregateArgs>): Prisma.PrismaPromise<GetDeviceStatusEventAggregateType<T>>

    /**
     * Group by DeviceStatusEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceStatusEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceStatusEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceStatusEventGroupByArgs['orderBy'] }
        : { orderBy?: DeviceStatusEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceStatusEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceStatusEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceStatusEvent model
   */
  readonly fields: DeviceStatusEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceStatusEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceStatusEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends DeviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceDefaultArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    truck<T extends TruckDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TruckDefaultArgs<ExtArgs>>): Prisma__TruckClient<$Result.GetResult<Prisma.$TruckPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceStatusEvent model
   */ 
  interface DeviceStatusEventFieldRefs {
    readonly id: FieldRef<"DeviceStatusEvent", 'String'>
    readonly deviceId: FieldRef<"DeviceStatusEvent", 'String'>
    readonly truckId: FieldRef<"DeviceStatusEvent", 'String'>
    readonly hostBat: FieldRef<"DeviceStatusEvent", 'Int'>
    readonly repeater1Bat: FieldRef<"DeviceStatusEvent", 'Int'>
    readonly repeater2Bat: FieldRef<"DeviceStatusEvent", 'Int'>
    readonly lockState: FieldRef<"DeviceStatusEvent", 'Int'>
    readonly reportedAt: FieldRef<"DeviceStatusEvent", 'DateTime'>
    readonly createdBy: FieldRef<"DeviceStatusEvent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DeviceStatusEvent findUnique
   */
  export type DeviceStatusEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStatusEvent
     */
    select?: DeviceStatusEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceStatusEventInclude<ExtArgs> | null
    /**
     * Filter, which DeviceStatusEvent to fetch.
     */
    where: DeviceStatusEventWhereUniqueInput
  }

  /**
   * DeviceStatusEvent findUniqueOrThrow
   */
  export type DeviceStatusEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStatusEvent
     */
    select?: DeviceStatusEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceStatusEventInclude<ExtArgs> | null
    /**
     * Filter, which DeviceStatusEvent to fetch.
     */
    where: DeviceStatusEventWhereUniqueInput
  }

  /**
   * DeviceStatusEvent findFirst
   */
  export type DeviceStatusEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStatusEvent
     */
    select?: DeviceStatusEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceStatusEventInclude<ExtArgs> | null
    /**
     * Filter, which DeviceStatusEvent to fetch.
     */
    where?: DeviceStatusEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceStatusEvents to fetch.
     */
    orderBy?: DeviceStatusEventOrderByWithRelationInput | DeviceStatusEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceStatusEvents.
     */
    cursor?: DeviceStatusEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceStatusEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceStatusEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceStatusEvents.
     */
    distinct?: DeviceStatusEventScalarFieldEnum | DeviceStatusEventScalarFieldEnum[]
  }

  /**
   * DeviceStatusEvent findFirstOrThrow
   */
  export type DeviceStatusEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStatusEvent
     */
    select?: DeviceStatusEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceStatusEventInclude<ExtArgs> | null
    /**
     * Filter, which DeviceStatusEvent to fetch.
     */
    where?: DeviceStatusEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceStatusEvents to fetch.
     */
    orderBy?: DeviceStatusEventOrderByWithRelationInput | DeviceStatusEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceStatusEvents.
     */
    cursor?: DeviceStatusEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceStatusEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceStatusEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceStatusEvents.
     */
    distinct?: DeviceStatusEventScalarFieldEnum | DeviceStatusEventScalarFieldEnum[]
  }

  /**
   * DeviceStatusEvent findMany
   */
  export type DeviceStatusEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStatusEvent
     */
    select?: DeviceStatusEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceStatusEventInclude<ExtArgs> | null
    /**
     * Filter, which DeviceStatusEvents to fetch.
     */
    where?: DeviceStatusEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceStatusEvents to fetch.
     */
    orderBy?: DeviceStatusEventOrderByWithRelationInput | DeviceStatusEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceStatusEvents.
     */
    cursor?: DeviceStatusEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceStatusEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceStatusEvents.
     */
    skip?: number
    distinct?: DeviceStatusEventScalarFieldEnum | DeviceStatusEventScalarFieldEnum[]
  }

  /**
   * DeviceStatusEvent create
   */
  export type DeviceStatusEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStatusEvent
     */
    select?: DeviceStatusEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceStatusEventInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceStatusEvent.
     */
    data: XOR<DeviceStatusEventCreateInput, DeviceStatusEventUncheckedCreateInput>
  }

  /**
   * DeviceStatusEvent createMany
   */
  export type DeviceStatusEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceStatusEvents.
     */
    data: DeviceStatusEventCreateManyInput | DeviceStatusEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceStatusEvent createManyAndReturn
   */
  export type DeviceStatusEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStatusEvent
     */
    select?: DeviceStatusEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DeviceStatusEvents.
     */
    data: DeviceStatusEventCreateManyInput | DeviceStatusEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceStatusEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceStatusEvent update
   */
  export type DeviceStatusEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStatusEvent
     */
    select?: DeviceStatusEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceStatusEventInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceStatusEvent.
     */
    data: XOR<DeviceStatusEventUpdateInput, DeviceStatusEventUncheckedUpdateInput>
    /**
     * Choose, which DeviceStatusEvent to update.
     */
    where: DeviceStatusEventWhereUniqueInput
  }

  /**
   * DeviceStatusEvent updateMany
   */
  export type DeviceStatusEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceStatusEvents.
     */
    data: XOR<DeviceStatusEventUpdateManyMutationInput, DeviceStatusEventUncheckedUpdateManyInput>
    /**
     * Filter which DeviceStatusEvents to update
     */
    where?: DeviceStatusEventWhereInput
  }

  /**
   * DeviceStatusEvent upsert
   */
  export type DeviceStatusEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStatusEvent
     */
    select?: DeviceStatusEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceStatusEventInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceStatusEvent to update in case it exists.
     */
    where: DeviceStatusEventWhereUniqueInput
    /**
     * In case the DeviceStatusEvent found by the `where` argument doesn't exist, create a new DeviceStatusEvent with this data.
     */
    create: XOR<DeviceStatusEventCreateInput, DeviceStatusEventUncheckedCreateInput>
    /**
     * In case the DeviceStatusEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceStatusEventUpdateInput, DeviceStatusEventUncheckedUpdateInput>
  }

  /**
   * DeviceStatusEvent delete
   */
  export type DeviceStatusEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStatusEvent
     */
    select?: DeviceStatusEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceStatusEventInclude<ExtArgs> | null
    /**
     * Filter which DeviceStatusEvent to delete.
     */
    where: DeviceStatusEventWhereUniqueInput
  }

  /**
   * DeviceStatusEvent deleteMany
   */
  export type DeviceStatusEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceStatusEvents to delete
     */
    where?: DeviceStatusEventWhereInput
  }

  /**
   * DeviceStatusEvent without action
   */
  export type DeviceStatusEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStatusEvent
     */
    select?: DeviceStatusEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceStatusEventInclude<ExtArgs> | null
  }


  /**
   * Model LockEvent
   */

  export type AggregateLockEvent = {
    _count: LockEventCountAggregateOutputType | null
    _avg: LockEventAvgAggregateOutputType | null
    _sum: LockEventSumAggregateOutputType | null
    _min: LockEventMinAggregateOutputType | null
    _max: LockEventMaxAggregateOutputType | null
  }

  export type LockEventAvgAggregateOutputType = {
    isLock: number | null
  }

  export type LockEventSumAggregateOutputType = {
    isLock: number | null
  }

  export type LockEventMinAggregateOutputType = {
    id: string | null
    deviceId: string | null
    truckId: string | null
    isLock: number | null
    reportedAt: Date | null
    createdBy: string | null
  }

  export type LockEventMaxAggregateOutputType = {
    id: string | null
    deviceId: string | null
    truckId: string | null
    isLock: number | null
    reportedAt: Date | null
    createdBy: string | null
  }

  export type LockEventCountAggregateOutputType = {
    id: number
    deviceId: number
    truckId: number
    isLock: number
    reportedAt: number
    createdBy: number
    _all: number
  }


  export type LockEventAvgAggregateInputType = {
    isLock?: true
  }

  export type LockEventSumAggregateInputType = {
    isLock?: true
  }

  export type LockEventMinAggregateInputType = {
    id?: true
    deviceId?: true
    truckId?: true
    isLock?: true
    reportedAt?: true
    createdBy?: true
  }

  export type LockEventMaxAggregateInputType = {
    id?: true
    deviceId?: true
    truckId?: true
    isLock?: true
    reportedAt?: true
    createdBy?: true
  }

  export type LockEventCountAggregateInputType = {
    id?: true
    deviceId?: true
    truckId?: true
    isLock?: true
    reportedAt?: true
    createdBy?: true
    _all?: true
  }

  export type LockEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LockEvent to aggregate.
     */
    where?: LockEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LockEvents to fetch.
     */
    orderBy?: LockEventOrderByWithRelationInput | LockEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LockEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LockEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LockEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LockEvents
    **/
    _count?: true | LockEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LockEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LockEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LockEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LockEventMaxAggregateInputType
  }

  export type GetLockEventAggregateType<T extends LockEventAggregateArgs> = {
        [P in keyof T & keyof AggregateLockEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLockEvent[P]>
      : GetScalarType<T[P], AggregateLockEvent[P]>
  }




  export type LockEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LockEventWhereInput
    orderBy?: LockEventOrderByWithAggregationInput | LockEventOrderByWithAggregationInput[]
    by: LockEventScalarFieldEnum[] | LockEventScalarFieldEnum
    having?: LockEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LockEventCountAggregateInputType | true
    _avg?: LockEventAvgAggregateInputType
    _sum?: LockEventSumAggregateInputType
    _min?: LockEventMinAggregateInputType
    _max?: LockEventMaxAggregateInputType
  }

  export type LockEventGroupByOutputType = {
    id: string
    deviceId: string
    truckId: string
    isLock: number | null
    reportedAt: Date
    createdBy: string | null
    _count: LockEventCountAggregateOutputType | null
    _avg: LockEventAvgAggregateOutputType | null
    _sum: LockEventSumAggregateOutputType | null
    _min: LockEventMinAggregateOutputType | null
    _max: LockEventMaxAggregateOutputType | null
  }

  type GetLockEventGroupByPayload<T extends LockEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LockEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LockEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LockEventGroupByOutputType[P]>
            : GetScalarType<T[P], LockEventGroupByOutputType[P]>
        }
      >
    >


  export type LockEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    truckId?: boolean
    isLock?: boolean
    reportedAt?: boolean
    createdBy?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lockEvent"]>

  export type LockEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    truckId?: boolean
    isLock?: boolean
    reportedAt?: boolean
    createdBy?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lockEvent"]>

  export type LockEventSelectScalar = {
    id?: boolean
    deviceId?: boolean
    truckId?: boolean
    isLock?: boolean
    reportedAt?: boolean
    createdBy?: boolean
  }

  export type LockEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }
  export type LockEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }

  export type $LockEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LockEvent"
    objects: {
      device: Prisma.$DevicePayload<ExtArgs>
      truck: Prisma.$TruckPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deviceId: string
      truckId: string
      isLock: number | null
      reportedAt: Date
      createdBy: string | null
    }, ExtArgs["result"]["lockEvent"]>
    composites: {}
  }

  type LockEventGetPayload<S extends boolean | null | undefined | LockEventDefaultArgs> = $Result.GetResult<Prisma.$LockEventPayload, S>

  type LockEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LockEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LockEventCountAggregateInputType | true
    }

  export interface LockEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LockEvent'], meta: { name: 'LockEvent' } }
    /**
     * Find zero or one LockEvent that matches the filter.
     * @param {LockEventFindUniqueArgs} args - Arguments to find a LockEvent
     * @example
     * // Get one LockEvent
     * const lockEvent = await prisma.lockEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LockEventFindUniqueArgs>(args: SelectSubset<T, LockEventFindUniqueArgs<ExtArgs>>): Prisma__LockEventClient<$Result.GetResult<Prisma.$LockEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LockEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LockEventFindUniqueOrThrowArgs} args - Arguments to find a LockEvent
     * @example
     * // Get one LockEvent
     * const lockEvent = await prisma.lockEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LockEventFindUniqueOrThrowArgs>(args: SelectSubset<T, LockEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LockEventClient<$Result.GetResult<Prisma.$LockEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LockEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LockEventFindFirstArgs} args - Arguments to find a LockEvent
     * @example
     * // Get one LockEvent
     * const lockEvent = await prisma.lockEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LockEventFindFirstArgs>(args?: SelectSubset<T, LockEventFindFirstArgs<ExtArgs>>): Prisma__LockEventClient<$Result.GetResult<Prisma.$LockEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LockEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LockEventFindFirstOrThrowArgs} args - Arguments to find a LockEvent
     * @example
     * // Get one LockEvent
     * const lockEvent = await prisma.lockEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LockEventFindFirstOrThrowArgs>(args?: SelectSubset<T, LockEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__LockEventClient<$Result.GetResult<Prisma.$LockEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LockEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LockEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LockEvents
     * const lockEvents = await prisma.lockEvent.findMany()
     * 
     * // Get first 10 LockEvents
     * const lockEvents = await prisma.lockEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lockEventWithIdOnly = await prisma.lockEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LockEventFindManyArgs>(args?: SelectSubset<T, LockEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LockEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LockEvent.
     * @param {LockEventCreateArgs} args - Arguments to create a LockEvent.
     * @example
     * // Create one LockEvent
     * const LockEvent = await prisma.lockEvent.create({
     *   data: {
     *     // ... data to create a LockEvent
     *   }
     * })
     * 
     */
    create<T extends LockEventCreateArgs>(args: SelectSubset<T, LockEventCreateArgs<ExtArgs>>): Prisma__LockEventClient<$Result.GetResult<Prisma.$LockEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LockEvents.
     * @param {LockEventCreateManyArgs} args - Arguments to create many LockEvents.
     * @example
     * // Create many LockEvents
     * const lockEvent = await prisma.lockEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LockEventCreateManyArgs>(args?: SelectSubset<T, LockEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LockEvents and returns the data saved in the database.
     * @param {LockEventCreateManyAndReturnArgs} args - Arguments to create many LockEvents.
     * @example
     * // Create many LockEvents
     * const lockEvent = await prisma.lockEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LockEvents and only return the `id`
     * const lockEventWithIdOnly = await prisma.lockEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LockEventCreateManyAndReturnArgs>(args?: SelectSubset<T, LockEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LockEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LockEvent.
     * @param {LockEventDeleteArgs} args - Arguments to delete one LockEvent.
     * @example
     * // Delete one LockEvent
     * const LockEvent = await prisma.lockEvent.delete({
     *   where: {
     *     // ... filter to delete one LockEvent
     *   }
     * })
     * 
     */
    delete<T extends LockEventDeleteArgs>(args: SelectSubset<T, LockEventDeleteArgs<ExtArgs>>): Prisma__LockEventClient<$Result.GetResult<Prisma.$LockEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LockEvent.
     * @param {LockEventUpdateArgs} args - Arguments to update one LockEvent.
     * @example
     * // Update one LockEvent
     * const lockEvent = await prisma.lockEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LockEventUpdateArgs>(args: SelectSubset<T, LockEventUpdateArgs<ExtArgs>>): Prisma__LockEventClient<$Result.GetResult<Prisma.$LockEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LockEvents.
     * @param {LockEventDeleteManyArgs} args - Arguments to filter LockEvents to delete.
     * @example
     * // Delete a few LockEvents
     * const { count } = await prisma.lockEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LockEventDeleteManyArgs>(args?: SelectSubset<T, LockEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LockEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LockEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LockEvents
     * const lockEvent = await prisma.lockEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LockEventUpdateManyArgs>(args: SelectSubset<T, LockEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LockEvent.
     * @param {LockEventUpsertArgs} args - Arguments to update or create a LockEvent.
     * @example
     * // Update or create a LockEvent
     * const lockEvent = await prisma.lockEvent.upsert({
     *   create: {
     *     // ... data to create a LockEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LockEvent we want to update
     *   }
     * })
     */
    upsert<T extends LockEventUpsertArgs>(args: SelectSubset<T, LockEventUpsertArgs<ExtArgs>>): Prisma__LockEventClient<$Result.GetResult<Prisma.$LockEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LockEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LockEventCountArgs} args - Arguments to filter LockEvents to count.
     * @example
     * // Count the number of LockEvents
     * const count = await prisma.lockEvent.count({
     *   where: {
     *     // ... the filter for the LockEvents we want to count
     *   }
     * })
    **/
    count<T extends LockEventCountArgs>(
      args?: Subset<T, LockEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LockEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LockEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LockEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LockEventAggregateArgs>(args: Subset<T, LockEventAggregateArgs>): Prisma.PrismaPromise<GetLockEventAggregateType<T>>

    /**
     * Group by LockEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LockEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LockEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LockEventGroupByArgs['orderBy'] }
        : { orderBy?: LockEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LockEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLockEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LockEvent model
   */
  readonly fields: LockEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LockEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LockEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends DeviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceDefaultArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    truck<T extends TruckDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TruckDefaultArgs<ExtArgs>>): Prisma__TruckClient<$Result.GetResult<Prisma.$TruckPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LockEvent model
   */ 
  interface LockEventFieldRefs {
    readonly id: FieldRef<"LockEvent", 'String'>
    readonly deviceId: FieldRef<"LockEvent", 'String'>
    readonly truckId: FieldRef<"LockEvent", 'String'>
    readonly isLock: FieldRef<"LockEvent", 'Int'>
    readonly reportedAt: FieldRef<"LockEvent", 'DateTime'>
    readonly createdBy: FieldRef<"LockEvent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LockEvent findUnique
   */
  export type LockEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockEvent
     */
    select?: LockEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockEventInclude<ExtArgs> | null
    /**
     * Filter, which LockEvent to fetch.
     */
    where: LockEventWhereUniqueInput
  }

  /**
   * LockEvent findUniqueOrThrow
   */
  export type LockEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockEvent
     */
    select?: LockEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockEventInclude<ExtArgs> | null
    /**
     * Filter, which LockEvent to fetch.
     */
    where: LockEventWhereUniqueInput
  }

  /**
   * LockEvent findFirst
   */
  export type LockEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockEvent
     */
    select?: LockEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockEventInclude<ExtArgs> | null
    /**
     * Filter, which LockEvent to fetch.
     */
    where?: LockEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LockEvents to fetch.
     */
    orderBy?: LockEventOrderByWithRelationInput | LockEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LockEvents.
     */
    cursor?: LockEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LockEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LockEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LockEvents.
     */
    distinct?: LockEventScalarFieldEnum | LockEventScalarFieldEnum[]
  }

  /**
   * LockEvent findFirstOrThrow
   */
  export type LockEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockEvent
     */
    select?: LockEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockEventInclude<ExtArgs> | null
    /**
     * Filter, which LockEvent to fetch.
     */
    where?: LockEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LockEvents to fetch.
     */
    orderBy?: LockEventOrderByWithRelationInput | LockEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LockEvents.
     */
    cursor?: LockEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LockEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LockEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LockEvents.
     */
    distinct?: LockEventScalarFieldEnum | LockEventScalarFieldEnum[]
  }

  /**
   * LockEvent findMany
   */
  export type LockEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockEvent
     */
    select?: LockEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockEventInclude<ExtArgs> | null
    /**
     * Filter, which LockEvents to fetch.
     */
    where?: LockEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LockEvents to fetch.
     */
    orderBy?: LockEventOrderByWithRelationInput | LockEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LockEvents.
     */
    cursor?: LockEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LockEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LockEvents.
     */
    skip?: number
    distinct?: LockEventScalarFieldEnum | LockEventScalarFieldEnum[]
  }

  /**
   * LockEvent create
   */
  export type LockEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockEvent
     */
    select?: LockEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockEventInclude<ExtArgs> | null
    /**
     * The data needed to create a LockEvent.
     */
    data: XOR<LockEventCreateInput, LockEventUncheckedCreateInput>
  }

  /**
   * LockEvent createMany
   */
  export type LockEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LockEvents.
     */
    data: LockEventCreateManyInput | LockEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LockEvent createManyAndReturn
   */
  export type LockEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockEvent
     */
    select?: LockEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LockEvents.
     */
    data: LockEventCreateManyInput | LockEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LockEvent update
   */
  export type LockEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockEvent
     */
    select?: LockEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockEventInclude<ExtArgs> | null
    /**
     * The data needed to update a LockEvent.
     */
    data: XOR<LockEventUpdateInput, LockEventUncheckedUpdateInput>
    /**
     * Choose, which LockEvent to update.
     */
    where: LockEventWhereUniqueInput
  }

  /**
   * LockEvent updateMany
   */
  export type LockEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LockEvents.
     */
    data: XOR<LockEventUpdateManyMutationInput, LockEventUncheckedUpdateManyInput>
    /**
     * Filter which LockEvents to update
     */
    where?: LockEventWhereInput
  }

  /**
   * LockEvent upsert
   */
  export type LockEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockEvent
     */
    select?: LockEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockEventInclude<ExtArgs> | null
    /**
     * The filter to search for the LockEvent to update in case it exists.
     */
    where: LockEventWhereUniqueInput
    /**
     * In case the LockEvent found by the `where` argument doesn't exist, create a new LockEvent with this data.
     */
    create: XOR<LockEventCreateInput, LockEventUncheckedCreateInput>
    /**
     * In case the LockEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LockEventUpdateInput, LockEventUncheckedUpdateInput>
  }

  /**
   * LockEvent delete
   */
  export type LockEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockEvent
     */
    select?: LockEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockEventInclude<ExtArgs> | null
    /**
     * Filter which LockEvent to delete.
     */
    where: LockEventWhereUniqueInput
  }

  /**
   * LockEvent deleteMany
   */
  export type LockEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LockEvents to delete
     */
    where?: LockEventWhereInput
  }

  /**
   * LockEvent without action
   */
  export type LockEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LockEvent
     */
    select?: LockEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LockEventInclude<ExtArgs> | null
  }


  /**
   * Model DailyRoute
   */

  export type AggregateDailyRoute = {
    _count: DailyRouteCountAggregateOutputType | null
    _avg: DailyRouteAvgAggregateOutputType | null
    _sum: DailyRouteSumAggregateOutputType | null
    _min: DailyRouteMinAggregateOutputType | null
    _max: DailyRouteMaxAggregateOutputType | null
  }

  export type DailyRouteAvgAggregateOutputType = {
    pointCount: number | null
  }

  export type DailyRouteSumAggregateOutputType = {
    pointCount: number | null
  }

  export type DailyRouteMinAggregateOutputType = {
    id: string | null
    truckId: string | null
    routeDate: Date | null
    pointCount: number | null
    generatedAt: Date | null
    createdBy: string | null
  }

  export type DailyRouteMaxAggregateOutputType = {
    id: string | null
    truckId: string | null
    routeDate: Date | null
    pointCount: number | null
    generatedAt: Date | null
    createdBy: string | null
  }

  export type DailyRouteCountAggregateOutputType = {
    id: number
    truckId: number
    routeDate: number
    pointCount: number
    generatedAt: number
    createdBy: number
    _all: number
  }


  export type DailyRouteAvgAggregateInputType = {
    pointCount?: true
  }

  export type DailyRouteSumAggregateInputType = {
    pointCount?: true
  }

  export type DailyRouteMinAggregateInputType = {
    id?: true
    truckId?: true
    routeDate?: true
    pointCount?: true
    generatedAt?: true
    createdBy?: true
  }

  export type DailyRouteMaxAggregateInputType = {
    id?: true
    truckId?: true
    routeDate?: true
    pointCount?: true
    generatedAt?: true
    createdBy?: true
  }

  export type DailyRouteCountAggregateInputType = {
    id?: true
    truckId?: true
    routeDate?: true
    pointCount?: true
    generatedAt?: true
    createdBy?: true
    _all?: true
  }

  export type DailyRouteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyRoute to aggregate.
     */
    where?: DailyRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRoutes to fetch.
     */
    orderBy?: DailyRouteOrderByWithRelationInput | DailyRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyRoutes
    **/
    _count?: true | DailyRouteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyRouteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyRouteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyRouteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyRouteMaxAggregateInputType
  }

  export type GetDailyRouteAggregateType<T extends DailyRouteAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyRoute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyRoute[P]>
      : GetScalarType<T[P], AggregateDailyRoute[P]>
  }




  export type DailyRouteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyRouteWhereInput
    orderBy?: DailyRouteOrderByWithAggregationInput | DailyRouteOrderByWithAggregationInput[]
    by: DailyRouteScalarFieldEnum[] | DailyRouteScalarFieldEnum
    having?: DailyRouteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyRouteCountAggregateInputType | true
    _avg?: DailyRouteAvgAggregateInputType
    _sum?: DailyRouteSumAggregateInputType
    _min?: DailyRouteMinAggregateInputType
    _max?: DailyRouteMaxAggregateInputType
  }

  export type DailyRouteGroupByOutputType = {
    id: string
    truckId: string
    routeDate: Date
    pointCount: number
    generatedAt: Date
    createdBy: string | null
    _count: DailyRouteCountAggregateOutputType | null
    _avg: DailyRouteAvgAggregateOutputType | null
    _sum: DailyRouteSumAggregateOutputType | null
    _min: DailyRouteMinAggregateOutputType | null
    _max: DailyRouteMaxAggregateOutputType | null
  }

  type GetDailyRouteGroupByPayload<T extends DailyRouteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyRouteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyRouteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyRouteGroupByOutputType[P]>
            : GetScalarType<T[P], DailyRouteGroupByOutputType[P]>
        }
      >
    >


  export type DailyRouteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    truckId?: boolean
    routeDate?: boolean
    pointCount?: boolean
    generatedAt?: boolean
    createdBy?: boolean
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyRoute"]>

  export type DailyRouteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    truckId?: boolean
    routeDate?: boolean
    pointCount?: boolean
    generatedAt?: boolean
    createdBy?: boolean
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyRoute"]>

  export type DailyRouteSelectScalar = {
    id?: boolean
    truckId?: boolean
    routeDate?: boolean
    pointCount?: boolean
    generatedAt?: boolean
    createdBy?: boolean
  }

  export type DailyRouteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }
  export type DailyRouteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    truck?: boolean | TruckDefaultArgs<ExtArgs>
  }

  export type $DailyRoutePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyRoute"
    objects: {
      truck: Prisma.$TruckPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      truckId: string
      routeDate: Date
      pointCount: number
      generatedAt: Date
      createdBy: string | null
    }, ExtArgs["result"]["dailyRoute"]>
    composites: {}
  }

  type DailyRouteGetPayload<S extends boolean | null | undefined | DailyRouteDefaultArgs> = $Result.GetResult<Prisma.$DailyRoutePayload, S>

  type DailyRouteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DailyRouteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DailyRouteCountAggregateInputType | true
    }

  export interface DailyRouteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyRoute'], meta: { name: 'DailyRoute' } }
    /**
     * Find zero or one DailyRoute that matches the filter.
     * @param {DailyRouteFindUniqueArgs} args - Arguments to find a DailyRoute
     * @example
     * // Get one DailyRoute
     * const dailyRoute = await prisma.dailyRoute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyRouteFindUniqueArgs>(args: SelectSubset<T, DailyRouteFindUniqueArgs<ExtArgs>>): Prisma__DailyRouteClient<$Result.GetResult<Prisma.$DailyRoutePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DailyRoute that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DailyRouteFindUniqueOrThrowArgs} args - Arguments to find a DailyRoute
     * @example
     * // Get one DailyRoute
     * const dailyRoute = await prisma.dailyRoute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyRouteFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyRouteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyRouteClient<$Result.GetResult<Prisma.$DailyRoutePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DailyRoute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRouteFindFirstArgs} args - Arguments to find a DailyRoute
     * @example
     * // Get one DailyRoute
     * const dailyRoute = await prisma.dailyRoute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyRouteFindFirstArgs>(args?: SelectSubset<T, DailyRouteFindFirstArgs<ExtArgs>>): Prisma__DailyRouteClient<$Result.GetResult<Prisma.$DailyRoutePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DailyRoute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRouteFindFirstOrThrowArgs} args - Arguments to find a DailyRoute
     * @example
     * // Get one DailyRoute
     * const dailyRoute = await prisma.dailyRoute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyRouteFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyRouteFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyRouteClient<$Result.GetResult<Prisma.$DailyRoutePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DailyRoutes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRouteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyRoutes
     * const dailyRoutes = await prisma.dailyRoute.findMany()
     * 
     * // Get first 10 DailyRoutes
     * const dailyRoutes = await prisma.dailyRoute.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyRouteWithIdOnly = await prisma.dailyRoute.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyRouteFindManyArgs>(args?: SelectSubset<T, DailyRouteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyRoutePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DailyRoute.
     * @param {DailyRouteCreateArgs} args - Arguments to create a DailyRoute.
     * @example
     * // Create one DailyRoute
     * const DailyRoute = await prisma.dailyRoute.create({
     *   data: {
     *     // ... data to create a DailyRoute
     *   }
     * })
     * 
     */
    create<T extends DailyRouteCreateArgs>(args: SelectSubset<T, DailyRouteCreateArgs<ExtArgs>>): Prisma__DailyRouteClient<$Result.GetResult<Prisma.$DailyRoutePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DailyRoutes.
     * @param {DailyRouteCreateManyArgs} args - Arguments to create many DailyRoutes.
     * @example
     * // Create many DailyRoutes
     * const dailyRoute = await prisma.dailyRoute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyRouteCreateManyArgs>(args?: SelectSubset<T, DailyRouteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyRoutes and returns the data saved in the database.
     * @param {DailyRouteCreateManyAndReturnArgs} args - Arguments to create many DailyRoutes.
     * @example
     * // Create many DailyRoutes
     * const dailyRoute = await prisma.dailyRoute.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyRoutes and only return the `id`
     * const dailyRouteWithIdOnly = await prisma.dailyRoute.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyRouteCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyRouteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyRoutePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DailyRoute.
     * @param {DailyRouteDeleteArgs} args - Arguments to delete one DailyRoute.
     * @example
     * // Delete one DailyRoute
     * const DailyRoute = await prisma.dailyRoute.delete({
     *   where: {
     *     // ... filter to delete one DailyRoute
     *   }
     * })
     * 
     */
    delete<T extends DailyRouteDeleteArgs>(args: SelectSubset<T, DailyRouteDeleteArgs<ExtArgs>>): Prisma__DailyRouteClient<$Result.GetResult<Prisma.$DailyRoutePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DailyRoute.
     * @param {DailyRouteUpdateArgs} args - Arguments to update one DailyRoute.
     * @example
     * // Update one DailyRoute
     * const dailyRoute = await prisma.dailyRoute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyRouteUpdateArgs>(args: SelectSubset<T, DailyRouteUpdateArgs<ExtArgs>>): Prisma__DailyRouteClient<$Result.GetResult<Prisma.$DailyRoutePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DailyRoutes.
     * @param {DailyRouteDeleteManyArgs} args - Arguments to filter DailyRoutes to delete.
     * @example
     * // Delete a few DailyRoutes
     * const { count } = await prisma.dailyRoute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyRouteDeleteManyArgs>(args?: SelectSubset<T, DailyRouteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyRoutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRouteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyRoutes
     * const dailyRoute = await prisma.dailyRoute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyRouteUpdateManyArgs>(args: SelectSubset<T, DailyRouteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DailyRoute.
     * @param {DailyRouteUpsertArgs} args - Arguments to update or create a DailyRoute.
     * @example
     * // Update or create a DailyRoute
     * const dailyRoute = await prisma.dailyRoute.upsert({
     *   create: {
     *     // ... data to create a DailyRoute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyRoute we want to update
     *   }
     * })
     */
    upsert<T extends DailyRouteUpsertArgs>(args: SelectSubset<T, DailyRouteUpsertArgs<ExtArgs>>): Prisma__DailyRouteClient<$Result.GetResult<Prisma.$DailyRoutePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DailyRoutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRouteCountArgs} args - Arguments to filter DailyRoutes to count.
     * @example
     * // Count the number of DailyRoutes
     * const count = await prisma.dailyRoute.count({
     *   where: {
     *     // ... the filter for the DailyRoutes we want to count
     *   }
     * })
    **/
    count<T extends DailyRouteCountArgs>(
      args?: Subset<T, DailyRouteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyRouteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyRoute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRouteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyRouteAggregateArgs>(args: Subset<T, DailyRouteAggregateArgs>): Prisma.PrismaPromise<GetDailyRouteAggregateType<T>>

    /**
     * Group by DailyRoute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRouteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyRouteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyRouteGroupByArgs['orderBy'] }
        : { orderBy?: DailyRouteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyRouteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyRouteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyRoute model
   */
  readonly fields: DailyRouteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyRoute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyRouteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    truck<T extends TruckDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TruckDefaultArgs<ExtArgs>>): Prisma__TruckClient<$Result.GetResult<Prisma.$TruckPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyRoute model
   */ 
  interface DailyRouteFieldRefs {
    readonly id: FieldRef<"DailyRoute", 'String'>
    readonly truckId: FieldRef<"DailyRoute", 'String'>
    readonly routeDate: FieldRef<"DailyRoute", 'DateTime'>
    readonly pointCount: FieldRef<"DailyRoute", 'Int'>
    readonly generatedAt: FieldRef<"DailyRoute", 'DateTime'>
    readonly createdBy: FieldRef<"DailyRoute", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DailyRoute findUnique
   */
  export type DailyRouteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRoute
     */
    select?: DailyRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRouteInclude<ExtArgs> | null
    /**
     * Filter, which DailyRoute to fetch.
     */
    where: DailyRouteWhereUniqueInput
  }

  /**
   * DailyRoute findUniqueOrThrow
   */
  export type DailyRouteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRoute
     */
    select?: DailyRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRouteInclude<ExtArgs> | null
    /**
     * Filter, which DailyRoute to fetch.
     */
    where: DailyRouteWhereUniqueInput
  }

  /**
   * DailyRoute findFirst
   */
  export type DailyRouteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRoute
     */
    select?: DailyRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRouteInclude<ExtArgs> | null
    /**
     * Filter, which DailyRoute to fetch.
     */
    where?: DailyRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRoutes to fetch.
     */
    orderBy?: DailyRouteOrderByWithRelationInput | DailyRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyRoutes.
     */
    cursor?: DailyRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyRoutes.
     */
    distinct?: DailyRouteScalarFieldEnum | DailyRouteScalarFieldEnum[]
  }

  /**
   * DailyRoute findFirstOrThrow
   */
  export type DailyRouteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRoute
     */
    select?: DailyRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRouteInclude<ExtArgs> | null
    /**
     * Filter, which DailyRoute to fetch.
     */
    where?: DailyRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRoutes to fetch.
     */
    orderBy?: DailyRouteOrderByWithRelationInput | DailyRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyRoutes.
     */
    cursor?: DailyRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyRoutes.
     */
    distinct?: DailyRouteScalarFieldEnum | DailyRouteScalarFieldEnum[]
  }

  /**
   * DailyRoute findMany
   */
  export type DailyRouteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRoute
     */
    select?: DailyRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRouteInclude<ExtArgs> | null
    /**
     * Filter, which DailyRoutes to fetch.
     */
    where?: DailyRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRoutes to fetch.
     */
    orderBy?: DailyRouteOrderByWithRelationInput | DailyRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyRoutes.
     */
    cursor?: DailyRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRoutes.
     */
    skip?: number
    distinct?: DailyRouteScalarFieldEnum | DailyRouteScalarFieldEnum[]
  }

  /**
   * DailyRoute create
   */
  export type DailyRouteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRoute
     */
    select?: DailyRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRouteInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyRoute.
     */
    data: XOR<DailyRouteCreateInput, DailyRouteUncheckedCreateInput>
  }

  /**
   * DailyRoute createMany
   */
  export type DailyRouteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyRoutes.
     */
    data: DailyRouteCreateManyInput | DailyRouteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyRoute createManyAndReturn
   */
  export type DailyRouteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRoute
     */
    select?: DailyRouteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DailyRoutes.
     */
    data: DailyRouteCreateManyInput | DailyRouteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRouteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyRoute update
   */
  export type DailyRouteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRoute
     */
    select?: DailyRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRouteInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyRoute.
     */
    data: XOR<DailyRouteUpdateInput, DailyRouteUncheckedUpdateInput>
    /**
     * Choose, which DailyRoute to update.
     */
    where: DailyRouteWhereUniqueInput
  }

  /**
   * DailyRoute updateMany
   */
  export type DailyRouteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyRoutes.
     */
    data: XOR<DailyRouteUpdateManyMutationInput, DailyRouteUncheckedUpdateManyInput>
    /**
     * Filter which DailyRoutes to update
     */
    where?: DailyRouteWhereInput
  }

  /**
   * DailyRoute upsert
   */
  export type DailyRouteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRoute
     */
    select?: DailyRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRouteInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyRoute to update in case it exists.
     */
    where: DailyRouteWhereUniqueInput
    /**
     * In case the DailyRoute found by the `where` argument doesn't exist, create a new DailyRoute with this data.
     */
    create: XOR<DailyRouteCreateInput, DailyRouteUncheckedCreateInput>
    /**
     * In case the DailyRoute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyRouteUpdateInput, DailyRouteUncheckedUpdateInput>
  }

  /**
   * DailyRoute delete
   */
  export type DailyRouteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRoute
     */
    select?: DailyRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRouteInclude<ExtArgs> | null
    /**
     * Filter which DailyRoute to delete.
     */
    where: DailyRouteWhereUniqueInput
  }

  /**
   * DailyRoute deleteMany
   */
  export type DailyRouteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyRoutes to delete
     */
    where?: DailyRouteWhereInput
  }

  /**
   * DailyRoute without action
   */
  export type DailyRouteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRoute
     */
    select?: DailyRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRouteInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const FleetGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    site: 'site',
    description: 'description',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type FleetGroupScalarFieldEnum = (typeof FleetGroupScalarFieldEnum)[keyof typeof FleetGroupScalarFieldEnum]


  export const TruckScalarFieldEnum: {
    id: 'id',
    plateNumber: 'plateNumber',
    vin: 'vin',
    name: 'name',
    model: 'model',
    year: 'year',
    tireConfig: 'tireConfig',
    fleetGroupId: 'fleetGroupId',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type TruckScalarFieldEnum = (typeof TruckScalarFieldEnum)[keyof typeof TruckScalarFieldEnum]


  export const DeviceScalarFieldEnum: {
    id: 'id',
    truckId: 'truckId',
    sn: 'sn',
    simNumber: 'simNumber',
    installedAt: 'installedAt',
    removedAt: 'removedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type DeviceScalarFieldEnum = (typeof DeviceScalarFieldEnum)[keyof typeof DeviceScalarFieldEnum]


  export const SensorScalarFieldEnum: {
    id: 'id',
    deviceId: 'deviceId',
    type: 'type',
    positionNo: 'positionNo',
    sn: 'sn',
    installedAt: 'installedAt',
    removedAt: 'removedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type SensorScalarFieldEnum = (typeof SensorScalarFieldEnum)[keyof typeof SensorScalarFieldEnum]


  export const TruckStatusEventScalarFieldEnum: {
    id: 'id',
    truckId: 'truckId',
    status: 'status',
    note: 'note',
    changedAt: 'changedAt',
    createdBy: 'createdBy'
  };

  export type TruckStatusEventScalarFieldEnum = (typeof TruckStatusEventScalarFieldEnum)[keyof typeof TruckStatusEventScalarFieldEnum]


  export const GeofenceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type GeofenceScalarFieldEnum = (typeof GeofenceScalarFieldEnum)[keyof typeof GeofenceScalarFieldEnum]


  export const GpsPositionScalarFieldEnum: {
    id: 'id',
    deviceId: 'deviceId',
    truckId: 'truckId',
    ts: 'ts',
    speedKph: 'speedKph',
    headingDeg: 'headingDeg',
    hdop: 'hdop',
    source: 'source'
  };

  export type GpsPositionScalarFieldEnum = (typeof GpsPositionScalarFieldEnum)[keyof typeof GpsPositionScalarFieldEnum]


  export const TripScalarFieldEnum: {
    id: 'id',
    truckId: 'truckId',
    startTs: 'startTs',
    endTs: 'endTs'
  };

  export type TripScalarFieldEnum = (typeof TripScalarFieldEnum)[keyof typeof TripScalarFieldEnum]


  export const TirePressureEventScalarFieldEnum: {
    id: 'id',
    deviceId: 'deviceId',
    truckId: 'truckId',
    tireNo: 'tireNo',
    pressureKpa: 'pressureKpa',
    tempCelsius: 'tempCelsius',
    exType: 'exType',
    batteryLevel: 'batteryLevel',
    changedAt: 'changedAt',
    createdBy: 'createdBy'
  };

  export type TirePressureEventScalarFieldEnum = (typeof TirePressureEventScalarFieldEnum)[keyof typeof TirePressureEventScalarFieldEnum]


  export const TireErrorCodeScalarFieldEnum: {
    code: 'code',
    description: 'description'
  };

  export type TireErrorCodeScalarFieldEnum = (typeof TireErrorCodeScalarFieldEnum)[keyof typeof TireErrorCodeScalarFieldEnum]


  export const HubTemperatureEventScalarFieldEnum: {
    id: 'id',
    deviceId: 'deviceId',
    truckId: 'truckId',
    hubNo: 'hubNo',
    tempCelsius: 'tempCelsius',
    exType: 'exType',
    batteryLevel: 'batteryLevel',
    changedAt: 'changedAt',
    createdBy: 'createdBy'
  };

  export type HubTemperatureEventScalarFieldEnum = (typeof HubTemperatureEventScalarFieldEnum)[keyof typeof HubTemperatureEventScalarFieldEnum]


  export const FuelLevelEventScalarFieldEnum: {
    id: 'id',
    truckId: 'truckId',
    fuelPercent: 'fuelPercent',
    changedAt: 'changedAt',
    source: 'source',
    createdBy: 'createdBy'
  };

  export type FuelLevelEventScalarFieldEnum = (typeof FuelLevelEventScalarFieldEnum)[keyof typeof FuelLevelEventScalarFieldEnum]


  export const SpeedEventScalarFieldEnum: {
    id: 'id',
    truckId: 'truckId',
    speedKph: 'speedKph',
    changedAt: 'changedAt',
    source: 'source',
    createdBy: 'createdBy'
  };

  export type SpeedEventScalarFieldEnum = (typeof SpeedEventScalarFieldEnum)[keyof typeof SpeedEventScalarFieldEnum]


  export const AlertEventScalarFieldEnum: {
    id: 'id',
    truckId: 'truckId',
    type: 'type',
    severity: 'severity',
    detail: 'detail',
    occurredAt: 'occurredAt',
    acknowledged: 'acknowledged',
    createdBy: 'createdBy'
  };

  export type AlertEventScalarFieldEnum = (typeof AlertEventScalarFieldEnum)[keyof typeof AlertEventScalarFieldEnum]


  export const DeviceStatusEventScalarFieldEnum: {
    id: 'id',
    deviceId: 'deviceId',
    truckId: 'truckId',
    hostBat: 'hostBat',
    repeater1Bat: 'repeater1Bat',
    repeater2Bat: 'repeater2Bat',
    lockState: 'lockState',
    reportedAt: 'reportedAt',
    createdBy: 'createdBy'
  };

  export type DeviceStatusEventScalarFieldEnum = (typeof DeviceStatusEventScalarFieldEnum)[keyof typeof DeviceStatusEventScalarFieldEnum]


  export const LockEventScalarFieldEnum: {
    id: 'id',
    deviceId: 'deviceId',
    truckId: 'truckId',
    isLock: 'isLock',
    reportedAt: 'reportedAt',
    createdBy: 'createdBy'
  };

  export type LockEventScalarFieldEnum = (typeof LockEventScalarFieldEnum)[keyof typeof LockEventScalarFieldEnum]


  export const DailyRouteScalarFieldEnum: {
    id: 'id',
    truckId: 'truckId',
    routeDate: 'routeDate',
    pointCount: 'pointCount',
    generatedAt: 'generatedAt',
    createdBy: 'createdBy'
  };

  export type DailyRouteScalarFieldEnum = (typeof DailyRouteScalarFieldEnum)[keyof typeof DailyRouteScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'TruckStatus'
   */
  export type EnumTruckStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TruckStatus'>
    


  /**
   * Reference to a field of type 'TruckStatus[]'
   */
  export type ListEnumTruckStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TruckStatus[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'AlertType'
   */
  export type EnumAlertTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertType'>
    


  /**
   * Reference to a field of type 'AlertType[]'
   */
  export type ListEnumAlertTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type FleetGroupWhereInput = {
    AND?: FleetGroupWhereInput | FleetGroupWhereInput[]
    OR?: FleetGroupWhereInput[]
    NOT?: FleetGroupWhereInput | FleetGroupWhereInput[]
    id?: UuidFilter<"FleetGroup"> | string
    name?: StringFilter<"FleetGroup"> | string
    site?: StringNullableFilter<"FleetGroup"> | string | null
    description?: StringNullableFilter<"FleetGroup"> | string | null
    createdAt?: DateTimeFilter<"FleetGroup"> | Date | string
    createdBy?: UuidNullableFilter<"FleetGroup"> | string | null
    updatedBy?: UuidNullableFilter<"FleetGroup"> | string | null
    trucks?: TruckListRelationFilter
  }

  export type FleetGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    site?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    trucks?: TruckOrderByRelationAggregateInput
  }

  export type FleetGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FleetGroupWhereInput | FleetGroupWhereInput[]
    OR?: FleetGroupWhereInput[]
    NOT?: FleetGroupWhereInput | FleetGroupWhereInput[]
    name?: StringFilter<"FleetGroup"> | string
    site?: StringNullableFilter<"FleetGroup"> | string | null
    description?: StringNullableFilter<"FleetGroup"> | string | null
    createdAt?: DateTimeFilter<"FleetGroup"> | Date | string
    createdBy?: UuidNullableFilter<"FleetGroup"> | string | null
    updatedBy?: UuidNullableFilter<"FleetGroup"> | string | null
    trucks?: TruckListRelationFilter
  }, "id">

  export type FleetGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    site?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: FleetGroupCountOrderByAggregateInput
    _max?: FleetGroupMaxOrderByAggregateInput
    _min?: FleetGroupMinOrderByAggregateInput
  }

  export type FleetGroupScalarWhereWithAggregatesInput = {
    AND?: FleetGroupScalarWhereWithAggregatesInput | FleetGroupScalarWhereWithAggregatesInput[]
    OR?: FleetGroupScalarWhereWithAggregatesInput[]
    NOT?: FleetGroupScalarWhereWithAggregatesInput | FleetGroupScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"FleetGroup"> | string
    name?: StringWithAggregatesFilter<"FleetGroup"> | string
    site?: StringNullableWithAggregatesFilter<"FleetGroup"> | string | null
    description?: StringNullableWithAggregatesFilter<"FleetGroup"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FleetGroup"> | Date | string
    createdBy?: UuidNullableWithAggregatesFilter<"FleetGroup"> | string | null
    updatedBy?: UuidNullableWithAggregatesFilter<"FleetGroup"> | string | null
  }

  export type TruckWhereInput = {
    AND?: TruckWhereInput | TruckWhereInput[]
    OR?: TruckWhereInput[]
    NOT?: TruckWhereInput | TruckWhereInput[]
    id?: UuidFilter<"Truck"> | string
    plateNumber?: StringFilter<"Truck"> | string
    vin?: StringNullableFilter<"Truck"> | string | null
    name?: StringNullableFilter<"Truck"> | string | null
    model?: StringNullableFilter<"Truck"> | string | null
    year?: IntNullableFilter<"Truck"> | number | null
    tireConfig?: StringNullableFilter<"Truck"> | string | null
    fleetGroupId?: UuidNullableFilter<"Truck"> | string | null
    createdAt?: DateTimeFilter<"Truck"> | Date | string
    createdBy?: UuidNullableFilter<"Truck"> | string | null
    updatedBy?: UuidNullableFilter<"Truck"> | string | null
    fleetGroup?: XOR<FleetGroupNullableRelationFilter, FleetGroupWhereInput> | null
    devices?: DeviceListRelationFilter
    truckStatusEvents?: TruckStatusEventListRelationFilter
    gpsPositions?: GpsPositionListRelationFilter
    trips?: TripListRelationFilter
    tirePressureEvents?: TirePressureEventListRelationFilter
    hubTemperatureEvents?: HubTemperatureEventListRelationFilter
    fuelLevelEvents?: FuelLevelEventListRelationFilter
    speedEvents?: SpeedEventListRelationFilter
    alertEvents?: AlertEventListRelationFilter
    deviceStatusEvents?: DeviceStatusEventListRelationFilter
    lockEvents?: LockEventListRelationFilter
    dailyRoutes?: DailyRouteListRelationFilter
  }

  export type TruckOrderByWithRelationInput = {
    id?: SortOrder
    plateNumber?: SortOrder
    vin?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    tireConfig?: SortOrderInput | SortOrder
    fleetGroupId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    fleetGroup?: FleetGroupOrderByWithRelationInput
    devices?: DeviceOrderByRelationAggregateInput
    truckStatusEvents?: TruckStatusEventOrderByRelationAggregateInput
    gpsPositions?: GpsPositionOrderByRelationAggregateInput
    trips?: TripOrderByRelationAggregateInput
    tirePressureEvents?: TirePressureEventOrderByRelationAggregateInput
    hubTemperatureEvents?: HubTemperatureEventOrderByRelationAggregateInput
    fuelLevelEvents?: FuelLevelEventOrderByRelationAggregateInput
    speedEvents?: SpeedEventOrderByRelationAggregateInput
    alertEvents?: AlertEventOrderByRelationAggregateInput
    deviceStatusEvents?: DeviceStatusEventOrderByRelationAggregateInput
    lockEvents?: LockEventOrderByRelationAggregateInput
    dailyRoutes?: DailyRouteOrderByRelationAggregateInput
  }

  export type TruckWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    plateNumber?: string
    vin?: string
    AND?: TruckWhereInput | TruckWhereInput[]
    OR?: TruckWhereInput[]
    NOT?: TruckWhereInput | TruckWhereInput[]
    name?: StringNullableFilter<"Truck"> | string | null
    model?: StringNullableFilter<"Truck"> | string | null
    year?: IntNullableFilter<"Truck"> | number | null
    tireConfig?: StringNullableFilter<"Truck"> | string | null
    fleetGroupId?: UuidNullableFilter<"Truck"> | string | null
    createdAt?: DateTimeFilter<"Truck"> | Date | string
    createdBy?: UuidNullableFilter<"Truck"> | string | null
    updatedBy?: UuidNullableFilter<"Truck"> | string | null
    fleetGroup?: XOR<FleetGroupNullableRelationFilter, FleetGroupWhereInput> | null
    devices?: DeviceListRelationFilter
    truckStatusEvents?: TruckStatusEventListRelationFilter
    gpsPositions?: GpsPositionListRelationFilter
    trips?: TripListRelationFilter
    tirePressureEvents?: TirePressureEventListRelationFilter
    hubTemperatureEvents?: HubTemperatureEventListRelationFilter
    fuelLevelEvents?: FuelLevelEventListRelationFilter
    speedEvents?: SpeedEventListRelationFilter
    alertEvents?: AlertEventListRelationFilter
    deviceStatusEvents?: DeviceStatusEventListRelationFilter
    lockEvents?: LockEventListRelationFilter
    dailyRoutes?: DailyRouteListRelationFilter
  }, "id" | "plateNumber" | "vin">

  export type TruckOrderByWithAggregationInput = {
    id?: SortOrder
    plateNumber?: SortOrder
    vin?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    tireConfig?: SortOrderInput | SortOrder
    fleetGroupId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: TruckCountOrderByAggregateInput
    _avg?: TruckAvgOrderByAggregateInput
    _max?: TruckMaxOrderByAggregateInput
    _min?: TruckMinOrderByAggregateInput
    _sum?: TruckSumOrderByAggregateInput
  }

  export type TruckScalarWhereWithAggregatesInput = {
    AND?: TruckScalarWhereWithAggregatesInput | TruckScalarWhereWithAggregatesInput[]
    OR?: TruckScalarWhereWithAggregatesInput[]
    NOT?: TruckScalarWhereWithAggregatesInput | TruckScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Truck"> | string
    plateNumber?: StringWithAggregatesFilter<"Truck"> | string
    vin?: StringNullableWithAggregatesFilter<"Truck"> | string | null
    name?: StringNullableWithAggregatesFilter<"Truck"> | string | null
    model?: StringNullableWithAggregatesFilter<"Truck"> | string | null
    year?: IntNullableWithAggregatesFilter<"Truck"> | number | null
    tireConfig?: StringNullableWithAggregatesFilter<"Truck"> | string | null
    fleetGroupId?: UuidNullableWithAggregatesFilter<"Truck"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Truck"> | Date | string
    createdBy?: UuidNullableWithAggregatesFilter<"Truck"> | string | null
    updatedBy?: UuidNullableWithAggregatesFilter<"Truck"> | string | null
  }

  export type DeviceWhereInput = {
    AND?: DeviceWhereInput | DeviceWhereInput[]
    OR?: DeviceWhereInput[]
    NOT?: DeviceWhereInput | DeviceWhereInput[]
    id?: UuidFilter<"Device"> | string
    truckId?: UuidFilter<"Device"> | string
    sn?: StringFilter<"Device"> | string
    simNumber?: StringNullableFilter<"Device"> | string | null
    installedAt?: DateTimeFilter<"Device"> | Date | string
    removedAt?: DateTimeNullableFilter<"Device"> | Date | string | null
    createdBy?: UuidNullableFilter<"Device"> | string | null
    updatedBy?: UuidNullableFilter<"Device"> | string | null
    truck?: XOR<TruckRelationFilter, TruckWhereInput>
    sensors?: SensorListRelationFilter
    gpsPositions?: GpsPositionListRelationFilter
    tirePressureEvents?: TirePressureEventListRelationFilter
    hubTemperatureEvents?: HubTemperatureEventListRelationFilter
    deviceStatusEvents?: DeviceStatusEventListRelationFilter
    lockEvents?: LockEventListRelationFilter
  }

  export type DeviceOrderByWithRelationInput = {
    id?: SortOrder
    truckId?: SortOrder
    sn?: SortOrder
    simNumber?: SortOrderInput | SortOrder
    installedAt?: SortOrder
    removedAt?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    truck?: TruckOrderByWithRelationInput
    sensors?: SensorOrderByRelationAggregateInput
    gpsPositions?: GpsPositionOrderByRelationAggregateInput
    tirePressureEvents?: TirePressureEventOrderByRelationAggregateInput
    hubTemperatureEvents?: HubTemperatureEventOrderByRelationAggregateInput
    deviceStatusEvents?: DeviceStatusEventOrderByRelationAggregateInput
    lockEvents?: LockEventOrderByRelationAggregateInput
  }

  export type DeviceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sn?: string
    AND?: DeviceWhereInput | DeviceWhereInput[]
    OR?: DeviceWhereInput[]
    NOT?: DeviceWhereInput | DeviceWhereInput[]
    truckId?: UuidFilter<"Device"> | string
    simNumber?: StringNullableFilter<"Device"> | string | null
    installedAt?: DateTimeFilter<"Device"> | Date | string
    removedAt?: DateTimeNullableFilter<"Device"> | Date | string | null
    createdBy?: UuidNullableFilter<"Device"> | string | null
    updatedBy?: UuidNullableFilter<"Device"> | string | null
    truck?: XOR<TruckRelationFilter, TruckWhereInput>
    sensors?: SensorListRelationFilter
    gpsPositions?: GpsPositionListRelationFilter
    tirePressureEvents?: TirePressureEventListRelationFilter
    hubTemperatureEvents?: HubTemperatureEventListRelationFilter
    deviceStatusEvents?: DeviceStatusEventListRelationFilter
    lockEvents?: LockEventListRelationFilter
  }, "id" | "sn">

  export type DeviceOrderByWithAggregationInput = {
    id?: SortOrder
    truckId?: SortOrder
    sn?: SortOrder
    simNumber?: SortOrderInput | SortOrder
    installedAt?: SortOrder
    removedAt?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: DeviceCountOrderByAggregateInput
    _max?: DeviceMaxOrderByAggregateInput
    _min?: DeviceMinOrderByAggregateInput
  }

  export type DeviceScalarWhereWithAggregatesInput = {
    AND?: DeviceScalarWhereWithAggregatesInput | DeviceScalarWhereWithAggregatesInput[]
    OR?: DeviceScalarWhereWithAggregatesInput[]
    NOT?: DeviceScalarWhereWithAggregatesInput | DeviceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Device"> | string
    truckId?: UuidWithAggregatesFilter<"Device"> | string
    sn?: StringWithAggregatesFilter<"Device"> | string
    simNumber?: StringNullableWithAggregatesFilter<"Device"> | string | null
    installedAt?: DateTimeWithAggregatesFilter<"Device"> | Date | string
    removedAt?: DateTimeNullableWithAggregatesFilter<"Device"> | Date | string | null
    createdBy?: UuidNullableWithAggregatesFilter<"Device"> | string | null
    updatedBy?: UuidNullableWithAggregatesFilter<"Device"> | string | null
  }

  export type SensorWhereInput = {
    AND?: SensorWhereInput | SensorWhereInput[]
    OR?: SensorWhereInput[]
    NOT?: SensorWhereInput | SensorWhereInput[]
    id?: UuidFilter<"Sensor"> | string
    deviceId?: UuidFilter<"Sensor"> | string
    type?: StringFilter<"Sensor"> | string
    positionNo?: IntFilter<"Sensor"> | number
    sn?: StringNullableFilter<"Sensor"> | string | null
    installedAt?: DateTimeNullableFilter<"Sensor"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Sensor"> | Date | string | null
    createdBy?: UuidNullableFilter<"Sensor"> | string | null
    updatedBy?: UuidNullableFilter<"Sensor"> | string | null
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
  }

  export type SensorOrderByWithRelationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    type?: SortOrder
    positionNo?: SortOrder
    sn?: SortOrderInput | SortOrder
    installedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    device?: DeviceOrderByWithRelationInput
  }

  export type SensorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sn?: string
    AND?: SensorWhereInput | SensorWhereInput[]
    OR?: SensorWhereInput[]
    NOT?: SensorWhereInput | SensorWhereInput[]
    deviceId?: UuidFilter<"Sensor"> | string
    type?: StringFilter<"Sensor"> | string
    positionNo?: IntFilter<"Sensor"> | number
    installedAt?: DateTimeNullableFilter<"Sensor"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Sensor"> | Date | string | null
    createdBy?: UuidNullableFilter<"Sensor"> | string | null
    updatedBy?: UuidNullableFilter<"Sensor"> | string | null
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
  }, "id" | "sn">

  export type SensorOrderByWithAggregationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    type?: SortOrder
    positionNo?: SortOrder
    sn?: SortOrderInput | SortOrder
    installedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: SensorCountOrderByAggregateInput
    _avg?: SensorAvgOrderByAggregateInput
    _max?: SensorMaxOrderByAggregateInput
    _min?: SensorMinOrderByAggregateInput
    _sum?: SensorSumOrderByAggregateInput
  }

  export type SensorScalarWhereWithAggregatesInput = {
    AND?: SensorScalarWhereWithAggregatesInput | SensorScalarWhereWithAggregatesInput[]
    OR?: SensorScalarWhereWithAggregatesInput[]
    NOT?: SensorScalarWhereWithAggregatesInput | SensorScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Sensor"> | string
    deviceId?: UuidWithAggregatesFilter<"Sensor"> | string
    type?: StringWithAggregatesFilter<"Sensor"> | string
    positionNo?: IntWithAggregatesFilter<"Sensor"> | number
    sn?: StringNullableWithAggregatesFilter<"Sensor"> | string | null
    installedAt?: DateTimeNullableWithAggregatesFilter<"Sensor"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"Sensor"> | Date | string | null
    createdBy?: UuidNullableWithAggregatesFilter<"Sensor"> | string | null
    updatedBy?: UuidNullableWithAggregatesFilter<"Sensor"> | string | null
  }

  export type TruckStatusEventWhereInput = {
    AND?: TruckStatusEventWhereInput | TruckStatusEventWhereInput[]
    OR?: TruckStatusEventWhereInput[]
    NOT?: TruckStatusEventWhereInput | TruckStatusEventWhereInput[]
    id?: UuidFilter<"TruckStatusEvent"> | string
    truckId?: UuidFilter<"TruckStatusEvent"> | string
    status?: EnumTruckStatusFilter<"TruckStatusEvent"> | $Enums.TruckStatus
    note?: StringNullableFilter<"TruckStatusEvent"> | string | null
    changedAt?: DateTimeFilter<"TruckStatusEvent"> | Date | string
    createdBy?: UuidNullableFilter<"TruckStatusEvent"> | string | null
    truck?: XOR<TruckRelationFilter, TruckWhereInput>
  }

  export type TruckStatusEventOrderByWithRelationInput = {
    id?: SortOrder
    truckId?: SortOrder
    status?: SortOrder
    note?: SortOrderInput | SortOrder
    changedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    truck?: TruckOrderByWithRelationInput
  }

  export type TruckStatusEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TruckStatusEventWhereInput | TruckStatusEventWhereInput[]
    OR?: TruckStatusEventWhereInput[]
    NOT?: TruckStatusEventWhereInput | TruckStatusEventWhereInput[]
    truckId?: UuidFilter<"TruckStatusEvent"> | string
    status?: EnumTruckStatusFilter<"TruckStatusEvent"> | $Enums.TruckStatus
    note?: StringNullableFilter<"TruckStatusEvent"> | string | null
    changedAt?: DateTimeFilter<"TruckStatusEvent"> | Date | string
    createdBy?: UuidNullableFilter<"TruckStatusEvent"> | string | null
    truck?: XOR<TruckRelationFilter, TruckWhereInput>
  }, "id">

  export type TruckStatusEventOrderByWithAggregationInput = {
    id?: SortOrder
    truckId?: SortOrder
    status?: SortOrder
    note?: SortOrderInput | SortOrder
    changedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: TruckStatusEventCountOrderByAggregateInput
    _max?: TruckStatusEventMaxOrderByAggregateInput
    _min?: TruckStatusEventMinOrderByAggregateInput
  }

  export type TruckStatusEventScalarWhereWithAggregatesInput = {
    AND?: TruckStatusEventScalarWhereWithAggregatesInput | TruckStatusEventScalarWhereWithAggregatesInput[]
    OR?: TruckStatusEventScalarWhereWithAggregatesInput[]
    NOT?: TruckStatusEventScalarWhereWithAggregatesInput | TruckStatusEventScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"TruckStatusEvent"> | string
    truckId?: UuidWithAggregatesFilter<"TruckStatusEvent"> | string
    status?: EnumTruckStatusWithAggregatesFilter<"TruckStatusEvent"> | $Enums.TruckStatus
    note?: StringNullableWithAggregatesFilter<"TruckStatusEvent"> | string | null
    changedAt?: DateTimeWithAggregatesFilter<"TruckStatusEvent"> | Date | string
    createdBy?: UuidNullableWithAggregatesFilter<"TruckStatusEvent"> | string | null
  }

  export type GeofenceWhereInput = {
    AND?: GeofenceWhereInput | GeofenceWhereInput[]
    OR?: GeofenceWhereInput[]
    NOT?: GeofenceWhereInput | GeofenceWhereInput[]
    id?: UuidFilter<"Geofence"> | string
    name?: StringFilter<"Geofence"> | string
    createdBy?: UuidNullableFilter<"Geofence"> | string | null
    createdAt?: DateTimeFilter<"Geofence"> | Date | string
  }

  export type GeofenceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type GeofenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GeofenceWhereInput | GeofenceWhereInput[]
    OR?: GeofenceWhereInput[]
    NOT?: GeofenceWhereInput | GeofenceWhereInput[]
    name?: StringFilter<"Geofence"> | string
    createdBy?: UuidNullableFilter<"Geofence"> | string | null
    createdAt?: DateTimeFilter<"Geofence"> | Date | string
  }, "id">

  export type GeofenceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: GeofenceCountOrderByAggregateInput
    _max?: GeofenceMaxOrderByAggregateInput
    _min?: GeofenceMinOrderByAggregateInput
  }

  export type GeofenceScalarWhereWithAggregatesInput = {
    AND?: GeofenceScalarWhereWithAggregatesInput | GeofenceScalarWhereWithAggregatesInput[]
    OR?: GeofenceScalarWhereWithAggregatesInput[]
    NOT?: GeofenceScalarWhereWithAggregatesInput | GeofenceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Geofence"> | string
    name?: StringWithAggregatesFilter<"Geofence"> | string
    createdBy?: UuidNullableWithAggregatesFilter<"Geofence"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Geofence"> | Date | string
  }

  export type GpsPositionWhereInput = {
    AND?: GpsPositionWhereInput | GpsPositionWhereInput[]
    OR?: GpsPositionWhereInput[]
    NOT?: GpsPositionWhereInput | GpsPositionWhereInput[]
    id?: BigIntFilter<"GpsPosition"> | bigint | number
    deviceId?: UuidNullableFilter<"GpsPosition"> | string | null
    truckId?: UuidFilter<"GpsPosition"> | string
    ts?: DateTimeFilter<"GpsPosition"> | Date | string
    speedKph?: FloatNullableFilter<"GpsPosition"> | number | null
    headingDeg?: FloatNullableFilter<"GpsPosition"> | number | null
    hdop?: FloatNullableFilter<"GpsPosition"> | number | null
    source?: StringNullableFilter<"GpsPosition"> | string | null
    device?: XOR<DeviceNullableRelationFilter, DeviceWhereInput> | null
    truck?: XOR<TruckRelationFilter, TruckWhereInput>
  }

  export type GpsPositionOrderByWithRelationInput = {
    id?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    truckId?: SortOrder
    ts?: SortOrder
    speedKph?: SortOrderInput | SortOrder
    headingDeg?: SortOrderInput | SortOrder
    hdop?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    device?: DeviceOrderByWithRelationInput
    truck?: TruckOrderByWithRelationInput
  }

  export type GpsPositionWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: GpsPositionWhereInput | GpsPositionWhereInput[]
    OR?: GpsPositionWhereInput[]
    NOT?: GpsPositionWhereInput | GpsPositionWhereInput[]
    deviceId?: UuidNullableFilter<"GpsPosition"> | string | null
    truckId?: UuidFilter<"GpsPosition"> | string
    ts?: DateTimeFilter<"GpsPosition"> | Date | string
    speedKph?: FloatNullableFilter<"GpsPosition"> | number | null
    headingDeg?: FloatNullableFilter<"GpsPosition"> | number | null
    hdop?: FloatNullableFilter<"GpsPosition"> | number | null
    source?: StringNullableFilter<"GpsPosition"> | string | null
    device?: XOR<DeviceNullableRelationFilter, DeviceWhereInput> | null
    truck?: XOR<TruckRelationFilter, TruckWhereInput>
  }, "id">

  export type GpsPositionOrderByWithAggregationInput = {
    id?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    truckId?: SortOrder
    ts?: SortOrder
    speedKph?: SortOrderInput | SortOrder
    headingDeg?: SortOrderInput | SortOrder
    hdop?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    _count?: GpsPositionCountOrderByAggregateInput
    _avg?: GpsPositionAvgOrderByAggregateInput
    _max?: GpsPositionMaxOrderByAggregateInput
    _min?: GpsPositionMinOrderByAggregateInput
    _sum?: GpsPositionSumOrderByAggregateInput
  }

  export type GpsPositionScalarWhereWithAggregatesInput = {
    AND?: GpsPositionScalarWhereWithAggregatesInput | GpsPositionScalarWhereWithAggregatesInput[]
    OR?: GpsPositionScalarWhereWithAggregatesInput[]
    NOT?: GpsPositionScalarWhereWithAggregatesInput | GpsPositionScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"GpsPosition"> | bigint | number
    deviceId?: UuidNullableWithAggregatesFilter<"GpsPosition"> | string | null
    truckId?: UuidWithAggregatesFilter<"GpsPosition"> | string
    ts?: DateTimeWithAggregatesFilter<"GpsPosition"> | Date | string
    speedKph?: FloatNullableWithAggregatesFilter<"GpsPosition"> | number | null
    headingDeg?: FloatNullableWithAggregatesFilter<"GpsPosition"> | number | null
    hdop?: FloatNullableWithAggregatesFilter<"GpsPosition"> | number | null
    source?: StringNullableWithAggregatesFilter<"GpsPosition"> | string | null
  }

  export type TripWhereInput = {
    AND?: TripWhereInput | TripWhereInput[]
    OR?: TripWhereInput[]
    NOT?: TripWhereInput | TripWhereInput[]
    id?: UuidFilter<"Trip"> | string
    truckId?: UuidFilter<"Trip"> | string
    startTs?: DateTimeFilter<"Trip"> | Date | string
    endTs?: DateTimeNullableFilter<"Trip"> | Date | string | null
    truck?: XOR<TruckRelationFilter, TruckWhereInput>
  }

  export type TripOrderByWithRelationInput = {
    id?: SortOrder
    truckId?: SortOrder
    startTs?: SortOrder
    endTs?: SortOrderInput | SortOrder
    truck?: TruckOrderByWithRelationInput
  }

  export type TripWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TripWhereInput | TripWhereInput[]
    OR?: TripWhereInput[]
    NOT?: TripWhereInput | TripWhereInput[]
    truckId?: UuidFilter<"Trip"> | string
    startTs?: DateTimeFilter<"Trip"> | Date | string
    endTs?: DateTimeNullableFilter<"Trip"> | Date | string | null
    truck?: XOR<TruckRelationFilter, TruckWhereInput>
  }, "id">

  export type TripOrderByWithAggregationInput = {
    id?: SortOrder
    truckId?: SortOrder
    startTs?: SortOrder
    endTs?: SortOrderInput | SortOrder
    _count?: TripCountOrderByAggregateInput
    _max?: TripMaxOrderByAggregateInput
    _min?: TripMinOrderByAggregateInput
  }

  export type TripScalarWhereWithAggregatesInput = {
    AND?: TripScalarWhereWithAggregatesInput | TripScalarWhereWithAggregatesInput[]
    OR?: TripScalarWhereWithAggregatesInput[]
    NOT?: TripScalarWhereWithAggregatesInput | TripScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Trip"> | string
    truckId?: UuidWithAggregatesFilter<"Trip"> | string
    startTs?: DateTimeWithAggregatesFilter<"Trip"> | Date | string
    endTs?: DateTimeNullableWithAggregatesFilter<"Trip"> | Date | string | null
  }

  export type TirePressureEventWhereInput = {
    AND?: TirePressureEventWhereInput | TirePressureEventWhereInput[]
    OR?: TirePressureEventWhereInput[]
    NOT?: TirePressureEventWhereInput | TirePressureEventWhereInput[]
    id?: UuidFilter<"TirePressureEvent"> | string
    deviceId?: UuidFilter<"TirePressureEvent"> | string
    truckId?: UuidFilter<"TirePressureEvent"> | string
    tireNo?: IntFilter<"TirePressureEvent"> | number
    pressureKpa?: FloatNullableFilter<"TirePressureEvent"> | number | null
    tempCelsius?: FloatNullableFilter<"TirePressureEvent"> | number | null
    exType?: StringNullableFilter<"TirePressureEvent"> | string | null
    batteryLevel?: IntNullableFilter<"TirePressureEvent"> | number | null
    changedAt?: DateTimeFilter<"TirePressureEvent"> | Date | string
    createdBy?: UuidNullableFilter<"TirePressureEvent"> | string | null
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
    truck?: XOR<TruckRelationFilter, TruckWhereInput>
  }

  export type TirePressureEventOrderByWithRelationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    truckId?: SortOrder
    tireNo?: SortOrder
    pressureKpa?: SortOrderInput | SortOrder
    tempCelsius?: SortOrderInput | SortOrder
    exType?: SortOrderInput | SortOrder
    batteryLevel?: SortOrderInput | SortOrder
    changedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    device?: DeviceOrderByWithRelationInput
    truck?: TruckOrderByWithRelationInput
  }

  export type TirePressureEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TirePressureEventWhereInput | TirePressureEventWhereInput[]
    OR?: TirePressureEventWhereInput[]
    NOT?: TirePressureEventWhereInput | TirePressureEventWhereInput[]
    deviceId?: UuidFilter<"TirePressureEvent"> | string
    truckId?: UuidFilter<"TirePressureEvent"> | string
    tireNo?: IntFilter<"TirePressureEvent"> | number
    pressureKpa?: FloatNullableFilter<"TirePressureEvent"> | number | null
    tempCelsius?: FloatNullableFilter<"TirePressureEvent"> | number | null
    exType?: StringNullableFilter<"TirePressureEvent"> | string | null
    batteryLevel?: IntNullableFilter<"TirePressureEvent"> | number | null
    changedAt?: DateTimeFilter<"TirePressureEvent"> | Date | string
    createdBy?: UuidNullableFilter<"TirePressureEvent"> | string | null
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
    truck?: XOR<TruckRelationFilter, TruckWhereInput>
  }, "id">

  export type TirePressureEventOrderByWithAggregationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    truckId?: SortOrder
    tireNo?: SortOrder
    pressureKpa?: SortOrderInput | SortOrder
    tempCelsius?: SortOrderInput | SortOrder
    exType?: SortOrderInput | SortOrder
    batteryLevel?: SortOrderInput | SortOrder
    changedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: TirePressureEventCountOrderByAggregateInput
    _avg?: TirePressureEventAvgOrderByAggregateInput
    _max?: TirePressureEventMaxOrderByAggregateInput
    _min?: TirePressureEventMinOrderByAggregateInput
    _sum?: TirePressureEventSumOrderByAggregateInput
  }

  export type TirePressureEventScalarWhereWithAggregatesInput = {
    AND?: TirePressureEventScalarWhereWithAggregatesInput | TirePressureEventScalarWhereWithAggregatesInput[]
    OR?: TirePressureEventScalarWhereWithAggregatesInput[]
    NOT?: TirePressureEventScalarWhereWithAggregatesInput | TirePressureEventScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"TirePressureEvent"> | string
    deviceId?: UuidWithAggregatesFilter<"TirePressureEvent"> | string
    truckId?: UuidWithAggregatesFilter<"TirePressureEvent"> | string
    tireNo?: IntWithAggregatesFilter<"TirePressureEvent"> | number
    pressureKpa?: FloatNullableWithAggregatesFilter<"TirePressureEvent"> | number | null
    tempCelsius?: FloatNullableWithAggregatesFilter<"TirePressureEvent"> | number | null
    exType?: StringNullableWithAggregatesFilter<"TirePressureEvent"> | string | null
    batteryLevel?: IntNullableWithAggregatesFilter<"TirePressureEvent"> | number | null
    changedAt?: DateTimeWithAggregatesFilter<"TirePressureEvent"> | Date | string
    createdBy?: UuidNullableWithAggregatesFilter<"TirePressureEvent"> | string | null
  }

  export type TireErrorCodeWhereInput = {
    AND?: TireErrorCodeWhereInput | TireErrorCodeWhereInput[]
    OR?: TireErrorCodeWhereInput[]
    NOT?: TireErrorCodeWhereInput | TireErrorCodeWhereInput[]
    code?: IntFilter<"TireErrorCode"> | number
    description?: StringNullableFilter<"TireErrorCode"> | string | null
  }

  export type TireErrorCodeOrderByWithRelationInput = {
    code?: SortOrder
    description?: SortOrderInput | SortOrder
  }

  export type TireErrorCodeWhereUniqueInput = Prisma.AtLeast<{
    code?: number
    AND?: TireErrorCodeWhereInput | TireErrorCodeWhereInput[]
    OR?: TireErrorCodeWhereInput[]
    NOT?: TireErrorCodeWhereInput | TireErrorCodeWhereInput[]
    description?: StringNullableFilter<"TireErrorCode"> | string | null
  }, "code">

  export type TireErrorCodeOrderByWithAggregationInput = {
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: TireErrorCodeCountOrderByAggregateInput
    _avg?: TireErrorCodeAvgOrderByAggregateInput
    _max?: TireErrorCodeMaxOrderByAggregateInput
    _min?: TireErrorCodeMinOrderByAggregateInput
    _sum?: TireErrorCodeSumOrderByAggregateInput
  }

  export type TireErrorCodeScalarWhereWithAggregatesInput = {
    AND?: TireErrorCodeScalarWhereWithAggregatesInput | TireErrorCodeScalarWhereWithAggregatesInput[]
    OR?: TireErrorCodeScalarWhereWithAggregatesInput[]
    NOT?: TireErrorCodeScalarWhereWithAggregatesInput | TireErrorCodeScalarWhereWithAggregatesInput[]
    code?: IntWithAggregatesFilter<"TireErrorCode"> | number
    description?: StringNullableWithAggregatesFilter<"TireErrorCode"> | string | null
  }

  export type HubTemperatureEventWhereInput = {
    AND?: HubTemperatureEventWhereInput | HubTemperatureEventWhereInput[]
    OR?: HubTemperatureEventWhereInput[]
    NOT?: HubTemperatureEventWhereInput | HubTemperatureEventWhereInput[]
    id?: UuidFilter<"HubTemperatureEvent"> | string
    deviceId?: UuidFilter<"HubTemperatureEvent"> | string
    truckId?: UuidFilter<"HubTemperatureEvent"> | string
    hubNo?: IntNullableFilter<"HubTemperatureEvent"> | number | null
    tempCelsius?: FloatNullableFilter<"HubTemperatureEvent"> | number | null
    exType?: StringNullableFilter<"HubTemperatureEvent"> | string | null
    batteryLevel?: IntNullableFilter<"HubTemperatureEvent"> | number | null
    changedAt?: DateTimeFilter<"HubTemperatureEvent"> | Date | string
    createdBy?: UuidNullableFilter<"HubTemperatureEvent"> | string | null
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
    truck?: XOR<TruckRelationFilter, TruckWhereInput>
  }

  export type HubTemperatureEventOrderByWithRelationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    truckId?: SortOrder
    hubNo?: SortOrderInput | SortOrder
    tempCelsius?: SortOrderInput | SortOrder
    exType?: SortOrderInput | SortOrder
    batteryLevel?: SortOrderInput | SortOrder
    changedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    device?: DeviceOrderByWithRelationInput
    truck?: TruckOrderByWithRelationInput
  }

  export type HubTemperatureEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HubTemperatureEventWhereInput | HubTemperatureEventWhereInput[]
    OR?: HubTemperatureEventWhereInput[]
    NOT?: HubTemperatureEventWhereInput | HubTemperatureEventWhereInput[]
    deviceId?: UuidFilter<"HubTemperatureEvent"> | string
    truckId?: UuidFilter<"HubTemperatureEvent"> | string
    hubNo?: IntNullableFilter<"HubTemperatureEvent"> | number | null
    tempCelsius?: FloatNullableFilter<"HubTemperatureEvent"> | number | null
    exType?: StringNullableFilter<"HubTemperatureEvent"> | string | null
    batteryLevel?: IntNullableFilter<"HubTemperatureEvent"> | number | null
    changedAt?: DateTimeFilter<"HubTemperatureEvent"> | Date | string
    createdBy?: UuidNullableFilter<"HubTemperatureEvent"> | string | null
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
    truck?: XOR<TruckRelationFilter, TruckWhereInput>
  }, "id">

  export type HubTemperatureEventOrderByWithAggregationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    truckId?: SortOrder
    hubNo?: SortOrderInput | SortOrder
    tempCelsius?: SortOrderInput | SortOrder
    exType?: SortOrderInput | SortOrder
    batteryLevel?: SortOrderInput | SortOrder
    changedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: HubTemperatureEventCountOrderByAggregateInput
    _avg?: HubTemperatureEventAvgOrderByAggregateInput
    _max?: HubTemperatureEventMaxOrderByAggregateInput
    _min?: HubTemperatureEventMinOrderByAggregateInput
    _sum?: HubTemperatureEventSumOrderByAggregateInput
  }

  export type HubTemperatureEventScalarWhereWithAggregatesInput = {
    AND?: HubTemperatureEventScalarWhereWithAggregatesInput | HubTemperatureEventScalarWhereWithAggregatesInput[]
    OR?: HubTemperatureEventScalarWhereWithAggregatesInput[]
    NOT?: HubTemperatureEventScalarWhereWithAggregatesInput | HubTemperatureEventScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"HubTemperatureEvent"> | string
    deviceId?: UuidWithAggregatesFilter<"HubTemperatureEvent"> | string
    truckId?: UuidWithAggregatesFilter<"HubTemperatureEvent"> | string
    hubNo?: IntNullableWithAggregatesFilter<"HubTemperatureEvent"> | number | null
    tempCelsius?: FloatNullableWithAggregatesFilter<"HubTemperatureEvent"> | number | null
    exType?: StringNullableWithAggregatesFilter<"HubTemperatureEvent"> | string | null
    batteryLevel?: IntNullableWithAggregatesFilter<"HubTemperatureEvent"> | number | null
    changedAt?: DateTimeWithAggregatesFilter<"HubTemperatureEvent"> | Date | string
    createdBy?: UuidNullableWithAggregatesFilter<"HubTemperatureEvent"> | string | null
  }

  export type FuelLevelEventWhereInput = {
    AND?: FuelLevelEventWhereInput | FuelLevelEventWhereInput[]
    OR?: FuelLevelEventWhereInput[]
    NOT?: FuelLevelEventWhereInput | FuelLevelEventWhereInput[]
    id?: UuidFilter<"FuelLevelEvent"> | string
    truckId?: UuidFilter<"FuelLevelEvent"> | string
    fuelPercent?: FloatNullableFilter<"FuelLevelEvent"> | number | null
    changedAt?: DateTimeFilter<"FuelLevelEvent"> | Date | string
    source?: StringNullableFilter<"FuelLevelEvent"> | string | null
    createdBy?: UuidNullableFilter<"FuelLevelEvent"> | string | null
    truck?: XOR<TruckRelationFilter, TruckWhereInput>
  }

  export type FuelLevelEventOrderByWithRelationInput = {
    id?: SortOrder
    truckId?: SortOrder
    fuelPercent?: SortOrderInput | SortOrder
    changedAt?: SortOrder
    source?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    truck?: TruckOrderByWithRelationInput
  }

  export type FuelLevelEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FuelLevelEventWhereInput | FuelLevelEventWhereInput[]
    OR?: FuelLevelEventWhereInput[]
    NOT?: FuelLevelEventWhereInput | FuelLevelEventWhereInput[]
    truckId?: UuidFilter<"FuelLevelEvent"> | string
    fuelPercent?: FloatNullableFilter<"FuelLevelEvent"> | number | null
    changedAt?: DateTimeFilter<"FuelLevelEvent"> | Date | string
    source?: StringNullableFilter<"FuelLevelEvent"> | string | null
    createdBy?: UuidNullableFilter<"FuelLevelEvent"> | string | null
    truck?: XOR<TruckRelationFilter, TruckWhereInput>
  }, "id">

  export type FuelLevelEventOrderByWithAggregationInput = {
    id?: SortOrder
    truckId?: SortOrder
    fuelPercent?: SortOrderInput | SortOrder
    changedAt?: SortOrder
    source?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: FuelLevelEventCountOrderByAggregateInput
    _avg?: FuelLevelEventAvgOrderByAggregateInput
    _max?: FuelLevelEventMaxOrderByAggregateInput
    _min?: FuelLevelEventMinOrderByAggregateInput
    _sum?: FuelLevelEventSumOrderByAggregateInput
  }

  export type FuelLevelEventScalarWhereWithAggregatesInput = {
    AND?: FuelLevelEventScalarWhereWithAggregatesInput | FuelLevelEventScalarWhereWithAggregatesInput[]
    OR?: FuelLevelEventScalarWhereWithAggregatesInput[]
    NOT?: FuelLevelEventScalarWhereWithAggregatesInput | FuelLevelEventScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"FuelLevelEvent"> | string
    truckId?: UuidWithAggregatesFilter<"FuelLevelEvent"> | string
    fuelPercent?: FloatNullableWithAggregatesFilter<"FuelLevelEvent"> | number | null
    changedAt?: DateTimeWithAggregatesFilter<"FuelLevelEvent"> | Date | string
    source?: StringNullableWithAggregatesFilter<"FuelLevelEvent"> | string | null
    createdBy?: UuidNullableWithAggregatesFilter<"FuelLevelEvent"> | string | null
  }

  export type SpeedEventWhereInput = {
    AND?: SpeedEventWhereInput | SpeedEventWhereInput[]
    OR?: SpeedEventWhereInput[]
    NOT?: SpeedEventWhereInput | SpeedEventWhereInput[]
    id?: UuidFilter<"SpeedEvent"> | string
    truckId?: UuidFilter<"SpeedEvent"> | string
    speedKph?: FloatNullableFilter<"SpeedEvent"> | number | null
    changedAt?: DateTimeFilter<"SpeedEvent"> | Date | string
    source?: StringNullableFilter<"SpeedEvent"> | string | null
    createdBy?: UuidNullableFilter<"SpeedEvent"> | string | null
    truck?: XOR<TruckRelationFilter, TruckWhereInput>
  }

  export type SpeedEventOrderByWithRelationInput = {
    id?: SortOrder
    truckId?: SortOrder
    speedKph?: SortOrderInput | SortOrder
    changedAt?: SortOrder
    source?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    truck?: TruckOrderByWithRelationInput
  }

  export type SpeedEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SpeedEventWhereInput | SpeedEventWhereInput[]
    OR?: SpeedEventWhereInput[]
    NOT?: SpeedEventWhereInput | SpeedEventWhereInput[]
    truckId?: UuidFilter<"SpeedEvent"> | string
    speedKph?: FloatNullableFilter<"SpeedEvent"> | number | null
    changedAt?: DateTimeFilter<"SpeedEvent"> | Date | string
    source?: StringNullableFilter<"SpeedEvent"> | string | null
    createdBy?: UuidNullableFilter<"SpeedEvent"> | string | null
    truck?: XOR<TruckRelationFilter, TruckWhereInput>
  }, "id">

  export type SpeedEventOrderByWithAggregationInput = {
    id?: SortOrder
    truckId?: SortOrder
    speedKph?: SortOrderInput | SortOrder
    changedAt?: SortOrder
    source?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: SpeedEventCountOrderByAggregateInput
    _avg?: SpeedEventAvgOrderByAggregateInput
    _max?: SpeedEventMaxOrderByAggregateInput
    _min?: SpeedEventMinOrderByAggregateInput
    _sum?: SpeedEventSumOrderByAggregateInput
  }

  export type SpeedEventScalarWhereWithAggregatesInput = {
    AND?: SpeedEventScalarWhereWithAggregatesInput | SpeedEventScalarWhereWithAggregatesInput[]
    OR?: SpeedEventScalarWhereWithAggregatesInput[]
    NOT?: SpeedEventScalarWhereWithAggregatesInput | SpeedEventScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SpeedEvent"> | string
    truckId?: UuidWithAggregatesFilter<"SpeedEvent"> | string
    speedKph?: FloatNullableWithAggregatesFilter<"SpeedEvent"> | number | null
    changedAt?: DateTimeWithAggregatesFilter<"SpeedEvent"> | Date | string
    source?: StringNullableWithAggregatesFilter<"SpeedEvent"> | string | null
    createdBy?: UuidNullableWithAggregatesFilter<"SpeedEvent"> | string | null
  }

  export type AlertEventWhereInput = {
    AND?: AlertEventWhereInput | AlertEventWhereInput[]
    OR?: AlertEventWhereInput[]
    NOT?: AlertEventWhereInput | AlertEventWhereInput[]
    id?: UuidFilter<"AlertEvent"> | string
    truckId?: UuidFilter<"AlertEvent"> | string
    type?: EnumAlertTypeFilter<"AlertEvent"> | $Enums.AlertType
    severity?: IntNullableFilter<"AlertEvent"> | number | null
    detail?: JsonNullableFilter<"AlertEvent">
    occurredAt?: DateTimeFilter<"AlertEvent"> | Date | string
    acknowledged?: BoolFilter<"AlertEvent"> | boolean
    createdBy?: UuidNullableFilter<"AlertEvent"> | string | null
    truck?: XOR<TruckRelationFilter, TruckWhereInput>
  }

  export type AlertEventOrderByWithRelationInput = {
    id?: SortOrder
    truckId?: SortOrder
    type?: SortOrder
    severity?: SortOrderInput | SortOrder
    detail?: SortOrderInput | SortOrder
    occurredAt?: SortOrder
    acknowledged?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    truck?: TruckOrderByWithRelationInput
  }

  export type AlertEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AlertEventWhereInput | AlertEventWhereInput[]
    OR?: AlertEventWhereInput[]
    NOT?: AlertEventWhereInput | AlertEventWhereInput[]
    truckId?: UuidFilter<"AlertEvent"> | string
    type?: EnumAlertTypeFilter<"AlertEvent"> | $Enums.AlertType
    severity?: IntNullableFilter<"AlertEvent"> | number | null
    detail?: JsonNullableFilter<"AlertEvent">
    occurredAt?: DateTimeFilter<"AlertEvent"> | Date | string
    acknowledged?: BoolFilter<"AlertEvent"> | boolean
    createdBy?: UuidNullableFilter<"AlertEvent"> | string | null
    truck?: XOR<TruckRelationFilter, TruckWhereInput>
  }, "id">

  export type AlertEventOrderByWithAggregationInput = {
    id?: SortOrder
    truckId?: SortOrder
    type?: SortOrder
    severity?: SortOrderInput | SortOrder
    detail?: SortOrderInput | SortOrder
    occurredAt?: SortOrder
    acknowledged?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: AlertEventCountOrderByAggregateInput
    _avg?: AlertEventAvgOrderByAggregateInput
    _max?: AlertEventMaxOrderByAggregateInput
    _min?: AlertEventMinOrderByAggregateInput
    _sum?: AlertEventSumOrderByAggregateInput
  }

  export type AlertEventScalarWhereWithAggregatesInput = {
    AND?: AlertEventScalarWhereWithAggregatesInput | AlertEventScalarWhereWithAggregatesInput[]
    OR?: AlertEventScalarWhereWithAggregatesInput[]
    NOT?: AlertEventScalarWhereWithAggregatesInput | AlertEventScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AlertEvent"> | string
    truckId?: UuidWithAggregatesFilter<"AlertEvent"> | string
    type?: EnumAlertTypeWithAggregatesFilter<"AlertEvent"> | $Enums.AlertType
    severity?: IntNullableWithAggregatesFilter<"AlertEvent"> | number | null
    detail?: JsonNullableWithAggregatesFilter<"AlertEvent">
    occurredAt?: DateTimeWithAggregatesFilter<"AlertEvent"> | Date | string
    acknowledged?: BoolWithAggregatesFilter<"AlertEvent"> | boolean
    createdBy?: UuidNullableWithAggregatesFilter<"AlertEvent"> | string | null
  }

  export type DeviceStatusEventWhereInput = {
    AND?: DeviceStatusEventWhereInput | DeviceStatusEventWhereInput[]
    OR?: DeviceStatusEventWhereInput[]
    NOT?: DeviceStatusEventWhereInput | DeviceStatusEventWhereInput[]
    id?: UuidFilter<"DeviceStatusEvent"> | string
    deviceId?: UuidFilter<"DeviceStatusEvent"> | string
    truckId?: UuidFilter<"DeviceStatusEvent"> | string
    hostBat?: IntNullableFilter<"DeviceStatusEvent"> | number | null
    repeater1Bat?: IntNullableFilter<"DeviceStatusEvent"> | number | null
    repeater2Bat?: IntNullableFilter<"DeviceStatusEvent"> | number | null
    lockState?: IntNullableFilter<"DeviceStatusEvent"> | number | null
    reportedAt?: DateTimeFilter<"DeviceStatusEvent"> | Date | string
    createdBy?: UuidNullableFilter<"DeviceStatusEvent"> | string | null
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
    truck?: XOR<TruckRelationFilter, TruckWhereInput>
  }

  export type DeviceStatusEventOrderByWithRelationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    truckId?: SortOrder
    hostBat?: SortOrderInput | SortOrder
    repeater1Bat?: SortOrderInput | SortOrder
    repeater2Bat?: SortOrderInput | SortOrder
    lockState?: SortOrderInput | SortOrder
    reportedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    device?: DeviceOrderByWithRelationInput
    truck?: TruckOrderByWithRelationInput
  }

  export type DeviceStatusEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeviceStatusEventWhereInput | DeviceStatusEventWhereInput[]
    OR?: DeviceStatusEventWhereInput[]
    NOT?: DeviceStatusEventWhereInput | DeviceStatusEventWhereInput[]
    deviceId?: UuidFilter<"DeviceStatusEvent"> | string
    truckId?: UuidFilter<"DeviceStatusEvent"> | string
    hostBat?: IntNullableFilter<"DeviceStatusEvent"> | number | null
    repeater1Bat?: IntNullableFilter<"DeviceStatusEvent"> | number | null
    repeater2Bat?: IntNullableFilter<"DeviceStatusEvent"> | number | null
    lockState?: IntNullableFilter<"DeviceStatusEvent"> | number | null
    reportedAt?: DateTimeFilter<"DeviceStatusEvent"> | Date | string
    createdBy?: UuidNullableFilter<"DeviceStatusEvent"> | string | null
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
    truck?: XOR<TruckRelationFilter, TruckWhereInput>
  }, "id">

  export type DeviceStatusEventOrderByWithAggregationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    truckId?: SortOrder
    hostBat?: SortOrderInput | SortOrder
    repeater1Bat?: SortOrderInput | SortOrder
    repeater2Bat?: SortOrderInput | SortOrder
    lockState?: SortOrderInput | SortOrder
    reportedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: DeviceStatusEventCountOrderByAggregateInput
    _avg?: DeviceStatusEventAvgOrderByAggregateInput
    _max?: DeviceStatusEventMaxOrderByAggregateInput
    _min?: DeviceStatusEventMinOrderByAggregateInput
    _sum?: DeviceStatusEventSumOrderByAggregateInput
  }

  export type DeviceStatusEventScalarWhereWithAggregatesInput = {
    AND?: DeviceStatusEventScalarWhereWithAggregatesInput | DeviceStatusEventScalarWhereWithAggregatesInput[]
    OR?: DeviceStatusEventScalarWhereWithAggregatesInput[]
    NOT?: DeviceStatusEventScalarWhereWithAggregatesInput | DeviceStatusEventScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"DeviceStatusEvent"> | string
    deviceId?: UuidWithAggregatesFilter<"DeviceStatusEvent"> | string
    truckId?: UuidWithAggregatesFilter<"DeviceStatusEvent"> | string
    hostBat?: IntNullableWithAggregatesFilter<"DeviceStatusEvent"> | number | null
    repeater1Bat?: IntNullableWithAggregatesFilter<"DeviceStatusEvent"> | number | null
    repeater2Bat?: IntNullableWithAggregatesFilter<"DeviceStatusEvent"> | number | null
    lockState?: IntNullableWithAggregatesFilter<"DeviceStatusEvent"> | number | null
    reportedAt?: DateTimeWithAggregatesFilter<"DeviceStatusEvent"> | Date | string
    createdBy?: UuidNullableWithAggregatesFilter<"DeviceStatusEvent"> | string | null
  }

  export type LockEventWhereInput = {
    AND?: LockEventWhereInput | LockEventWhereInput[]
    OR?: LockEventWhereInput[]
    NOT?: LockEventWhereInput | LockEventWhereInput[]
    id?: UuidFilter<"LockEvent"> | string
    deviceId?: UuidFilter<"LockEvent"> | string
    truckId?: UuidFilter<"LockEvent"> | string
    isLock?: IntNullableFilter<"LockEvent"> | number | null
    reportedAt?: DateTimeFilter<"LockEvent"> | Date | string
    createdBy?: UuidNullableFilter<"LockEvent"> | string | null
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
    truck?: XOR<TruckRelationFilter, TruckWhereInput>
  }

  export type LockEventOrderByWithRelationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    truckId?: SortOrder
    isLock?: SortOrderInput | SortOrder
    reportedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    device?: DeviceOrderByWithRelationInput
    truck?: TruckOrderByWithRelationInput
  }

  export type LockEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LockEventWhereInput | LockEventWhereInput[]
    OR?: LockEventWhereInput[]
    NOT?: LockEventWhereInput | LockEventWhereInput[]
    deviceId?: UuidFilter<"LockEvent"> | string
    truckId?: UuidFilter<"LockEvent"> | string
    isLock?: IntNullableFilter<"LockEvent"> | number | null
    reportedAt?: DateTimeFilter<"LockEvent"> | Date | string
    createdBy?: UuidNullableFilter<"LockEvent"> | string | null
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
    truck?: XOR<TruckRelationFilter, TruckWhereInput>
  }, "id">

  export type LockEventOrderByWithAggregationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    truckId?: SortOrder
    isLock?: SortOrderInput | SortOrder
    reportedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: LockEventCountOrderByAggregateInput
    _avg?: LockEventAvgOrderByAggregateInput
    _max?: LockEventMaxOrderByAggregateInput
    _min?: LockEventMinOrderByAggregateInput
    _sum?: LockEventSumOrderByAggregateInput
  }

  export type LockEventScalarWhereWithAggregatesInput = {
    AND?: LockEventScalarWhereWithAggregatesInput | LockEventScalarWhereWithAggregatesInput[]
    OR?: LockEventScalarWhereWithAggregatesInput[]
    NOT?: LockEventScalarWhereWithAggregatesInput | LockEventScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"LockEvent"> | string
    deviceId?: UuidWithAggregatesFilter<"LockEvent"> | string
    truckId?: UuidWithAggregatesFilter<"LockEvent"> | string
    isLock?: IntNullableWithAggregatesFilter<"LockEvent"> | number | null
    reportedAt?: DateTimeWithAggregatesFilter<"LockEvent"> | Date | string
    createdBy?: UuidNullableWithAggregatesFilter<"LockEvent"> | string | null
  }

  export type DailyRouteWhereInput = {
    AND?: DailyRouteWhereInput | DailyRouteWhereInput[]
    OR?: DailyRouteWhereInput[]
    NOT?: DailyRouteWhereInput | DailyRouteWhereInput[]
    id?: UuidFilter<"DailyRoute"> | string
    truckId?: UuidFilter<"DailyRoute"> | string
    routeDate?: DateTimeFilter<"DailyRoute"> | Date | string
    pointCount?: IntFilter<"DailyRoute"> | number
    generatedAt?: DateTimeFilter<"DailyRoute"> | Date | string
    createdBy?: UuidNullableFilter<"DailyRoute"> | string | null
    truck?: XOR<TruckRelationFilter, TruckWhereInput>
  }

  export type DailyRouteOrderByWithRelationInput = {
    id?: SortOrder
    truckId?: SortOrder
    routeDate?: SortOrder
    pointCount?: SortOrder
    generatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    truck?: TruckOrderByWithRelationInput
  }

  export type DailyRouteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    truckId_routeDate?: DailyRouteTruckIdRouteDateCompoundUniqueInput
    AND?: DailyRouteWhereInput | DailyRouteWhereInput[]
    OR?: DailyRouteWhereInput[]
    NOT?: DailyRouteWhereInput | DailyRouteWhereInput[]
    truckId?: UuidFilter<"DailyRoute"> | string
    routeDate?: DateTimeFilter<"DailyRoute"> | Date | string
    pointCount?: IntFilter<"DailyRoute"> | number
    generatedAt?: DateTimeFilter<"DailyRoute"> | Date | string
    createdBy?: UuidNullableFilter<"DailyRoute"> | string | null
    truck?: XOR<TruckRelationFilter, TruckWhereInput>
  }, "id" | "truckId_routeDate">

  export type DailyRouteOrderByWithAggregationInput = {
    id?: SortOrder
    truckId?: SortOrder
    routeDate?: SortOrder
    pointCount?: SortOrder
    generatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: DailyRouteCountOrderByAggregateInput
    _avg?: DailyRouteAvgOrderByAggregateInput
    _max?: DailyRouteMaxOrderByAggregateInput
    _min?: DailyRouteMinOrderByAggregateInput
    _sum?: DailyRouteSumOrderByAggregateInput
  }

  export type DailyRouteScalarWhereWithAggregatesInput = {
    AND?: DailyRouteScalarWhereWithAggregatesInput | DailyRouteScalarWhereWithAggregatesInput[]
    OR?: DailyRouteScalarWhereWithAggregatesInput[]
    NOT?: DailyRouteScalarWhereWithAggregatesInput | DailyRouteScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"DailyRoute"> | string
    truckId?: UuidWithAggregatesFilter<"DailyRoute"> | string
    routeDate?: DateTimeWithAggregatesFilter<"DailyRoute"> | Date | string
    pointCount?: IntWithAggregatesFilter<"DailyRoute"> | number
    generatedAt?: DateTimeWithAggregatesFilter<"DailyRoute"> | Date | string
    createdBy?: UuidNullableWithAggregatesFilter<"DailyRoute"> | string | null
  }

  export type FleetGroupCreateInput = {
    id?: string
    name: string
    site?: string | null
    description?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    trucks?: TruckCreateNestedManyWithoutFleetGroupInput
  }

  export type FleetGroupUncheckedCreateInput = {
    id?: string
    name: string
    site?: string | null
    description?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    trucks?: TruckUncheckedCreateNestedManyWithoutFleetGroupInput
  }

  export type FleetGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    site?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    trucks?: TruckUpdateManyWithoutFleetGroupNestedInput
  }

  export type FleetGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    site?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    trucks?: TruckUncheckedUpdateManyWithoutFleetGroupNestedInput
  }

  export type FleetGroupCreateManyInput = {
    id?: string
    name: string
    site?: string | null
    description?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type FleetGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    site?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FleetGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    site?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TruckCreateInput = {
    id?: string
    plateNumber: string
    vin?: string | null
    name?: string | null
    model?: string | null
    year?: number | null
    tireConfig?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    fleetGroup?: FleetGroupCreateNestedOneWithoutTrucksInput
    devices?: DeviceCreateNestedManyWithoutTruckInput
    truckStatusEvents?: TruckStatusEventCreateNestedManyWithoutTruckInput
    gpsPositions?: GpsPositionCreateNestedManyWithoutTruckInput
    trips?: TripCreateNestedManyWithoutTruckInput
    tirePressureEvents?: TirePressureEventCreateNestedManyWithoutTruckInput
    hubTemperatureEvents?: HubTemperatureEventCreateNestedManyWithoutTruckInput
    fuelLevelEvents?: FuelLevelEventCreateNestedManyWithoutTruckInput
    speedEvents?: SpeedEventCreateNestedManyWithoutTruckInput
    alertEvents?: AlertEventCreateNestedManyWithoutTruckInput
    deviceStatusEvents?: DeviceStatusEventCreateNestedManyWithoutTruckInput
    lockEvents?: LockEventCreateNestedManyWithoutTruckInput
    dailyRoutes?: DailyRouteCreateNestedManyWithoutTruckInput
  }

  export type TruckUncheckedCreateInput = {
    id?: string
    plateNumber: string
    vin?: string | null
    name?: string | null
    model?: string | null
    year?: number | null
    tireConfig?: string | null
    fleetGroupId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    devices?: DeviceUncheckedCreateNestedManyWithoutTruckInput
    truckStatusEvents?: TruckStatusEventUncheckedCreateNestedManyWithoutTruckInput
    gpsPositions?: GpsPositionUncheckedCreateNestedManyWithoutTruckInput
    trips?: TripUncheckedCreateNestedManyWithoutTruckInput
    tirePressureEvents?: TirePressureEventUncheckedCreateNestedManyWithoutTruckInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedCreateNestedManyWithoutTruckInput
    fuelLevelEvents?: FuelLevelEventUncheckedCreateNestedManyWithoutTruckInput
    speedEvents?: SpeedEventUncheckedCreateNestedManyWithoutTruckInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutTruckInput
    deviceStatusEvents?: DeviceStatusEventUncheckedCreateNestedManyWithoutTruckInput
    lockEvents?: LockEventUncheckedCreateNestedManyWithoutTruckInput
    dailyRoutes?: DailyRouteUncheckedCreateNestedManyWithoutTruckInput
  }

  export type TruckUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    fleetGroup?: FleetGroupUpdateOneWithoutTrucksNestedInput
    devices?: DeviceUpdateManyWithoutTruckNestedInput
    truckStatusEvents?: TruckStatusEventUpdateManyWithoutTruckNestedInput
    gpsPositions?: GpsPositionUpdateManyWithoutTruckNestedInput
    trips?: TripUpdateManyWithoutTruckNestedInput
    tirePressureEvents?: TirePressureEventUpdateManyWithoutTruckNestedInput
    hubTemperatureEvents?: HubTemperatureEventUpdateManyWithoutTruckNestedInput
    fuelLevelEvents?: FuelLevelEventUpdateManyWithoutTruckNestedInput
    speedEvents?: SpeedEventUpdateManyWithoutTruckNestedInput
    alertEvents?: AlertEventUpdateManyWithoutTruckNestedInput
    deviceStatusEvents?: DeviceStatusEventUpdateManyWithoutTruckNestedInput
    lockEvents?: LockEventUpdateManyWithoutTruckNestedInput
    dailyRoutes?: DailyRouteUpdateManyWithoutTruckNestedInput
  }

  export type TruckUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    fleetGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    devices?: DeviceUncheckedUpdateManyWithoutTruckNestedInput
    truckStatusEvents?: TruckStatusEventUncheckedUpdateManyWithoutTruckNestedInput
    gpsPositions?: GpsPositionUncheckedUpdateManyWithoutTruckNestedInput
    trips?: TripUncheckedUpdateManyWithoutTruckNestedInput
    tirePressureEvents?: TirePressureEventUncheckedUpdateManyWithoutTruckNestedInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedUpdateManyWithoutTruckNestedInput
    fuelLevelEvents?: FuelLevelEventUncheckedUpdateManyWithoutTruckNestedInput
    speedEvents?: SpeedEventUncheckedUpdateManyWithoutTruckNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutTruckNestedInput
    deviceStatusEvents?: DeviceStatusEventUncheckedUpdateManyWithoutTruckNestedInput
    lockEvents?: LockEventUncheckedUpdateManyWithoutTruckNestedInput
    dailyRoutes?: DailyRouteUncheckedUpdateManyWithoutTruckNestedInput
  }

  export type TruckCreateManyInput = {
    id?: string
    plateNumber: string
    vin?: string | null
    name?: string | null
    model?: string | null
    year?: number | null
    tireConfig?: string | null
    fleetGroupId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type TruckUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TruckUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    fleetGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeviceCreateInput = {
    id?: string
    sn: string
    simNumber?: string | null
    installedAt?: Date | string
    removedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    truck: TruckCreateNestedOneWithoutDevicesInput
    sensors?: SensorCreateNestedManyWithoutDeviceInput
    gpsPositions?: GpsPositionCreateNestedManyWithoutDeviceInput
    tirePressureEvents?: TirePressureEventCreateNestedManyWithoutDeviceInput
    hubTemperatureEvents?: HubTemperatureEventCreateNestedManyWithoutDeviceInput
    deviceStatusEvents?: DeviceStatusEventCreateNestedManyWithoutDeviceInput
    lockEvents?: LockEventCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateInput = {
    id?: string
    truckId: string
    sn: string
    simNumber?: string | null
    installedAt?: Date | string
    removedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    sensors?: SensorUncheckedCreateNestedManyWithoutDeviceInput
    gpsPositions?: GpsPositionUncheckedCreateNestedManyWithoutDeviceInput
    tirePressureEvents?: TirePressureEventUncheckedCreateNestedManyWithoutDeviceInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedCreateNestedManyWithoutDeviceInput
    deviceStatusEvents?: DeviceStatusEventUncheckedCreateNestedManyWithoutDeviceInput
    lockEvents?: LockEventUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sn?: StringFieldUpdateOperationsInput | string
    simNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    truck?: TruckUpdateOneRequiredWithoutDevicesNestedInput
    sensors?: SensorUpdateManyWithoutDeviceNestedInput
    gpsPositions?: GpsPositionUpdateManyWithoutDeviceNestedInput
    tirePressureEvents?: TirePressureEventUpdateManyWithoutDeviceNestedInput
    hubTemperatureEvents?: HubTemperatureEventUpdateManyWithoutDeviceNestedInput
    deviceStatusEvents?: DeviceStatusEventUpdateManyWithoutDeviceNestedInput
    lockEvents?: LockEventUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    sn?: StringFieldUpdateOperationsInput | string
    simNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sensors?: SensorUncheckedUpdateManyWithoutDeviceNestedInput
    gpsPositions?: GpsPositionUncheckedUpdateManyWithoutDeviceNestedInput
    tirePressureEvents?: TirePressureEventUncheckedUpdateManyWithoutDeviceNestedInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedUpdateManyWithoutDeviceNestedInput
    deviceStatusEvents?: DeviceStatusEventUncheckedUpdateManyWithoutDeviceNestedInput
    lockEvents?: LockEventUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceCreateManyInput = {
    id?: string
    truckId: string
    sn: string
    simNumber?: string | null
    installedAt?: Date | string
    removedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type DeviceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sn?: StringFieldUpdateOperationsInput | string
    simNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeviceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    sn?: StringFieldUpdateOperationsInput | string
    simNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SensorCreateInput = {
    id?: string
    type: string
    positionNo: number
    sn?: string | null
    installedAt?: Date | string | null
    removedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    device: DeviceCreateNestedOneWithoutSensorsInput
  }

  export type SensorUncheckedCreateInput = {
    id?: string
    deviceId: string
    type: string
    positionNo: number
    sn?: string | null
    installedAt?: Date | string | null
    removedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type SensorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    positionNo?: IntFieldUpdateOperationsInput | number
    sn?: NullableStringFieldUpdateOperationsInput | string | null
    installedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    device?: DeviceUpdateOneRequiredWithoutSensorsNestedInput
  }

  export type SensorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    positionNo?: IntFieldUpdateOperationsInput | number
    sn?: NullableStringFieldUpdateOperationsInput | string | null
    installedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SensorCreateManyInput = {
    id?: string
    deviceId: string
    type: string
    positionNo: number
    sn?: string | null
    installedAt?: Date | string | null
    removedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type SensorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    positionNo?: IntFieldUpdateOperationsInput | number
    sn?: NullableStringFieldUpdateOperationsInput | string | null
    installedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SensorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    positionNo?: IntFieldUpdateOperationsInput | number
    sn?: NullableStringFieldUpdateOperationsInput | string | null
    installedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TruckStatusEventCreateInput = {
    id?: string
    status: $Enums.TruckStatus
    note?: string | null
    changedAt?: Date | string
    createdBy?: string | null
    truck: TruckCreateNestedOneWithoutTruckStatusEventsInput
  }

  export type TruckStatusEventUncheckedCreateInput = {
    id?: string
    truckId: string
    status: $Enums.TruckStatus
    note?: string | null
    changedAt?: Date | string
    createdBy?: string | null
  }

  export type TruckStatusEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTruckStatusFieldUpdateOperationsInput | $Enums.TruckStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    truck?: TruckUpdateOneRequiredWithoutTruckStatusEventsNestedInput
  }

  export type TruckStatusEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    status?: EnumTruckStatusFieldUpdateOperationsInput | $Enums.TruckStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TruckStatusEventCreateManyInput = {
    id?: string
    truckId: string
    status: $Enums.TruckStatus
    note?: string | null
    changedAt?: Date | string
    createdBy?: string | null
  }

  export type TruckStatusEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTruckStatusFieldUpdateOperationsInput | $Enums.TruckStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TruckStatusEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    status?: EnumTruckStatusFieldUpdateOperationsInput | $Enums.TruckStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GeofenceCreateInput = {
    id?: string
    name: string
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type GeofenceUncheckedCreateInput = {
    id?: string
    name: string
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type GeofenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeofenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeofenceCreateManyInput = {
    id?: string
    name: string
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type GeofenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeofenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GpsPositionCreateInput = {
    id?: bigint | number
    ts: Date | string
    speedKph?: number | null
    headingDeg?: number | null
    hdop?: number | null
    source?: string | null
    device?: DeviceCreateNestedOneWithoutGpsPositionsInput
    truck: TruckCreateNestedOneWithoutGpsPositionsInput
  }

  export type GpsPositionUncheckedCreateInput = {
    id?: bigint | number
    deviceId?: string | null
    truckId: string
    ts: Date | string
    speedKph?: number | null
    headingDeg?: number | null
    hdop?: number | null
    source?: string | null
  }

  export type GpsPositionUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    speedKph?: NullableFloatFieldUpdateOperationsInput | number | null
    headingDeg?: NullableFloatFieldUpdateOperationsInput | number | null
    hdop?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    device?: DeviceUpdateOneWithoutGpsPositionsNestedInput
    truck?: TruckUpdateOneRequiredWithoutGpsPositionsNestedInput
  }

  export type GpsPositionUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    truckId?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    speedKph?: NullableFloatFieldUpdateOperationsInput | number | null
    headingDeg?: NullableFloatFieldUpdateOperationsInput | number | null
    hdop?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GpsPositionCreateManyInput = {
    id?: bigint | number
    deviceId?: string | null
    truckId: string
    ts: Date | string
    speedKph?: number | null
    headingDeg?: number | null
    hdop?: number | null
    source?: string | null
  }

  export type GpsPositionUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    speedKph?: NullableFloatFieldUpdateOperationsInput | number | null
    headingDeg?: NullableFloatFieldUpdateOperationsInput | number | null
    hdop?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GpsPositionUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    truckId?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    speedKph?: NullableFloatFieldUpdateOperationsInput | number | null
    headingDeg?: NullableFloatFieldUpdateOperationsInput | number | null
    hdop?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TripCreateInput = {
    id?: string
    startTs: Date | string
    endTs?: Date | string | null
    truck: TruckCreateNestedOneWithoutTripsInput
  }

  export type TripUncheckedCreateInput = {
    id?: string
    truckId: string
    startTs: Date | string
    endTs?: Date | string | null
  }

  export type TripUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truck?: TruckUpdateOneRequiredWithoutTripsNestedInput
  }

  export type TripUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripCreateManyInput = {
    id?: string
    truckId: string
    startTs: Date | string
    endTs?: Date | string | null
  }

  export type TripUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TirePressureEventCreateInput = {
    id?: string
    tireNo: number
    pressureKpa?: number | null
    tempCelsius?: number | null
    exType?: string | null
    batteryLevel?: number | null
    changedAt?: Date | string
    createdBy?: string | null
    device: DeviceCreateNestedOneWithoutTirePressureEventsInput
    truck: TruckCreateNestedOneWithoutTirePressureEventsInput
  }

  export type TirePressureEventUncheckedCreateInput = {
    id?: string
    deviceId: string
    truckId: string
    tireNo: number
    pressureKpa?: number | null
    tempCelsius?: number | null
    exType?: string | null
    batteryLevel?: number | null
    changedAt?: Date | string
    createdBy?: string | null
  }

  export type TirePressureEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tireNo?: IntFieldUpdateOperationsInput | number
    pressureKpa?: NullableFloatFieldUpdateOperationsInput | number | null
    tempCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    exType?: NullableStringFieldUpdateOperationsInput | string | null
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    device?: DeviceUpdateOneRequiredWithoutTirePressureEventsNestedInput
    truck?: TruckUpdateOneRequiredWithoutTirePressureEventsNestedInput
  }

  export type TirePressureEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    tireNo?: IntFieldUpdateOperationsInput | number
    pressureKpa?: NullableFloatFieldUpdateOperationsInput | number | null
    tempCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    exType?: NullableStringFieldUpdateOperationsInput | string | null
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TirePressureEventCreateManyInput = {
    id?: string
    deviceId: string
    truckId: string
    tireNo: number
    pressureKpa?: number | null
    tempCelsius?: number | null
    exType?: string | null
    batteryLevel?: number | null
    changedAt?: Date | string
    createdBy?: string | null
  }

  export type TirePressureEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tireNo?: IntFieldUpdateOperationsInput | number
    pressureKpa?: NullableFloatFieldUpdateOperationsInput | number | null
    tempCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    exType?: NullableStringFieldUpdateOperationsInput | string | null
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TirePressureEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    tireNo?: IntFieldUpdateOperationsInput | number
    pressureKpa?: NullableFloatFieldUpdateOperationsInput | number | null
    tempCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    exType?: NullableStringFieldUpdateOperationsInput | string | null
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TireErrorCodeCreateInput = {
    code: number
    description?: string | null
  }

  export type TireErrorCodeUncheckedCreateInput = {
    code: number
    description?: string | null
  }

  export type TireErrorCodeUpdateInput = {
    code?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TireErrorCodeUncheckedUpdateInput = {
    code?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TireErrorCodeCreateManyInput = {
    code: number
    description?: string | null
  }

  export type TireErrorCodeUpdateManyMutationInput = {
    code?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TireErrorCodeUncheckedUpdateManyInput = {
    code?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HubTemperatureEventCreateInput = {
    id?: string
    hubNo?: number | null
    tempCelsius?: number | null
    exType?: string | null
    batteryLevel?: number | null
    changedAt?: Date | string
    createdBy?: string | null
    device: DeviceCreateNestedOneWithoutHubTemperatureEventsInput
    truck: TruckCreateNestedOneWithoutHubTemperatureEventsInput
  }

  export type HubTemperatureEventUncheckedCreateInput = {
    id?: string
    deviceId: string
    truckId: string
    hubNo?: number | null
    tempCelsius?: number | null
    exType?: string | null
    batteryLevel?: number | null
    changedAt?: Date | string
    createdBy?: string | null
  }

  export type HubTemperatureEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hubNo?: NullableIntFieldUpdateOperationsInput | number | null
    tempCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    exType?: NullableStringFieldUpdateOperationsInput | string | null
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    device?: DeviceUpdateOneRequiredWithoutHubTemperatureEventsNestedInput
    truck?: TruckUpdateOneRequiredWithoutHubTemperatureEventsNestedInput
  }

  export type HubTemperatureEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    hubNo?: NullableIntFieldUpdateOperationsInput | number | null
    tempCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    exType?: NullableStringFieldUpdateOperationsInput | string | null
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HubTemperatureEventCreateManyInput = {
    id?: string
    deviceId: string
    truckId: string
    hubNo?: number | null
    tempCelsius?: number | null
    exType?: string | null
    batteryLevel?: number | null
    changedAt?: Date | string
    createdBy?: string | null
  }

  export type HubTemperatureEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hubNo?: NullableIntFieldUpdateOperationsInput | number | null
    tempCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    exType?: NullableStringFieldUpdateOperationsInput | string | null
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HubTemperatureEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    hubNo?: NullableIntFieldUpdateOperationsInput | number | null
    tempCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    exType?: NullableStringFieldUpdateOperationsInput | string | null
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FuelLevelEventCreateInput = {
    id?: string
    fuelPercent?: number | null
    changedAt: Date | string
    source?: string | null
    createdBy?: string | null
    truck: TruckCreateNestedOneWithoutFuelLevelEventsInput
  }

  export type FuelLevelEventUncheckedCreateInput = {
    id?: string
    truckId: string
    fuelPercent?: number | null
    changedAt: Date | string
    source?: string | null
    createdBy?: string | null
  }

  export type FuelLevelEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fuelPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    truck?: TruckUpdateOneRequiredWithoutFuelLevelEventsNestedInput
  }

  export type FuelLevelEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    fuelPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FuelLevelEventCreateManyInput = {
    id?: string
    truckId: string
    fuelPercent?: number | null
    changedAt: Date | string
    source?: string | null
    createdBy?: string | null
  }

  export type FuelLevelEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fuelPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FuelLevelEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    fuelPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpeedEventCreateInput = {
    id?: string
    speedKph?: number | null
    changedAt: Date | string
    source?: string | null
    createdBy?: string | null
    truck: TruckCreateNestedOneWithoutSpeedEventsInput
  }

  export type SpeedEventUncheckedCreateInput = {
    id?: string
    truckId: string
    speedKph?: number | null
    changedAt: Date | string
    source?: string | null
    createdBy?: string | null
  }

  export type SpeedEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    speedKph?: NullableFloatFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    truck?: TruckUpdateOneRequiredWithoutSpeedEventsNestedInput
  }

  export type SpeedEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    speedKph?: NullableFloatFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpeedEventCreateManyInput = {
    id?: string
    truckId: string
    speedKph?: number | null
    changedAt: Date | string
    source?: string | null
    createdBy?: string | null
  }

  export type SpeedEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    speedKph?: NullableFloatFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpeedEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    speedKph?: NullableFloatFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertEventCreateInput = {
    id?: string
    type: $Enums.AlertType
    severity?: number | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: Date | string
    acknowledged?: boolean
    createdBy?: string | null
    truck: TruckCreateNestedOneWithoutAlertEventsInput
  }

  export type AlertEventUncheckedCreateInput = {
    id?: string
    truckId: string
    type: $Enums.AlertType
    severity?: number | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: Date | string
    acknowledged?: boolean
    createdBy?: string | null
  }

  export type AlertEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    severity?: NullableIntFieldUpdateOperationsInput | number | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    truck?: TruckUpdateOneRequiredWithoutAlertEventsNestedInput
  }

  export type AlertEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    severity?: NullableIntFieldUpdateOperationsInput | number | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertEventCreateManyInput = {
    id?: string
    truckId: string
    type: $Enums.AlertType
    severity?: number | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: Date | string
    acknowledged?: boolean
    createdBy?: string | null
  }

  export type AlertEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    severity?: NullableIntFieldUpdateOperationsInput | number | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    severity?: NullableIntFieldUpdateOperationsInput | number | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeviceStatusEventCreateInput = {
    id?: string
    hostBat?: number | null
    repeater1Bat?: number | null
    repeater2Bat?: number | null
    lockState?: number | null
    reportedAt?: Date | string
    createdBy?: string | null
    device: DeviceCreateNestedOneWithoutDeviceStatusEventsInput
    truck: TruckCreateNestedOneWithoutDeviceStatusEventsInput
  }

  export type DeviceStatusEventUncheckedCreateInput = {
    id?: string
    deviceId: string
    truckId: string
    hostBat?: number | null
    repeater1Bat?: number | null
    repeater2Bat?: number | null
    lockState?: number | null
    reportedAt?: Date | string
    createdBy?: string | null
  }

  export type DeviceStatusEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hostBat?: NullableIntFieldUpdateOperationsInput | number | null
    repeater1Bat?: NullableIntFieldUpdateOperationsInput | number | null
    repeater2Bat?: NullableIntFieldUpdateOperationsInput | number | null
    lockState?: NullableIntFieldUpdateOperationsInput | number | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    device?: DeviceUpdateOneRequiredWithoutDeviceStatusEventsNestedInput
    truck?: TruckUpdateOneRequiredWithoutDeviceStatusEventsNestedInput
  }

  export type DeviceStatusEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    hostBat?: NullableIntFieldUpdateOperationsInput | number | null
    repeater1Bat?: NullableIntFieldUpdateOperationsInput | number | null
    repeater2Bat?: NullableIntFieldUpdateOperationsInput | number | null
    lockState?: NullableIntFieldUpdateOperationsInput | number | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeviceStatusEventCreateManyInput = {
    id?: string
    deviceId: string
    truckId: string
    hostBat?: number | null
    repeater1Bat?: number | null
    repeater2Bat?: number | null
    lockState?: number | null
    reportedAt?: Date | string
    createdBy?: string | null
  }

  export type DeviceStatusEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hostBat?: NullableIntFieldUpdateOperationsInput | number | null
    repeater1Bat?: NullableIntFieldUpdateOperationsInput | number | null
    repeater2Bat?: NullableIntFieldUpdateOperationsInput | number | null
    lockState?: NullableIntFieldUpdateOperationsInput | number | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeviceStatusEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    hostBat?: NullableIntFieldUpdateOperationsInput | number | null
    repeater1Bat?: NullableIntFieldUpdateOperationsInput | number | null
    repeater2Bat?: NullableIntFieldUpdateOperationsInput | number | null
    lockState?: NullableIntFieldUpdateOperationsInput | number | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LockEventCreateInput = {
    id?: string
    isLock?: number | null
    reportedAt?: Date | string
    createdBy?: string | null
    device: DeviceCreateNestedOneWithoutLockEventsInput
    truck: TruckCreateNestedOneWithoutLockEventsInput
  }

  export type LockEventUncheckedCreateInput = {
    id?: string
    deviceId: string
    truckId: string
    isLock?: number | null
    reportedAt?: Date | string
    createdBy?: string | null
  }

  export type LockEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLock?: NullableIntFieldUpdateOperationsInput | number | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    device?: DeviceUpdateOneRequiredWithoutLockEventsNestedInput
    truck?: TruckUpdateOneRequiredWithoutLockEventsNestedInput
  }

  export type LockEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    isLock?: NullableIntFieldUpdateOperationsInput | number | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LockEventCreateManyInput = {
    id?: string
    deviceId: string
    truckId: string
    isLock?: number | null
    reportedAt?: Date | string
    createdBy?: string | null
  }

  export type LockEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLock?: NullableIntFieldUpdateOperationsInput | number | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LockEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    isLock?: NullableIntFieldUpdateOperationsInput | number | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DailyRouteCreateInput = {
    id?: string
    routeDate: Date | string
    pointCount: number
    generatedAt?: Date | string
    createdBy?: string | null
    truck: TruckCreateNestedOneWithoutDailyRoutesInput
  }

  export type DailyRouteUncheckedCreateInput = {
    id?: string
    truckId: string
    routeDate: Date | string
    pointCount: number
    generatedAt?: Date | string
    createdBy?: string | null
  }

  export type DailyRouteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pointCount?: IntFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    truck?: TruckUpdateOneRequiredWithoutDailyRoutesNestedInput
  }

  export type DailyRouteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    routeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pointCount?: IntFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DailyRouteCreateManyInput = {
    id?: string
    truckId: string
    routeDate: Date | string
    pointCount: number
    generatedAt?: Date | string
    createdBy?: string | null
  }

  export type DailyRouteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pointCount?: IntFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DailyRouteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    routeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pointCount?: IntFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type TruckListRelationFilter = {
    every?: TruckWhereInput
    some?: TruckWhereInput
    none?: TruckWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TruckOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FleetGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    site?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type FleetGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    site?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type FleetGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    site?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FleetGroupNullableRelationFilter = {
    is?: FleetGroupWhereInput | null
    isNot?: FleetGroupWhereInput | null
  }

  export type DeviceListRelationFilter = {
    every?: DeviceWhereInput
    some?: DeviceWhereInput
    none?: DeviceWhereInput
  }

  export type TruckStatusEventListRelationFilter = {
    every?: TruckStatusEventWhereInput
    some?: TruckStatusEventWhereInput
    none?: TruckStatusEventWhereInput
  }

  export type GpsPositionListRelationFilter = {
    every?: GpsPositionWhereInput
    some?: GpsPositionWhereInput
    none?: GpsPositionWhereInput
  }

  export type TripListRelationFilter = {
    every?: TripWhereInput
    some?: TripWhereInput
    none?: TripWhereInput
  }

  export type TirePressureEventListRelationFilter = {
    every?: TirePressureEventWhereInput
    some?: TirePressureEventWhereInput
    none?: TirePressureEventWhereInput
  }

  export type HubTemperatureEventListRelationFilter = {
    every?: HubTemperatureEventWhereInput
    some?: HubTemperatureEventWhereInput
    none?: HubTemperatureEventWhereInput
  }

  export type FuelLevelEventListRelationFilter = {
    every?: FuelLevelEventWhereInput
    some?: FuelLevelEventWhereInput
    none?: FuelLevelEventWhereInput
  }

  export type SpeedEventListRelationFilter = {
    every?: SpeedEventWhereInput
    some?: SpeedEventWhereInput
    none?: SpeedEventWhereInput
  }

  export type AlertEventListRelationFilter = {
    every?: AlertEventWhereInput
    some?: AlertEventWhereInput
    none?: AlertEventWhereInput
  }

  export type DeviceStatusEventListRelationFilter = {
    every?: DeviceStatusEventWhereInput
    some?: DeviceStatusEventWhereInput
    none?: DeviceStatusEventWhereInput
  }

  export type LockEventListRelationFilter = {
    every?: LockEventWhereInput
    some?: LockEventWhereInput
    none?: LockEventWhereInput
  }

  export type DailyRouteListRelationFilter = {
    every?: DailyRouteWhereInput
    some?: DailyRouteWhereInput
    none?: DailyRouteWhereInput
  }

  export type DeviceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TruckStatusEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GpsPositionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TripOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TirePressureEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HubTemperatureEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FuelLevelEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpeedEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlertEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceStatusEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LockEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyRouteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TruckCountOrderByAggregateInput = {
    id?: SortOrder
    plateNumber?: SortOrder
    vin?: SortOrder
    name?: SortOrder
    model?: SortOrder
    year?: SortOrder
    tireConfig?: SortOrder
    fleetGroupId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type TruckAvgOrderByAggregateInput = {
    year?: SortOrder
  }

  export type TruckMaxOrderByAggregateInput = {
    id?: SortOrder
    plateNumber?: SortOrder
    vin?: SortOrder
    name?: SortOrder
    model?: SortOrder
    year?: SortOrder
    tireConfig?: SortOrder
    fleetGroupId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type TruckMinOrderByAggregateInput = {
    id?: SortOrder
    plateNumber?: SortOrder
    vin?: SortOrder
    name?: SortOrder
    model?: SortOrder
    year?: SortOrder
    tireConfig?: SortOrder
    fleetGroupId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type TruckSumOrderByAggregateInput = {
    year?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type TruckRelationFilter = {
    is?: TruckWhereInput
    isNot?: TruckWhereInput
  }

  export type SensorListRelationFilter = {
    every?: SensorWhereInput
    some?: SensorWhereInput
    none?: SensorWhereInput
  }

  export type SensorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceCountOrderByAggregateInput = {
    id?: SortOrder
    truckId?: SortOrder
    sn?: SortOrder
    simNumber?: SortOrder
    installedAt?: SortOrder
    removedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type DeviceMaxOrderByAggregateInput = {
    id?: SortOrder
    truckId?: SortOrder
    sn?: SortOrder
    simNumber?: SortOrder
    installedAt?: SortOrder
    removedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type DeviceMinOrderByAggregateInput = {
    id?: SortOrder
    truckId?: SortOrder
    sn?: SortOrder
    simNumber?: SortOrder
    installedAt?: SortOrder
    removedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DeviceRelationFilter = {
    is?: DeviceWhereInput
    isNot?: DeviceWhereInput
  }

  export type SensorCountOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    type?: SortOrder
    positionNo?: SortOrder
    sn?: SortOrder
    installedAt?: SortOrder
    removedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type SensorAvgOrderByAggregateInput = {
    positionNo?: SortOrder
  }

  export type SensorMaxOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    type?: SortOrder
    positionNo?: SortOrder
    sn?: SortOrder
    installedAt?: SortOrder
    removedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type SensorMinOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    type?: SortOrder
    positionNo?: SortOrder
    sn?: SortOrder
    installedAt?: SortOrder
    removedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type SensorSumOrderByAggregateInput = {
    positionNo?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumTruckStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TruckStatus | EnumTruckStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TruckStatus[] | ListEnumTruckStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TruckStatus[] | ListEnumTruckStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTruckStatusFilter<$PrismaModel> | $Enums.TruckStatus
  }

  export type TruckStatusEventCountOrderByAggregateInput = {
    id?: SortOrder
    truckId?: SortOrder
    status?: SortOrder
    note?: SortOrder
    changedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type TruckStatusEventMaxOrderByAggregateInput = {
    id?: SortOrder
    truckId?: SortOrder
    status?: SortOrder
    note?: SortOrder
    changedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type TruckStatusEventMinOrderByAggregateInput = {
    id?: SortOrder
    truckId?: SortOrder
    status?: SortOrder
    note?: SortOrder
    changedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type EnumTruckStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TruckStatus | EnumTruckStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TruckStatus[] | ListEnumTruckStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TruckStatus[] | ListEnumTruckStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTruckStatusWithAggregatesFilter<$PrismaModel> | $Enums.TruckStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTruckStatusFilter<$PrismaModel>
    _max?: NestedEnumTruckStatusFilter<$PrismaModel>
  }

  export type GeofenceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type GeofenceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type GeofenceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DeviceNullableRelationFilter = {
    is?: DeviceWhereInput | null
    isNot?: DeviceWhereInput | null
  }

  export type GpsPositionCountOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    truckId?: SortOrder
    ts?: SortOrder
    speedKph?: SortOrder
    headingDeg?: SortOrder
    hdop?: SortOrder
    source?: SortOrder
  }

  export type GpsPositionAvgOrderByAggregateInput = {
    id?: SortOrder
    speedKph?: SortOrder
    headingDeg?: SortOrder
    hdop?: SortOrder
  }

  export type GpsPositionMaxOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    truckId?: SortOrder
    ts?: SortOrder
    speedKph?: SortOrder
    headingDeg?: SortOrder
    hdop?: SortOrder
    source?: SortOrder
  }

  export type GpsPositionMinOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    truckId?: SortOrder
    ts?: SortOrder
    speedKph?: SortOrder
    headingDeg?: SortOrder
    hdop?: SortOrder
    source?: SortOrder
  }

  export type GpsPositionSumOrderByAggregateInput = {
    id?: SortOrder
    speedKph?: SortOrder
    headingDeg?: SortOrder
    hdop?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type TripCountOrderByAggregateInput = {
    id?: SortOrder
    truckId?: SortOrder
    startTs?: SortOrder
    endTs?: SortOrder
  }

  export type TripMaxOrderByAggregateInput = {
    id?: SortOrder
    truckId?: SortOrder
    startTs?: SortOrder
    endTs?: SortOrder
  }

  export type TripMinOrderByAggregateInput = {
    id?: SortOrder
    truckId?: SortOrder
    startTs?: SortOrder
    endTs?: SortOrder
  }

  export type TirePressureEventCountOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    truckId?: SortOrder
    tireNo?: SortOrder
    pressureKpa?: SortOrder
    tempCelsius?: SortOrder
    exType?: SortOrder
    batteryLevel?: SortOrder
    changedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type TirePressureEventAvgOrderByAggregateInput = {
    tireNo?: SortOrder
    pressureKpa?: SortOrder
    tempCelsius?: SortOrder
    batteryLevel?: SortOrder
  }

  export type TirePressureEventMaxOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    truckId?: SortOrder
    tireNo?: SortOrder
    pressureKpa?: SortOrder
    tempCelsius?: SortOrder
    exType?: SortOrder
    batteryLevel?: SortOrder
    changedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type TirePressureEventMinOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    truckId?: SortOrder
    tireNo?: SortOrder
    pressureKpa?: SortOrder
    tempCelsius?: SortOrder
    exType?: SortOrder
    batteryLevel?: SortOrder
    changedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type TirePressureEventSumOrderByAggregateInput = {
    tireNo?: SortOrder
    pressureKpa?: SortOrder
    tempCelsius?: SortOrder
    batteryLevel?: SortOrder
  }

  export type TireErrorCodeCountOrderByAggregateInput = {
    code?: SortOrder
    description?: SortOrder
  }

  export type TireErrorCodeAvgOrderByAggregateInput = {
    code?: SortOrder
  }

  export type TireErrorCodeMaxOrderByAggregateInput = {
    code?: SortOrder
    description?: SortOrder
  }

  export type TireErrorCodeMinOrderByAggregateInput = {
    code?: SortOrder
    description?: SortOrder
  }

  export type TireErrorCodeSumOrderByAggregateInput = {
    code?: SortOrder
  }

  export type HubTemperatureEventCountOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    truckId?: SortOrder
    hubNo?: SortOrder
    tempCelsius?: SortOrder
    exType?: SortOrder
    batteryLevel?: SortOrder
    changedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type HubTemperatureEventAvgOrderByAggregateInput = {
    hubNo?: SortOrder
    tempCelsius?: SortOrder
    batteryLevel?: SortOrder
  }

  export type HubTemperatureEventMaxOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    truckId?: SortOrder
    hubNo?: SortOrder
    tempCelsius?: SortOrder
    exType?: SortOrder
    batteryLevel?: SortOrder
    changedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type HubTemperatureEventMinOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    truckId?: SortOrder
    hubNo?: SortOrder
    tempCelsius?: SortOrder
    exType?: SortOrder
    batteryLevel?: SortOrder
    changedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type HubTemperatureEventSumOrderByAggregateInput = {
    hubNo?: SortOrder
    tempCelsius?: SortOrder
    batteryLevel?: SortOrder
  }

  export type FuelLevelEventCountOrderByAggregateInput = {
    id?: SortOrder
    truckId?: SortOrder
    fuelPercent?: SortOrder
    changedAt?: SortOrder
    source?: SortOrder
    createdBy?: SortOrder
  }

  export type FuelLevelEventAvgOrderByAggregateInput = {
    fuelPercent?: SortOrder
  }

  export type FuelLevelEventMaxOrderByAggregateInput = {
    id?: SortOrder
    truckId?: SortOrder
    fuelPercent?: SortOrder
    changedAt?: SortOrder
    source?: SortOrder
    createdBy?: SortOrder
  }

  export type FuelLevelEventMinOrderByAggregateInput = {
    id?: SortOrder
    truckId?: SortOrder
    fuelPercent?: SortOrder
    changedAt?: SortOrder
    source?: SortOrder
    createdBy?: SortOrder
  }

  export type FuelLevelEventSumOrderByAggregateInput = {
    fuelPercent?: SortOrder
  }

  export type SpeedEventCountOrderByAggregateInput = {
    id?: SortOrder
    truckId?: SortOrder
    speedKph?: SortOrder
    changedAt?: SortOrder
    source?: SortOrder
    createdBy?: SortOrder
  }

  export type SpeedEventAvgOrderByAggregateInput = {
    speedKph?: SortOrder
  }

  export type SpeedEventMaxOrderByAggregateInput = {
    id?: SortOrder
    truckId?: SortOrder
    speedKph?: SortOrder
    changedAt?: SortOrder
    source?: SortOrder
    createdBy?: SortOrder
  }

  export type SpeedEventMinOrderByAggregateInput = {
    id?: SortOrder
    truckId?: SortOrder
    speedKph?: SortOrder
    changedAt?: SortOrder
    source?: SortOrder
    createdBy?: SortOrder
  }

  export type SpeedEventSumOrderByAggregateInput = {
    speedKph?: SortOrder
  }

  export type EnumAlertTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertTypeFilter<$PrismaModel> | $Enums.AlertType
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AlertEventCountOrderByAggregateInput = {
    id?: SortOrder
    truckId?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    detail?: SortOrder
    occurredAt?: SortOrder
    acknowledged?: SortOrder
    createdBy?: SortOrder
  }

  export type AlertEventAvgOrderByAggregateInput = {
    severity?: SortOrder
  }

  export type AlertEventMaxOrderByAggregateInput = {
    id?: SortOrder
    truckId?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    occurredAt?: SortOrder
    acknowledged?: SortOrder
    createdBy?: SortOrder
  }

  export type AlertEventMinOrderByAggregateInput = {
    id?: SortOrder
    truckId?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    occurredAt?: SortOrder
    acknowledged?: SortOrder
    createdBy?: SortOrder
  }

  export type AlertEventSumOrderByAggregateInput = {
    severity?: SortOrder
  }

  export type EnumAlertTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertTypeWithAggregatesFilter<$PrismaModel> | $Enums.AlertType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertTypeFilter<$PrismaModel>
    _max?: NestedEnumAlertTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DeviceStatusEventCountOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    truckId?: SortOrder
    hostBat?: SortOrder
    repeater1Bat?: SortOrder
    repeater2Bat?: SortOrder
    lockState?: SortOrder
    reportedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type DeviceStatusEventAvgOrderByAggregateInput = {
    hostBat?: SortOrder
    repeater1Bat?: SortOrder
    repeater2Bat?: SortOrder
    lockState?: SortOrder
  }

  export type DeviceStatusEventMaxOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    truckId?: SortOrder
    hostBat?: SortOrder
    repeater1Bat?: SortOrder
    repeater2Bat?: SortOrder
    lockState?: SortOrder
    reportedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type DeviceStatusEventMinOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    truckId?: SortOrder
    hostBat?: SortOrder
    repeater1Bat?: SortOrder
    repeater2Bat?: SortOrder
    lockState?: SortOrder
    reportedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type DeviceStatusEventSumOrderByAggregateInput = {
    hostBat?: SortOrder
    repeater1Bat?: SortOrder
    repeater2Bat?: SortOrder
    lockState?: SortOrder
  }

  export type LockEventCountOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    truckId?: SortOrder
    isLock?: SortOrder
    reportedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type LockEventAvgOrderByAggregateInput = {
    isLock?: SortOrder
  }

  export type LockEventMaxOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    truckId?: SortOrder
    isLock?: SortOrder
    reportedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type LockEventMinOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    truckId?: SortOrder
    isLock?: SortOrder
    reportedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type LockEventSumOrderByAggregateInput = {
    isLock?: SortOrder
  }

  export type DailyRouteTruckIdRouteDateCompoundUniqueInput = {
    truckId: string
    routeDate: Date | string
  }

  export type DailyRouteCountOrderByAggregateInput = {
    id?: SortOrder
    truckId?: SortOrder
    routeDate?: SortOrder
    pointCount?: SortOrder
    generatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type DailyRouteAvgOrderByAggregateInput = {
    pointCount?: SortOrder
  }

  export type DailyRouteMaxOrderByAggregateInput = {
    id?: SortOrder
    truckId?: SortOrder
    routeDate?: SortOrder
    pointCount?: SortOrder
    generatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type DailyRouteMinOrderByAggregateInput = {
    id?: SortOrder
    truckId?: SortOrder
    routeDate?: SortOrder
    pointCount?: SortOrder
    generatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type DailyRouteSumOrderByAggregateInput = {
    pointCount?: SortOrder
  }

  export type TruckCreateNestedManyWithoutFleetGroupInput = {
    create?: XOR<TruckCreateWithoutFleetGroupInput, TruckUncheckedCreateWithoutFleetGroupInput> | TruckCreateWithoutFleetGroupInput[] | TruckUncheckedCreateWithoutFleetGroupInput[]
    connectOrCreate?: TruckCreateOrConnectWithoutFleetGroupInput | TruckCreateOrConnectWithoutFleetGroupInput[]
    createMany?: TruckCreateManyFleetGroupInputEnvelope
    connect?: TruckWhereUniqueInput | TruckWhereUniqueInput[]
  }

  export type TruckUncheckedCreateNestedManyWithoutFleetGroupInput = {
    create?: XOR<TruckCreateWithoutFleetGroupInput, TruckUncheckedCreateWithoutFleetGroupInput> | TruckCreateWithoutFleetGroupInput[] | TruckUncheckedCreateWithoutFleetGroupInput[]
    connectOrCreate?: TruckCreateOrConnectWithoutFleetGroupInput | TruckCreateOrConnectWithoutFleetGroupInput[]
    createMany?: TruckCreateManyFleetGroupInputEnvelope
    connect?: TruckWhereUniqueInput | TruckWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type TruckUpdateManyWithoutFleetGroupNestedInput = {
    create?: XOR<TruckCreateWithoutFleetGroupInput, TruckUncheckedCreateWithoutFleetGroupInput> | TruckCreateWithoutFleetGroupInput[] | TruckUncheckedCreateWithoutFleetGroupInput[]
    connectOrCreate?: TruckCreateOrConnectWithoutFleetGroupInput | TruckCreateOrConnectWithoutFleetGroupInput[]
    upsert?: TruckUpsertWithWhereUniqueWithoutFleetGroupInput | TruckUpsertWithWhereUniqueWithoutFleetGroupInput[]
    createMany?: TruckCreateManyFleetGroupInputEnvelope
    set?: TruckWhereUniqueInput | TruckWhereUniqueInput[]
    disconnect?: TruckWhereUniqueInput | TruckWhereUniqueInput[]
    delete?: TruckWhereUniqueInput | TruckWhereUniqueInput[]
    connect?: TruckWhereUniqueInput | TruckWhereUniqueInput[]
    update?: TruckUpdateWithWhereUniqueWithoutFleetGroupInput | TruckUpdateWithWhereUniqueWithoutFleetGroupInput[]
    updateMany?: TruckUpdateManyWithWhereWithoutFleetGroupInput | TruckUpdateManyWithWhereWithoutFleetGroupInput[]
    deleteMany?: TruckScalarWhereInput | TruckScalarWhereInput[]
  }

  export type TruckUncheckedUpdateManyWithoutFleetGroupNestedInput = {
    create?: XOR<TruckCreateWithoutFleetGroupInput, TruckUncheckedCreateWithoutFleetGroupInput> | TruckCreateWithoutFleetGroupInput[] | TruckUncheckedCreateWithoutFleetGroupInput[]
    connectOrCreate?: TruckCreateOrConnectWithoutFleetGroupInput | TruckCreateOrConnectWithoutFleetGroupInput[]
    upsert?: TruckUpsertWithWhereUniqueWithoutFleetGroupInput | TruckUpsertWithWhereUniqueWithoutFleetGroupInput[]
    createMany?: TruckCreateManyFleetGroupInputEnvelope
    set?: TruckWhereUniqueInput | TruckWhereUniqueInput[]
    disconnect?: TruckWhereUniqueInput | TruckWhereUniqueInput[]
    delete?: TruckWhereUniqueInput | TruckWhereUniqueInput[]
    connect?: TruckWhereUniqueInput | TruckWhereUniqueInput[]
    update?: TruckUpdateWithWhereUniqueWithoutFleetGroupInput | TruckUpdateWithWhereUniqueWithoutFleetGroupInput[]
    updateMany?: TruckUpdateManyWithWhereWithoutFleetGroupInput | TruckUpdateManyWithWhereWithoutFleetGroupInput[]
    deleteMany?: TruckScalarWhereInput | TruckScalarWhereInput[]
  }

  export type FleetGroupCreateNestedOneWithoutTrucksInput = {
    create?: XOR<FleetGroupCreateWithoutTrucksInput, FleetGroupUncheckedCreateWithoutTrucksInput>
    connectOrCreate?: FleetGroupCreateOrConnectWithoutTrucksInput
    connect?: FleetGroupWhereUniqueInput
  }

  export type DeviceCreateNestedManyWithoutTruckInput = {
    create?: XOR<DeviceCreateWithoutTruckInput, DeviceUncheckedCreateWithoutTruckInput> | DeviceCreateWithoutTruckInput[] | DeviceUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutTruckInput | DeviceCreateOrConnectWithoutTruckInput[]
    createMany?: DeviceCreateManyTruckInputEnvelope
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
  }

  export type TruckStatusEventCreateNestedManyWithoutTruckInput = {
    create?: XOR<TruckStatusEventCreateWithoutTruckInput, TruckStatusEventUncheckedCreateWithoutTruckInput> | TruckStatusEventCreateWithoutTruckInput[] | TruckStatusEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: TruckStatusEventCreateOrConnectWithoutTruckInput | TruckStatusEventCreateOrConnectWithoutTruckInput[]
    createMany?: TruckStatusEventCreateManyTruckInputEnvelope
    connect?: TruckStatusEventWhereUniqueInput | TruckStatusEventWhereUniqueInput[]
  }

  export type GpsPositionCreateNestedManyWithoutTruckInput = {
    create?: XOR<GpsPositionCreateWithoutTruckInput, GpsPositionUncheckedCreateWithoutTruckInput> | GpsPositionCreateWithoutTruckInput[] | GpsPositionUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: GpsPositionCreateOrConnectWithoutTruckInput | GpsPositionCreateOrConnectWithoutTruckInput[]
    createMany?: GpsPositionCreateManyTruckInputEnvelope
    connect?: GpsPositionWhereUniqueInput | GpsPositionWhereUniqueInput[]
  }

  export type TripCreateNestedManyWithoutTruckInput = {
    create?: XOR<TripCreateWithoutTruckInput, TripUncheckedCreateWithoutTruckInput> | TripCreateWithoutTruckInput[] | TripUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: TripCreateOrConnectWithoutTruckInput | TripCreateOrConnectWithoutTruckInput[]
    createMany?: TripCreateManyTruckInputEnvelope
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
  }

  export type TirePressureEventCreateNestedManyWithoutTruckInput = {
    create?: XOR<TirePressureEventCreateWithoutTruckInput, TirePressureEventUncheckedCreateWithoutTruckInput> | TirePressureEventCreateWithoutTruckInput[] | TirePressureEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: TirePressureEventCreateOrConnectWithoutTruckInput | TirePressureEventCreateOrConnectWithoutTruckInput[]
    createMany?: TirePressureEventCreateManyTruckInputEnvelope
    connect?: TirePressureEventWhereUniqueInput | TirePressureEventWhereUniqueInput[]
  }

  export type HubTemperatureEventCreateNestedManyWithoutTruckInput = {
    create?: XOR<HubTemperatureEventCreateWithoutTruckInput, HubTemperatureEventUncheckedCreateWithoutTruckInput> | HubTemperatureEventCreateWithoutTruckInput[] | HubTemperatureEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: HubTemperatureEventCreateOrConnectWithoutTruckInput | HubTemperatureEventCreateOrConnectWithoutTruckInput[]
    createMany?: HubTemperatureEventCreateManyTruckInputEnvelope
    connect?: HubTemperatureEventWhereUniqueInput | HubTemperatureEventWhereUniqueInput[]
  }

  export type FuelLevelEventCreateNestedManyWithoutTruckInput = {
    create?: XOR<FuelLevelEventCreateWithoutTruckInput, FuelLevelEventUncheckedCreateWithoutTruckInput> | FuelLevelEventCreateWithoutTruckInput[] | FuelLevelEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: FuelLevelEventCreateOrConnectWithoutTruckInput | FuelLevelEventCreateOrConnectWithoutTruckInput[]
    createMany?: FuelLevelEventCreateManyTruckInputEnvelope
    connect?: FuelLevelEventWhereUniqueInput | FuelLevelEventWhereUniqueInput[]
  }

  export type SpeedEventCreateNestedManyWithoutTruckInput = {
    create?: XOR<SpeedEventCreateWithoutTruckInput, SpeedEventUncheckedCreateWithoutTruckInput> | SpeedEventCreateWithoutTruckInput[] | SpeedEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: SpeedEventCreateOrConnectWithoutTruckInput | SpeedEventCreateOrConnectWithoutTruckInput[]
    createMany?: SpeedEventCreateManyTruckInputEnvelope
    connect?: SpeedEventWhereUniqueInput | SpeedEventWhereUniqueInput[]
  }

  export type AlertEventCreateNestedManyWithoutTruckInput = {
    create?: XOR<AlertEventCreateWithoutTruckInput, AlertEventUncheckedCreateWithoutTruckInput> | AlertEventCreateWithoutTruckInput[] | AlertEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: AlertEventCreateOrConnectWithoutTruckInput | AlertEventCreateOrConnectWithoutTruckInput[]
    createMany?: AlertEventCreateManyTruckInputEnvelope
    connect?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
  }

  export type DeviceStatusEventCreateNestedManyWithoutTruckInput = {
    create?: XOR<DeviceStatusEventCreateWithoutTruckInput, DeviceStatusEventUncheckedCreateWithoutTruckInput> | DeviceStatusEventCreateWithoutTruckInput[] | DeviceStatusEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: DeviceStatusEventCreateOrConnectWithoutTruckInput | DeviceStatusEventCreateOrConnectWithoutTruckInput[]
    createMany?: DeviceStatusEventCreateManyTruckInputEnvelope
    connect?: DeviceStatusEventWhereUniqueInput | DeviceStatusEventWhereUniqueInput[]
  }

  export type LockEventCreateNestedManyWithoutTruckInput = {
    create?: XOR<LockEventCreateWithoutTruckInput, LockEventUncheckedCreateWithoutTruckInput> | LockEventCreateWithoutTruckInput[] | LockEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: LockEventCreateOrConnectWithoutTruckInput | LockEventCreateOrConnectWithoutTruckInput[]
    createMany?: LockEventCreateManyTruckInputEnvelope
    connect?: LockEventWhereUniqueInput | LockEventWhereUniqueInput[]
  }

  export type DailyRouteCreateNestedManyWithoutTruckInput = {
    create?: XOR<DailyRouteCreateWithoutTruckInput, DailyRouteUncheckedCreateWithoutTruckInput> | DailyRouteCreateWithoutTruckInput[] | DailyRouteUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: DailyRouteCreateOrConnectWithoutTruckInput | DailyRouteCreateOrConnectWithoutTruckInput[]
    createMany?: DailyRouteCreateManyTruckInputEnvelope
    connect?: DailyRouteWhereUniqueInput | DailyRouteWhereUniqueInput[]
  }

  export type DeviceUncheckedCreateNestedManyWithoutTruckInput = {
    create?: XOR<DeviceCreateWithoutTruckInput, DeviceUncheckedCreateWithoutTruckInput> | DeviceCreateWithoutTruckInput[] | DeviceUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutTruckInput | DeviceCreateOrConnectWithoutTruckInput[]
    createMany?: DeviceCreateManyTruckInputEnvelope
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
  }

  export type TruckStatusEventUncheckedCreateNestedManyWithoutTruckInput = {
    create?: XOR<TruckStatusEventCreateWithoutTruckInput, TruckStatusEventUncheckedCreateWithoutTruckInput> | TruckStatusEventCreateWithoutTruckInput[] | TruckStatusEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: TruckStatusEventCreateOrConnectWithoutTruckInput | TruckStatusEventCreateOrConnectWithoutTruckInput[]
    createMany?: TruckStatusEventCreateManyTruckInputEnvelope
    connect?: TruckStatusEventWhereUniqueInput | TruckStatusEventWhereUniqueInput[]
  }

  export type GpsPositionUncheckedCreateNestedManyWithoutTruckInput = {
    create?: XOR<GpsPositionCreateWithoutTruckInput, GpsPositionUncheckedCreateWithoutTruckInput> | GpsPositionCreateWithoutTruckInput[] | GpsPositionUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: GpsPositionCreateOrConnectWithoutTruckInput | GpsPositionCreateOrConnectWithoutTruckInput[]
    createMany?: GpsPositionCreateManyTruckInputEnvelope
    connect?: GpsPositionWhereUniqueInput | GpsPositionWhereUniqueInput[]
  }

  export type TripUncheckedCreateNestedManyWithoutTruckInput = {
    create?: XOR<TripCreateWithoutTruckInput, TripUncheckedCreateWithoutTruckInput> | TripCreateWithoutTruckInput[] | TripUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: TripCreateOrConnectWithoutTruckInput | TripCreateOrConnectWithoutTruckInput[]
    createMany?: TripCreateManyTruckInputEnvelope
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
  }

  export type TirePressureEventUncheckedCreateNestedManyWithoutTruckInput = {
    create?: XOR<TirePressureEventCreateWithoutTruckInput, TirePressureEventUncheckedCreateWithoutTruckInput> | TirePressureEventCreateWithoutTruckInput[] | TirePressureEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: TirePressureEventCreateOrConnectWithoutTruckInput | TirePressureEventCreateOrConnectWithoutTruckInput[]
    createMany?: TirePressureEventCreateManyTruckInputEnvelope
    connect?: TirePressureEventWhereUniqueInput | TirePressureEventWhereUniqueInput[]
  }

  export type HubTemperatureEventUncheckedCreateNestedManyWithoutTruckInput = {
    create?: XOR<HubTemperatureEventCreateWithoutTruckInput, HubTemperatureEventUncheckedCreateWithoutTruckInput> | HubTemperatureEventCreateWithoutTruckInput[] | HubTemperatureEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: HubTemperatureEventCreateOrConnectWithoutTruckInput | HubTemperatureEventCreateOrConnectWithoutTruckInput[]
    createMany?: HubTemperatureEventCreateManyTruckInputEnvelope
    connect?: HubTemperatureEventWhereUniqueInput | HubTemperatureEventWhereUniqueInput[]
  }

  export type FuelLevelEventUncheckedCreateNestedManyWithoutTruckInput = {
    create?: XOR<FuelLevelEventCreateWithoutTruckInput, FuelLevelEventUncheckedCreateWithoutTruckInput> | FuelLevelEventCreateWithoutTruckInput[] | FuelLevelEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: FuelLevelEventCreateOrConnectWithoutTruckInput | FuelLevelEventCreateOrConnectWithoutTruckInput[]
    createMany?: FuelLevelEventCreateManyTruckInputEnvelope
    connect?: FuelLevelEventWhereUniqueInput | FuelLevelEventWhereUniqueInput[]
  }

  export type SpeedEventUncheckedCreateNestedManyWithoutTruckInput = {
    create?: XOR<SpeedEventCreateWithoutTruckInput, SpeedEventUncheckedCreateWithoutTruckInput> | SpeedEventCreateWithoutTruckInput[] | SpeedEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: SpeedEventCreateOrConnectWithoutTruckInput | SpeedEventCreateOrConnectWithoutTruckInput[]
    createMany?: SpeedEventCreateManyTruckInputEnvelope
    connect?: SpeedEventWhereUniqueInput | SpeedEventWhereUniqueInput[]
  }

  export type AlertEventUncheckedCreateNestedManyWithoutTruckInput = {
    create?: XOR<AlertEventCreateWithoutTruckInput, AlertEventUncheckedCreateWithoutTruckInput> | AlertEventCreateWithoutTruckInput[] | AlertEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: AlertEventCreateOrConnectWithoutTruckInput | AlertEventCreateOrConnectWithoutTruckInput[]
    createMany?: AlertEventCreateManyTruckInputEnvelope
    connect?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
  }

  export type DeviceStatusEventUncheckedCreateNestedManyWithoutTruckInput = {
    create?: XOR<DeviceStatusEventCreateWithoutTruckInput, DeviceStatusEventUncheckedCreateWithoutTruckInput> | DeviceStatusEventCreateWithoutTruckInput[] | DeviceStatusEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: DeviceStatusEventCreateOrConnectWithoutTruckInput | DeviceStatusEventCreateOrConnectWithoutTruckInput[]
    createMany?: DeviceStatusEventCreateManyTruckInputEnvelope
    connect?: DeviceStatusEventWhereUniqueInput | DeviceStatusEventWhereUniqueInput[]
  }

  export type LockEventUncheckedCreateNestedManyWithoutTruckInput = {
    create?: XOR<LockEventCreateWithoutTruckInput, LockEventUncheckedCreateWithoutTruckInput> | LockEventCreateWithoutTruckInput[] | LockEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: LockEventCreateOrConnectWithoutTruckInput | LockEventCreateOrConnectWithoutTruckInput[]
    createMany?: LockEventCreateManyTruckInputEnvelope
    connect?: LockEventWhereUniqueInput | LockEventWhereUniqueInput[]
  }

  export type DailyRouteUncheckedCreateNestedManyWithoutTruckInput = {
    create?: XOR<DailyRouteCreateWithoutTruckInput, DailyRouteUncheckedCreateWithoutTruckInput> | DailyRouteCreateWithoutTruckInput[] | DailyRouteUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: DailyRouteCreateOrConnectWithoutTruckInput | DailyRouteCreateOrConnectWithoutTruckInput[]
    createMany?: DailyRouteCreateManyTruckInputEnvelope
    connect?: DailyRouteWhereUniqueInput | DailyRouteWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FleetGroupUpdateOneWithoutTrucksNestedInput = {
    create?: XOR<FleetGroupCreateWithoutTrucksInput, FleetGroupUncheckedCreateWithoutTrucksInput>
    connectOrCreate?: FleetGroupCreateOrConnectWithoutTrucksInput
    upsert?: FleetGroupUpsertWithoutTrucksInput
    disconnect?: FleetGroupWhereInput | boolean
    delete?: FleetGroupWhereInput | boolean
    connect?: FleetGroupWhereUniqueInput
    update?: XOR<XOR<FleetGroupUpdateToOneWithWhereWithoutTrucksInput, FleetGroupUpdateWithoutTrucksInput>, FleetGroupUncheckedUpdateWithoutTrucksInput>
  }

  export type DeviceUpdateManyWithoutTruckNestedInput = {
    create?: XOR<DeviceCreateWithoutTruckInput, DeviceUncheckedCreateWithoutTruckInput> | DeviceCreateWithoutTruckInput[] | DeviceUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutTruckInput | DeviceCreateOrConnectWithoutTruckInput[]
    upsert?: DeviceUpsertWithWhereUniqueWithoutTruckInput | DeviceUpsertWithWhereUniqueWithoutTruckInput[]
    createMany?: DeviceCreateManyTruckInputEnvelope
    set?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    disconnect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    delete?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    update?: DeviceUpdateWithWhereUniqueWithoutTruckInput | DeviceUpdateWithWhereUniqueWithoutTruckInput[]
    updateMany?: DeviceUpdateManyWithWhereWithoutTruckInput | DeviceUpdateManyWithWhereWithoutTruckInput[]
    deleteMany?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
  }

  export type TruckStatusEventUpdateManyWithoutTruckNestedInput = {
    create?: XOR<TruckStatusEventCreateWithoutTruckInput, TruckStatusEventUncheckedCreateWithoutTruckInput> | TruckStatusEventCreateWithoutTruckInput[] | TruckStatusEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: TruckStatusEventCreateOrConnectWithoutTruckInput | TruckStatusEventCreateOrConnectWithoutTruckInput[]
    upsert?: TruckStatusEventUpsertWithWhereUniqueWithoutTruckInput | TruckStatusEventUpsertWithWhereUniqueWithoutTruckInput[]
    createMany?: TruckStatusEventCreateManyTruckInputEnvelope
    set?: TruckStatusEventWhereUniqueInput | TruckStatusEventWhereUniqueInput[]
    disconnect?: TruckStatusEventWhereUniqueInput | TruckStatusEventWhereUniqueInput[]
    delete?: TruckStatusEventWhereUniqueInput | TruckStatusEventWhereUniqueInput[]
    connect?: TruckStatusEventWhereUniqueInput | TruckStatusEventWhereUniqueInput[]
    update?: TruckStatusEventUpdateWithWhereUniqueWithoutTruckInput | TruckStatusEventUpdateWithWhereUniqueWithoutTruckInput[]
    updateMany?: TruckStatusEventUpdateManyWithWhereWithoutTruckInput | TruckStatusEventUpdateManyWithWhereWithoutTruckInput[]
    deleteMany?: TruckStatusEventScalarWhereInput | TruckStatusEventScalarWhereInput[]
  }

  export type GpsPositionUpdateManyWithoutTruckNestedInput = {
    create?: XOR<GpsPositionCreateWithoutTruckInput, GpsPositionUncheckedCreateWithoutTruckInput> | GpsPositionCreateWithoutTruckInput[] | GpsPositionUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: GpsPositionCreateOrConnectWithoutTruckInput | GpsPositionCreateOrConnectWithoutTruckInput[]
    upsert?: GpsPositionUpsertWithWhereUniqueWithoutTruckInput | GpsPositionUpsertWithWhereUniqueWithoutTruckInput[]
    createMany?: GpsPositionCreateManyTruckInputEnvelope
    set?: GpsPositionWhereUniqueInput | GpsPositionWhereUniqueInput[]
    disconnect?: GpsPositionWhereUniqueInput | GpsPositionWhereUniqueInput[]
    delete?: GpsPositionWhereUniqueInput | GpsPositionWhereUniqueInput[]
    connect?: GpsPositionWhereUniqueInput | GpsPositionWhereUniqueInput[]
    update?: GpsPositionUpdateWithWhereUniqueWithoutTruckInput | GpsPositionUpdateWithWhereUniqueWithoutTruckInput[]
    updateMany?: GpsPositionUpdateManyWithWhereWithoutTruckInput | GpsPositionUpdateManyWithWhereWithoutTruckInput[]
    deleteMany?: GpsPositionScalarWhereInput | GpsPositionScalarWhereInput[]
  }

  export type TripUpdateManyWithoutTruckNestedInput = {
    create?: XOR<TripCreateWithoutTruckInput, TripUncheckedCreateWithoutTruckInput> | TripCreateWithoutTruckInput[] | TripUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: TripCreateOrConnectWithoutTruckInput | TripCreateOrConnectWithoutTruckInput[]
    upsert?: TripUpsertWithWhereUniqueWithoutTruckInput | TripUpsertWithWhereUniqueWithoutTruckInput[]
    createMany?: TripCreateManyTruckInputEnvelope
    set?: TripWhereUniqueInput | TripWhereUniqueInput[]
    disconnect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    delete?: TripWhereUniqueInput | TripWhereUniqueInput[]
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    update?: TripUpdateWithWhereUniqueWithoutTruckInput | TripUpdateWithWhereUniqueWithoutTruckInput[]
    updateMany?: TripUpdateManyWithWhereWithoutTruckInput | TripUpdateManyWithWhereWithoutTruckInput[]
    deleteMany?: TripScalarWhereInput | TripScalarWhereInput[]
  }

  export type TirePressureEventUpdateManyWithoutTruckNestedInput = {
    create?: XOR<TirePressureEventCreateWithoutTruckInput, TirePressureEventUncheckedCreateWithoutTruckInput> | TirePressureEventCreateWithoutTruckInput[] | TirePressureEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: TirePressureEventCreateOrConnectWithoutTruckInput | TirePressureEventCreateOrConnectWithoutTruckInput[]
    upsert?: TirePressureEventUpsertWithWhereUniqueWithoutTruckInput | TirePressureEventUpsertWithWhereUniqueWithoutTruckInput[]
    createMany?: TirePressureEventCreateManyTruckInputEnvelope
    set?: TirePressureEventWhereUniqueInput | TirePressureEventWhereUniqueInput[]
    disconnect?: TirePressureEventWhereUniqueInput | TirePressureEventWhereUniqueInput[]
    delete?: TirePressureEventWhereUniqueInput | TirePressureEventWhereUniqueInput[]
    connect?: TirePressureEventWhereUniqueInput | TirePressureEventWhereUniqueInput[]
    update?: TirePressureEventUpdateWithWhereUniqueWithoutTruckInput | TirePressureEventUpdateWithWhereUniqueWithoutTruckInput[]
    updateMany?: TirePressureEventUpdateManyWithWhereWithoutTruckInput | TirePressureEventUpdateManyWithWhereWithoutTruckInput[]
    deleteMany?: TirePressureEventScalarWhereInput | TirePressureEventScalarWhereInput[]
  }

  export type HubTemperatureEventUpdateManyWithoutTruckNestedInput = {
    create?: XOR<HubTemperatureEventCreateWithoutTruckInput, HubTemperatureEventUncheckedCreateWithoutTruckInput> | HubTemperatureEventCreateWithoutTruckInput[] | HubTemperatureEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: HubTemperatureEventCreateOrConnectWithoutTruckInput | HubTemperatureEventCreateOrConnectWithoutTruckInput[]
    upsert?: HubTemperatureEventUpsertWithWhereUniqueWithoutTruckInput | HubTemperatureEventUpsertWithWhereUniqueWithoutTruckInput[]
    createMany?: HubTemperatureEventCreateManyTruckInputEnvelope
    set?: HubTemperatureEventWhereUniqueInput | HubTemperatureEventWhereUniqueInput[]
    disconnect?: HubTemperatureEventWhereUniqueInput | HubTemperatureEventWhereUniqueInput[]
    delete?: HubTemperatureEventWhereUniqueInput | HubTemperatureEventWhereUniqueInput[]
    connect?: HubTemperatureEventWhereUniqueInput | HubTemperatureEventWhereUniqueInput[]
    update?: HubTemperatureEventUpdateWithWhereUniqueWithoutTruckInput | HubTemperatureEventUpdateWithWhereUniqueWithoutTruckInput[]
    updateMany?: HubTemperatureEventUpdateManyWithWhereWithoutTruckInput | HubTemperatureEventUpdateManyWithWhereWithoutTruckInput[]
    deleteMany?: HubTemperatureEventScalarWhereInput | HubTemperatureEventScalarWhereInput[]
  }

  export type FuelLevelEventUpdateManyWithoutTruckNestedInput = {
    create?: XOR<FuelLevelEventCreateWithoutTruckInput, FuelLevelEventUncheckedCreateWithoutTruckInput> | FuelLevelEventCreateWithoutTruckInput[] | FuelLevelEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: FuelLevelEventCreateOrConnectWithoutTruckInput | FuelLevelEventCreateOrConnectWithoutTruckInput[]
    upsert?: FuelLevelEventUpsertWithWhereUniqueWithoutTruckInput | FuelLevelEventUpsertWithWhereUniqueWithoutTruckInput[]
    createMany?: FuelLevelEventCreateManyTruckInputEnvelope
    set?: FuelLevelEventWhereUniqueInput | FuelLevelEventWhereUniqueInput[]
    disconnect?: FuelLevelEventWhereUniqueInput | FuelLevelEventWhereUniqueInput[]
    delete?: FuelLevelEventWhereUniqueInput | FuelLevelEventWhereUniqueInput[]
    connect?: FuelLevelEventWhereUniqueInput | FuelLevelEventWhereUniqueInput[]
    update?: FuelLevelEventUpdateWithWhereUniqueWithoutTruckInput | FuelLevelEventUpdateWithWhereUniqueWithoutTruckInput[]
    updateMany?: FuelLevelEventUpdateManyWithWhereWithoutTruckInput | FuelLevelEventUpdateManyWithWhereWithoutTruckInput[]
    deleteMany?: FuelLevelEventScalarWhereInput | FuelLevelEventScalarWhereInput[]
  }

  export type SpeedEventUpdateManyWithoutTruckNestedInput = {
    create?: XOR<SpeedEventCreateWithoutTruckInput, SpeedEventUncheckedCreateWithoutTruckInput> | SpeedEventCreateWithoutTruckInput[] | SpeedEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: SpeedEventCreateOrConnectWithoutTruckInput | SpeedEventCreateOrConnectWithoutTruckInput[]
    upsert?: SpeedEventUpsertWithWhereUniqueWithoutTruckInput | SpeedEventUpsertWithWhereUniqueWithoutTruckInput[]
    createMany?: SpeedEventCreateManyTruckInputEnvelope
    set?: SpeedEventWhereUniqueInput | SpeedEventWhereUniqueInput[]
    disconnect?: SpeedEventWhereUniqueInput | SpeedEventWhereUniqueInput[]
    delete?: SpeedEventWhereUniqueInput | SpeedEventWhereUniqueInput[]
    connect?: SpeedEventWhereUniqueInput | SpeedEventWhereUniqueInput[]
    update?: SpeedEventUpdateWithWhereUniqueWithoutTruckInput | SpeedEventUpdateWithWhereUniqueWithoutTruckInput[]
    updateMany?: SpeedEventUpdateManyWithWhereWithoutTruckInput | SpeedEventUpdateManyWithWhereWithoutTruckInput[]
    deleteMany?: SpeedEventScalarWhereInput | SpeedEventScalarWhereInput[]
  }

  export type AlertEventUpdateManyWithoutTruckNestedInput = {
    create?: XOR<AlertEventCreateWithoutTruckInput, AlertEventUncheckedCreateWithoutTruckInput> | AlertEventCreateWithoutTruckInput[] | AlertEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: AlertEventCreateOrConnectWithoutTruckInput | AlertEventCreateOrConnectWithoutTruckInput[]
    upsert?: AlertEventUpsertWithWhereUniqueWithoutTruckInput | AlertEventUpsertWithWhereUniqueWithoutTruckInput[]
    createMany?: AlertEventCreateManyTruckInputEnvelope
    set?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    disconnect?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    delete?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    connect?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    update?: AlertEventUpdateWithWhereUniqueWithoutTruckInput | AlertEventUpdateWithWhereUniqueWithoutTruckInput[]
    updateMany?: AlertEventUpdateManyWithWhereWithoutTruckInput | AlertEventUpdateManyWithWhereWithoutTruckInput[]
    deleteMany?: AlertEventScalarWhereInput | AlertEventScalarWhereInput[]
  }

  export type DeviceStatusEventUpdateManyWithoutTruckNestedInput = {
    create?: XOR<DeviceStatusEventCreateWithoutTruckInput, DeviceStatusEventUncheckedCreateWithoutTruckInput> | DeviceStatusEventCreateWithoutTruckInput[] | DeviceStatusEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: DeviceStatusEventCreateOrConnectWithoutTruckInput | DeviceStatusEventCreateOrConnectWithoutTruckInput[]
    upsert?: DeviceStatusEventUpsertWithWhereUniqueWithoutTruckInput | DeviceStatusEventUpsertWithWhereUniqueWithoutTruckInput[]
    createMany?: DeviceStatusEventCreateManyTruckInputEnvelope
    set?: DeviceStatusEventWhereUniqueInput | DeviceStatusEventWhereUniqueInput[]
    disconnect?: DeviceStatusEventWhereUniqueInput | DeviceStatusEventWhereUniqueInput[]
    delete?: DeviceStatusEventWhereUniqueInput | DeviceStatusEventWhereUniqueInput[]
    connect?: DeviceStatusEventWhereUniqueInput | DeviceStatusEventWhereUniqueInput[]
    update?: DeviceStatusEventUpdateWithWhereUniqueWithoutTruckInput | DeviceStatusEventUpdateWithWhereUniqueWithoutTruckInput[]
    updateMany?: DeviceStatusEventUpdateManyWithWhereWithoutTruckInput | DeviceStatusEventUpdateManyWithWhereWithoutTruckInput[]
    deleteMany?: DeviceStatusEventScalarWhereInput | DeviceStatusEventScalarWhereInput[]
  }

  export type LockEventUpdateManyWithoutTruckNestedInput = {
    create?: XOR<LockEventCreateWithoutTruckInput, LockEventUncheckedCreateWithoutTruckInput> | LockEventCreateWithoutTruckInput[] | LockEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: LockEventCreateOrConnectWithoutTruckInput | LockEventCreateOrConnectWithoutTruckInput[]
    upsert?: LockEventUpsertWithWhereUniqueWithoutTruckInput | LockEventUpsertWithWhereUniqueWithoutTruckInput[]
    createMany?: LockEventCreateManyTruckInputEnvelope
    set?: LockEventWhereUniqueInput | LockEventWhereUniqueInput[]
    disconnect?: LockEventWhereUniqueInput | LockEventWhereUniqueInput[]
    delete?: LockEventWhereUniqueInput | LockEventWhereUniqueInput[]
    connect?: LockEventWhereUniqueInput | LockEventWhereUniqueInput[]
    update?: LockEventUpdateWithWhereUniqueWithoutTruckInput | LockEventUpdateWithWhereUniqueWithoutTruckInput[]
    updateMany?: LockEventUpdateManyWithWhereWithoutTruckInput | LockEventUpdateManyWithWhereWithoutTruckInput[]
    deleteMany?: LockEventScalarWhereInput | LockEventScalarWhereInput[]
  }

  export type DailyRouteUpdateManyWithoutTruckNestedInput = {
    create?: XOR<DailyRouteCreateWithoutTruckInput, DailyRouteUncheckedCreateWithoutTruckInput> | DailyRouteCreateWithoutTruckInput[] | DailyRouteUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: DailyRouteCreateOrConnectWithoutTruckInput | DailyRouteCreateOrConnectWithoutTruckInput[]
    upsert?: DailyRouteUpsertWithWhereUniqueWithoutTruckInput | DailyRouteUpsertWithWhereUniqueWithoutTruckInput[]
    createMany?: DailyRouteCreateManyTruckInputEnvelope
    set?: DailyRouteWhereUniqueInput | DailyRouteWhereUniqueInput[]
    disconnect?: DailyRouteWhereUniqueInput | DailyRouteWhereUniqueInput[]
    delete?: DailyRouteWhereUniqueInput | DailyRouteWhereUniqueInput[]
    connect?: DailyRouteWhereUniqueInput | DailyRouteWhereUniqueInput[]
    update?: DailyRouteUpdateWithWhereUniqueWithoutTruckInput | DailyRouteUpdateWithWhereUniqueWithoutTruckInput[]
    updateMany?: DailyRouteUpdateManyWithWhereWithoutTruckInput | DailyRouteUpdateManyWithWhereWithoutTruckInput[]
    deleteMany?: DailyRouteScalarWhereInput | DailyRouteScalarWhereInput[]
  }

  export type DeviceUncheckedUpdateManyWithoutTruckNestedInput = {
    create?: XOR<DeviceCreateWithoutTruckInput, DeviceUncheckedCreateWithoutTruckInput> | DeviceCreateWithoutTruckInput[] | DeviceUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutTruckInput | DeviceCreateOrConnectWithoutTruckInput[]
    upsert?: DeviceUpsertWithWhereUniqueWithoutTruckInput | DeviceUpsertWithWhereUniqueWithoutTruckInput[]
    createMany?: DeviceCreateManyTruckInputEnvelope
    set?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    disconnect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    delete?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    update?: DeviceUpdateWithWhereUniqueWithoutTruckInput | DeviceUpdateWithWhereUniqueWithoutTruckInput[]
    updateMany?: DeviceUpdateManyWithWhereWithoutTruckInput | DeviceUpdateManyWithWhereWithoutTruckInput[]
    deleteMany?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
  }

  export type TruckStatusEventUncheckedUpdateManyWithoutTruckNestedInput = {
    create?: XOR<TruckStatusEventCreateWithoutTruckInput, TruckStatusEventUncheckedCreateWithoutTruckInput> | TruckStatusEventCreateWithoutTruckInput[] | TruckStatusEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: TruckStatusEventCreateOrConnectWithoutTruckInput | TruckStatusEventCreateOrConnectWithoutTruckInput[]
    upsert?: TruckStatusEventUpsertWithWhereUniqueWithoutTruckInput | TruckStatusEventUpsertWithWhereUniqueWithoutTruckInput[]
    createMany?: TruckStatusEventCreateManyTruckInputEnvelope
    set?: TruckStatusEventWhereUniqueInput | TruckStatusEventWhereUniqueInput[]
    disconnect?: TruckStatusEventWhereUniqueInput | TruckStatusEventWhereUniqueInput[]
    delete?: TruckStatusEventWhereUniqueInput | TruckStatusEventWhereUniqueInput[]
    connect?: TruckStatusEventWhereUniqueInput | TruckStatusEventWhereUniqueInput[]
    update?: TruckStatusEventUpdateWithWhereUniqueWithoutTruckInput | TruckStatusEventUpdateWithWhereUniqueWithoutTruckInput[]
    updateMany?: TruckStatusEventUpdateManyWithWhereWithoutTruckInput | TruckStatusEventUpdateManyWithWhereWithoutTruckInput[]
    deleteMany?: TruckStatusEventScalarWhereInput | TruckStatusEventScalarWhereInput[]
  }

  export type GpsPositionUncheckedUpdateManyWithoutTruckNestedInput = {
    create?: XOR<GpsPositionCreateWithoutTruckInput, GpsPositionUncheckedCreateWithoutTruckInput> | GpsPositionCreateWithoutTruckInput[] | GpsPositionUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: GpsPositionCreateOrConnectWithoutTruckInput | GpsPositionCreateOrConnectWithoutTruckInput[]
    upsert?: GpsPositionUpsertWithWhereUniqueWithoutTruckInput | GpsPositionUpsertWithWhereUniqueWithoutTruckInput[]
    createMany?: GpsPositionCreateManyTruckInputEnvelope
    set?: GpsPositionWhereUniqueInput | GpsPositionWhereUniqueInput[]
    disconnect?: GpsPositionWhereUniqueInput | GpsPositionWhereUniqueInput[]
    delete?: GpsPositionWhereUniqueInput | GpsPositionWhereUniqueInput[]
    connect?: GpsPositionWhereUniqueInput | GpsPositionWhereUniqueInput[]
    update?: GpsPositionUpdateWithWhereUniqueWithoutTruckInput | GpsPositionUpdateWithWhereUniqueWithoutTruckInput[]
    updateMany?: GpsPositionUpdateManyWithWhereWithoutTruckInput | GpsPositionUpdateManyWithWhereWithoutTruckInput[]
    deleteMany?: GpsPositionScalarWhereInput | GpsPositionScalarWhereInput[]
  }

  export type TripUncheckedUpdateManyWithoutTruckNestedInput = {
    create?: XOR<TripCreateWithoutTruckInput, TripUncheckedCreateWithoutTruckInput> | TripCreateWithoutTruckInput[] | TripUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: TripCreateOrConnectWithoutTruckInput | TripCreateOrConnectWithoutTruckInput[]
    upsert?: TripUpsertWithWhereUniqueWithoutTruckInput | TripUpsertWithWhereUniqueWithoutTruckInput[]
    createMany?: TripCreateManyTruckInputEnvelope
    set?: TripWhereUniqueInput | TripWhereUniqueInput[]
    disconnect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    delete?: TripWhereUniqueInput | TripWhereUniqueInput[]
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    update?: TripUpdateWithWhereUniqueWithoutTruckInput | TripUpdateWithWhereUniqueWithoutTruckInput[]
    updateMany?: TripUpdateManyWithWhereWithoutTruckInput | TripUpdateManyWithWhereWithoutTruckInput[]
    deleteMany?: TripScalarWhereInput | TripScalarWhereInput[]
  }

  export type TirePressureEventUncheckedUpdateManyWithoutTruckNestedInput = {
    create?: XOR<TirePressureEventCreateWithoutTruckInput, TirePressureEventUncheckedCreateWithoutTruckInput> | TirePressureEventCreateWithoutTruckInput[] | TirePressureEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: TirePressureEventCreateOrConnectWithoutTruckInput | TirePressureEventCreateOrConnectWithoutTruckInput[]
    upsert?: TirePressureEventUpsertWithWhereUniqueWithoutTruckInput | TirePressureEventUpsertWithWhereUniqueWithoutTruckInput[]
    createMany?: TirePressureEventCreateManyTruckInputEnvelope
    set?: TirePressureEventWhereUniqueInput | TirePressureEventWhereUniqueInput[]
    disconnect?: TirePressureEventWhereUniqueInput | TirePressureEventWhereUniqueInput[]
    delete?: TirePressureEventWhereUniqueInput | TirePressureEventWhereUniqueInput[]
    connect?: TirePressureEventWhereUniqueInput | TirePressureEventWhereUniqueInput[]
    update?: TirePressureEventUpdateWithWhereUniqueWithoutTruckInput | TirePressureEventUpdateWithWhereUniqueWithoutTruckInput[]
    updateMany?: TirePressureEventUpdateManyWithWhereWithoutTruckInput | TirePressureEventUpdateManyWithWhereWithoutTruckInput[]
    deleteMany?: TirePressureEventScalarWhereInput | TirePressureEventScalarWhereInput[]
  }

  export type HubTemperatureEventUncheckedUpdateManyWithoutTruckNestedInput = {
    create?: XOR<HubTemperatureEventCreateWithoutTruckInput, HubTemperatureEventUncheckedCreateWithoutTruckInput> | HubTemperatureEventCreateWithoutTruckInput[] | HubTemperatureEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: HubTemperatureEventCreateOrConnectWithoutTruckInput | HubTemperatureEventCreateOrConnectWithoutTruckInput[]
    upsert?: HubTemperatureEventUpsertWithWhereUniqueWithoutTruckInput | HubTemperatureEventUpsertWithWhereUniqueWithoutTruckInput[]
    createMany?: HubTemperatureEventCreateManyTruckInputEnvelope
    set?: HubTemperatureEventWhereUniqueInput | HubTemperatureEventWhereUniqueInput[]
    disconnect?: HubTemperatureEventWhereUniqueInput | HubTemperatureEventWhereUniqueInput[]
    delete?: HubTemperatureEventWhereUniqueInput | HubTemperatureEventWhereUniqueInput[]
    connect?: HubTemperatureEventWhereUniqueInput | HubTemperatureEventWhereUniqueInput[]
    update?: HubTemperatureEventUpdateWithWhereUniqueWithoutTruckInput | HubTemperatureEventUpdateWithWhereUniqueWithoutTruckInput[]
    updateMany?: HubTemperatureEventUpdateManyWithWhereWithoutTruckInput | HubTemperatureEventUpdateManyWithWhereWithoutTruckInput[]
    deleteMany?: HubTemperatureEventScalarWhereInput | HubTemperatureEventScalarWhereInput[]
  }

  export type FuelLevelEventUncheckedUpdateManyWithoutTruckNestedInput = {
    create?: XOR<FuelLevelEventCreateWithoutTruckInput, FuelLevelEventUncheckedCreateWithoutTruckInput> | FuelLevelEventCreateWithoutTruckInput[] | FuelLevelEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: FuelLevelEventCreateOrConnectWithoutTruckInput | FuelLevelEventCreateOrConnectWithoutTruckInput[]
    upsert?: FuelLevelEventUpsertWithWhereUniqueWithoutTruckInput | FuelLevelEventUpsertWithWhereUniqueWithoutTruckInput[]
    createMany?: FuelLevelEventCreateManyTruckInputEnvelope
    set?: FuelLevelEventWhereUniqueInput | FuelLevelEventWhereUniqueInput[]
    disconnect?: FuelLevelEventWhereUniqueInput | FuelLevelEventWhereUniqueInput[]
    delete?: FuelLevelEventWhereUniqueInput | FuelLevelEventWhereUniqueInput[]
    connect?: FuelLevelEventWhereUniqueInput | FuelLevelEventWhereUniqueInput[]
    update?: FuelLevelEventUpdateWithWhereUniqueWithoutTruckInput | FuelLevelEventUpdateWithWhereUniqueWithoutTruckInput[]
    updateMany?: FuelLevelEventUpdateManyWithWhereWithoutTruckInput | FuelLevelEventUpdateManyWithWhereWithoutTruckInput[]
    deleteMany?: FuelLevelEventScalarWhereInput | FuelLevelEventScalarWhereInput[]
  }

  export type SpeedEventUncheckedUpdateManyWithoutTruckNestedInput = {
    create?: XOR<SpeedEventCreateWithoutTruckInput, SpeedEventUncheckedCreateWithoutTruckInput> | SpeedEventCreateWithoutTruckInput[] | SpeedEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: SpeedEventCreateOrConnectWithoutTruckInput | SpeedEventCreateOrConnectWithoutTruckInput[]
    upsert?: SpeedEventUpsertWithWhereUniqueWithoutTruckInput | SpeedEventUpsertWithWhereUniqueWithoutTruckInput[]
    createMany?: SpeedEventCreateManyTruckInputEnvelope
    set?: SpeedEventWhereUniqueInput | SpeedEventWhereUniqueInput[]
    disconnect?: SpeedEventWhereUniqueInput | SpeedEventWhereUniqueInput[]
    delete?: SpeedEventWhereUniqueInput | SpeedEventWhereUniqueInput[]
    connect?: SpeedEventWhereUniqueInput | SpeedEventWhereUniqueInput[]
    update?: SpeedEventUpdateWithWhereUniqueWithoutTruckInput | SpeedEventUpdateWithWhereUniqueWithoutTruckInput[]
    updateMany?: SpeedEventUpdateManyWithWhereWithoutTruckInput | SpeedEventUpdateManyWithWhereWithoutTruckInput[]
    deleteMany?: SpeedEventScalarWhereInput | SpeedEventScalarWhereInput[]
  }

  export type AlertEventUncheckedUpdateManyWithoutTruckNestedInput = {
    create?: XOR<AlertEventCreateWithoutTruckInput, AlertEventUncheckedCreateWithoutTruckInput> | AlertEventCreateWithoutTruckInput[] | AlertEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: AlertEventCreateOrConnectWithoutTruckInput | AlertEventCreateOrConnectWithoutTruckInput[]
    upsert?: AlertEventUpsertWithWhereUniqueWithoutTruckInput | AlertEventUpsertWithWhereUniqueWithoutTruckInput[]
    createMany?: AlertEventCreateManyTruckInputEnvelope
    set?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    disconnect?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    delete?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    connect?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    update?: AlertEventUpdateWithWhereUniqueWithoutTruckInput | AlertEventUpdateWithWhereUniqueWithoutTruckInput[]
    updateMany?: AlertEventUpdateManyWithWhereWithoutTruckInput | AlertEventUpdateManyWithWhereWithoutTruckInput[]
    deleteMany?: AlertEventScalarWhereInput | AlertEventScalarWhereInput[]
  }

  export type DeviceStatusEventUncheckedUpdateManyWithoutTruckNestedInput = {
    create?: XOR<DeviceStatusEventCreateWithoutTruckInput, DeviceStatusEventUncheckedCreateWithoutTruckInput> | DeviceStatusEventCreateWithoutTruckInput[] | DeviceStatusEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: DeviceStatusEventCreateOrConnectWithoutTruckInput | DeviceStatusEventCreateOrConnectWithoutTruckInput[]
    upsert?: DeviceStatusEventUpsertWithWhereUniqueWithoutTruckInput | DeviceStatusEventUpsertWithWhereUniqueWithoutTruckInput[]
    createMany?: DeviceStatusEventCreateManyTruckInputEnvelope
    set?: DeviceStatusEventWhereUniqueInput | DeviceStatusEventWhereUniqueInput[]
    disconnect?: DeviceStatusEventWhereUniqueInput | DeviceStatusEventWhereUniqueInput[]
    delete?: DeviceStatusEventWhereUniqueInput | DeviceStatusEventWhereUniqueInput[]
    connect?: DeviceStatusEventWhereUniqueInput | DeviceStatusEventWhereUniqueInput[]
    update?: DeviceStatusEventUpdateWithWhereUniqueWithoutTruckInput | DeviceStatusEventUpdateWithWhereUniqueWithoutTruckInput[]
    updateMany?: DeviceStatusEventUpdateManyWithWhereWithoutTruckInput | DeviceStatusEventUpdateManyWithWhereWithoutTruckInput[]
    deleteMany?: DeviceStatusEventScalarWhereInput | DeviceStatusEventScalarWhereInput[]
  }

  export type LockEventUncheckedUpdateManyWithoutTruckNestedInput = {
    create?: XOR<LockEventCreateWithoutTruckInput, LockEventUncheckedCreateWithoutTruckInput> | LockEventCreateWithoutTruckInput[] | LockEventUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: LockEventCreateOrConnectWithoutTruckInput | LockEventCreateOrConnectWithoutTruckInput[]
    upsert?: LockEventUpsertWithWhereUniqueWithoutTruckInput | LockEventUpsertWithWhereUniqueWithoutTruckInput[]
    createMany?: LockEventCreateManyTruckInputEnvelope
    set?: LockEventWhereUniqueInput | LockEventWhereUniqueInput[]
    disconnect?: LockEventWhereUniqueInput | LockEventWhereUniqueInput[]
    delete?: LockEventWhereUniqueInput | LockEventWhereUniqueInput[]
    connect?: LockEventWhereUniqueInput | LockEventWhereUniqueInput[]
    update?: LockEventUpdateWithWhereUniqueWithoutTruckInput | LockEventUpdateWithWhereUniqueWithoutTruckInput[]
    updateMany?: LockEventUpdateManyWithWhereWithoutTruckInput | LockEventUpdateManyWithWhereWithoutTruckInput[]
    deleteMany?: LockEventScalarWhereInput | LockEventScalarWhereInput[]
  }

  export type DailyRouteUncheckedUpdateManyWithoutTruckNestedInput = {
    create?: XOR<DailyRouteCreateWithoutTruckInput, DailyRouteUncheckedCreateWithoutTruckInput> | DailyRouteCreateWithoutTruckInput[] | DailyRouteUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: DailyRouteCreateOrConnectWithoutTruckInput | DailyRouteCreateOrConnectWithoutTruckInput[]
    upsert?: DailyRouteUpsertWithWhereUniqueWithoutTruckInput | DailyRouteUpsertWithWhereUniqueWithoutTruckInput[]
    createMany?: DailyRouteCreateManyTruckInputEnvelope
    set?: DailyRouteWhereUniqueInput | DailyRouteWhereUniqueInput[]
    disconnect?: DailyRouteWhereUniqueInput | DailyRouteWhereUniqueInput[]
    delete?: DailyRouteWhereUniqueInput | DailyRouteWhereUniqueInput[]
    connect?: DailyRouteWhereUniqueInput | DailyRouteWhereUniqueInput[]
    update?: DailyRouteUpdateWithWhereUniqueWithoutTruckInput | DailyRouteUpdateWithWhereUniqueWithoutTruckInput[]
    updateMany?: DailyRouteUpdateManyWithWhereWithoutTruckInput | DailyRouteUpdateManyWithWhereWithoutTruckInput[]
    deleteMany?: DailyRouteScalarWhereInput | DailyRouteScalarWhereInput[]
  }

  export type TruckCreateNestedOneWithoutDevicesInput = {
    create?: XOR<TruckCreateWithoutDevicesInput, TruckUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: TruckCreateOrConnectWithoutDevicesInput
    connect?: TruckWhereUniqueInput
  }

  export type SensorCreateNestedManyWithoutDeviceInput = {
    create?: XOR<SensorCreateWithoutDeviceInput, SensorUncheckedCreateWithoutDeviceInput> | SensorCreateWithoutDeviceInput[] | SensorUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: SensorCreateOrConnectWithoutDeviceInput | SensorCreateOrConnectWithoutDeviceInput[]
    createMany?: SensorCreateManyDeviceInputEnvelope
    connect?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
  }

  export type GpsPositionCreateNestedManyWithoutDeviceInput = {
    create?: XOR<GpsPositionCreateWithoutDeviceInput, GpsPositionUncheckedCreateWithoutDeviceInput> | GpsPositionCreateWithoutDeviceInput[] | GpsPositionUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: GpsPositionCreateOrConnectWithoutDeviceInput | GpsPositionCreateOrConnectWithoutDeviceInput[]
    createMany?: GpsPositionCreateManyDeviceInputEnvelope
    connect?: GpsPositionWhereUniqueInput | GpsPositionWhereUniqueInput[]
  }

  export type TirePressureEventCreateNestedManyWithoutDeviceInput = {
    create?: XOR<TirePressureEventCreateWithoutDeviceInput, TirePressureEventUncheckedCreateWithoutDeviceInput> | TirePressureEventCreateWithoutDeviceInput[] | TirePressureEventUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: TirePressureEventCreateOrConnectWithoutDeviceInput | TirePressureEventCreateOrConnectWithoutDeviceInput[]
    createMany?: TirePressureEventCreateManyDeviceInputEnvelope
    connect?: TirePressureEventWhereUniqueInput | TirePressureEventWhereUniqueInput[]
  }

  export type HubTemperatureEventCreateNestedManyWithoutDeviceInput = {
    create?: XOR<HubTemperatureEventCreateWithoutDeviceInput, HubTemperatureEventUncheckedCreateWithoutDeviceInput> | HubTemperatureEventCreateWithoutDeviceInput[] | HubTemperatureEventUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: HubTemperatureEventCreateOrConnectWithoutDeviceInput | HubTemperatureEventCreateOrConnectWithoutDeviceInput[]
    createMany?: HubTemperatureEventCreateManyDeviceInputEnvelope
    connect?: HubTemperatureEventWhereUniqueInput | HubTemperatureEventWhereUniqueInput[]
  }

  export type DeviceStatusEventCreateNestedManyWithoutDeviceInput = {
    create?: XOR<DeviceStatusEventCreateWithoutDeviceInput, DeviceStatusEventUncheckedCreateWithoutDeviceInput> | DeviceStatusEventCreateWithoutDeviceInput[] | DeviceStatusEventUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DeviceStatusEventCreateOrConnectWithoutDeviceInput | DeviceStatusEventCreateOrConnectWithoutDeviceInput[]
    createMany?: DeviceStatusEventCreateManyDeviceInputEnvelope
    connect?: DeviceStatusEventWhereUniqueInput | DeviceStatusEventWhereUniqueInput[]
  }

  export type LockEventCreateNestedManyWithoutDeviceInput = {
    create?: XOR<LockEventCreateWithoutDeviceInput, LockEventUncheckedCreateWithoutDeviceInput> | LockEventCreateWithoutDeviceInput[] | LockEventUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: LockEventCreateOrConnectWithoutDeviceInput | LockEventCreateOrConnectWithoutDeviceInput[]
    createMany?: LockEventCreateManyDeviceInputEnvelope
    connect?: LockEventWhereUniqueInput | LockEventWhereUniqueInput[]
  }

  export type SensorUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<SensorCreateWithoutDeviceInput, SensorUncheckedCreateWithoutDeviceInput> | SensorCreateWithoutDeviceInput[] | SensorUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: SensorCreateOrConnectWithoutDeviceInput | SensorCreateOrConnectWithoutDeviceInput[]
    createMany?: SensorCreateManyDeviceInputEnvelope
    connect?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
  }

  export type GpsPositionUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<GpsPositionCreateWithoutDeviceInput, GpsPositionUncheckedCreateWithoutDeviceInput> | GpsPositionCreateWithoutDeviceInput[] | GpsPositionUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: GpsPositionCreateOrConnectWithoutDeviceInput | GpsPositionCreateOrConnectWithoutDeviceInput[]
    createMany?: GpsPositionCreateManyDeviceInputEnvelope
    connect?: GpsPositionWhereUniqueInput | GpsPositionWhereUniqueInput[]
  }

  export type TirePressureEventUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<TirePressureEventCreateWithoutDeviceInput, TirePressureEventUncheckedCreateWithoutDeviceInput> | TirePressureEventCreateWithoutDeviceInput[] | TirePressureEventUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: TirePressureEventCreateOrConnectWithoutDeviceInput | TirePressureEventCreateOrConnectWithoutDeviceInput[]
    createMany?: TirePressureEventCreateManyDeviceInputEnvelope
    connect?: TirePressureEventWhereUniqueInput | TirePressureEventWhereUniqueInput[]
  }

  export type HubTemperatureEventUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<HubTemperatureEventCreateWithoutDeviceInput, HubTemperatureEventUncheckedCreateWithoutDeviceInput> | HubTemperatureEventCreateWithoutDeviceInput[] | HubTemperatureEventUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: HubTemperatureEventCreateOrConnectWithoutDeviceInput | HubTemperatureEventCreateOrConnectWithoutDeviceInput[]
    createMany?: HubTemperatureEventCreateManyDeviceInputEnvelope
    connect?: HubTemperatureEventWhereUniqueInput | HubTemperatureEventWhereUniqueInput[]
  }

  export type DeviceStatusEventUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<DeviceStatusEventCreateWithoutDeviceInput, DeviceStatusEventUncheckedCreateWithoutDeviceInput> | DeviceStatusEventCreateWithoutDeviceInput[] | DeviceStatusEventUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DeviceStatusEventCreateOrConnectWithoutDeviceInput | DeviceStatusEventCreateOrConnectWithoutDeviceInput[]
    createMany?: DeviceStatusEventCreateManyDeviceInputEnvelope
    connect?: DeviceStatusEventWhereUniqueInput | DeviceStatusEventWhereUniqueInput[]
  }

  export type LockEventUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<LockEventCreateWithoutDeviceInput, LockEventUncheckedCreateWithoutDeviceInput> | LockEventCreateWithoutDeviceInput[] | LockEventUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: LockEventCreateOrConnectWithoutDeviceInput | LockEventCreateOrConnectWithoutDeviceInput[]
    createMany?: LockEventCreateManyDeviceInputEnvelope
    connect?: LockEventWhereUniqueInput | LockEventWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type TruckUpdateOneRequiredWithoutDevicesNestedInput = {
    create?: XOR<TruckCreateWithoutDevicesInput, TruckUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: TruckCreateOrConnectWithoutDevicesInput
    upsert?: TruckUpsertWithoutDevicesInput
    connect?: TruckWhereUniqueInput
    update?: XOR<XOR<TruckUpdateToOneWithWhereWithoutDevicesInput, TruckUpdateWithoutDevicesInput>, TruckUncheckedUpdateWithoutDevicesInput>
  }

  export type SensorUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<SensorCreateWithoutDeviceInput, SensorUncheckedCreateWithoutDeviceInput> | SensorCreateWithoutDeviceInput[] | SensorUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: SensorCreateOrConnectWithoutDeviceInput | SensorCreateOrConnectWithoutDeviceInput[]
    upsert?: SensorUpsertWithWhereUniqueWithoutDeviceInput | SensorUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: SensorCreateManyDeviceInputEnvelope
    set?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    disconnect?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    delete?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    connect?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    update?: SensorUpdateWithWhereUniqueWithoutDeviceInput | SensorUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: SensorUpdateManyWithWhereWithoutDeviceInput | SensorUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: SensorScalarWhereInput | SensorScalarWhereInput[]
  }

  export type GpsPositionUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<GpsPositionCreateWithoutDeviceInput, GpsPositionUncheckedCreateWithoutDeviceInput> | GpsPositionCreateWithoutDeviceInput[] | GpsPositionUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: GpsPositionCreateOrConnectWithoutDeviceInput | GpsPositionCreateOrConnectWithoutDeviceInput[]
    upsert?: GpsPositionUpsertWithWhereUniqueWithoutDeviceInput | GpsPositionUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: GpsPositionCreateManyDeviceInputEnvelope
    set?: GpsPositionWhereUniqueInput | GpsPositionWhereUniqueInput[]
    disconnect?: GpsPositionWhereUniqueInput | GpsPositionWhereUniqueInput[]
    delete?: GpsPositionWhereUniqueInput | GpsPositionWhereUniqueInput[]
    connect?: GpsPositionWhereUniqueInput | GpsPositionWhereUniqueInput[]
    update?: GpsPositionUpdateWithWhereUniqueWithoutDeviceInput | GpsPositionUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: GpsPositionUpdateManyWithWhereWithoutDeviceInput | GpsPositionUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: GpsPositionScalarWhereInput | GpsPositionScalarWhereInput[]
  }

  export type TirePressureEventUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<TirePressureEventCreateWithoutDeviceInput, TirePressureEventUncheckedCreateWithoutDeviceInput> | TirePressureEventCreateWithoutDeviceInput[] | TirePressureEventUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: TirePressureEventCreateOrConnectWithoutDeviceInput | TirePressureEventCreateOrConnectWithoutDeviceInput[]
    upsert?: TirePressureEventUpsertWithWhereUniqueWithoutDeviceInput | TirePressureEventUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: TirePressureEventCreateManyDeviceInputEnvelope
    set?: TirePressureEventWhereUniqueInput | TirePressureEventWhereUniqueInput[]
    disconnect?: TirePressureEventWhereUniqueInput | TirePressureEventWhereUniqueInput[]
    delete?: TirePressureEventWhereUniqueInput | TirePressureEventWhereUniqueInput[]
    connect?: TirePressureEventWhereUniqueInput | TirePressureEventWhereUniqueInput[]
    update?: TirePressureEventUpdateWithWhereUniqueWithoutDeviceInput | TirePressureEventUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: TirePressureEventUpdateManyWithWhereWithoutDeviceInput | TirePressureEventUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: TirePressureEventScalarWhereInput | TirePressureEventScalarWhereInput[]
  }

  export type HubTemperatureEventUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<HubTemperatureEventCreateWithoutDeviceInput, HubTemperatureEventUncheckedCreateWithoutDeviceInput> | HubTemperatureEventCreateWithoutDeviceInput[] | HubTemperatureEventUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: HubTemperatureEventCreateOrConnectWithoutDeviceInput | HubTemperatureEventCreateOrConnectWithoutDeviceInput[]
    upsert?: HubTemperatureEventUpsertWithWhereUniqueWithoutDeviceInput | HubTemperatureEventUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: HubTemperatureEventCreateManyDeviceInputEnvelope
    set?: HubTemperatureEventWhereUniqueInput | HubTemperatureEventWhereUniqueInput[]
    disconnect?: HubTemperatureEventWhereUniqueInput | HubTemperatureEventWhereUniqueInput[]
    delete?: HubTemperatureEventWhereUniqueInput | HubTemperatureEventWhereUniqueInput[]
    connect?: HubTemperatureEventWhereUniqueInput | HubTemperatureEventWhereUniqueInput[]
    update?: HubTemperatureEventUpdateWithWhereUniqueWithoutDeviceInput | HubTemperatureEventUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: HubTemperatureEventUpdateManyWithWhereWithoutDeviceInput | HubTemperatureEventUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: HubTemperatureEventScalarWhereInput | HubTemperatureEventScalarWhereInput[]
  }

  export type DeviceStatusEventUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<DeviceStatusEventCreateWithoutDeviceInput, DeviceStatusEventUncheckedCreateWithoutDeviceInput> | DeviceStatusEventCreateWithoutDeviceInput[] | DeviceStatusEventUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DeviceStatusEventCreateOrConnectWithoutDeviceInput | DeviceStatusEventCreateOrConnectWithoutDeviceInput[]
    upsert?: DeviceStatusEventUpsertWithWhereUniqueWithoutDeviceInput | DeviceStatusEventUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: DeviceStatusEventCreateManyDeviceInputEnvelope
    set?: DeviceStatusEventWhereUniqueInput | DeviceStatusEventWhereUniqueInput[]
    disconnect?: DeviceStatusEventWhereUniqueInput | DeviceStatusEventWhereUniqueInput[]
    delete?: DeviceStatusEventWhereUniqueInput | DeviceStatusEventWhereUniqueInput[]
    connect?: DeviceStatusEventWhereUniqueInput | DeviceStatusEventWhereUniqueInput[]
    update?: DeviceStatusEventUpdateWithWhereUniqueWithoutDeviceInput | DeviceStatusEventUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: DeviceStatusEventUpdateManyWithWhereWithoutDeviceInput | DeviceStatusEventUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: DeviceStatusEventScalarWhereInput | DeviceStatusEventScalarWhereInput[]
  }

  export type LockEventUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<LockEventCreateWithoutDeviceInput, LockEventUncheckedCreateWithoutDeviceInput> | LockEventCreateWithoutDeviceInput[] | LockEventUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: LockEventCreateOrConnectWithoutDeviceInput | LockEventCreateOrConnectWithoutDeviceInput[]
    upsert?: LockEventUpsertWithWhereUniqueWithoutDeviceInput | LockEventUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: LockEventCreateManyDeviceInputEnvelope
    set?: LockEventWhereUniqueInput | LockEventWhereUniqueInput[]
    disconnect?: LockEventWhereUniqueInput | LockEventWhereUniqueInput[]
    delete?: LockEventWhereUniqueInput | LockEventWhereUniqueInput[]
    connect?: LockEventWhereUniqueInput | LockEventWhereUniqueInput[]
    update?: LockEventUpdateWithWhereUniqueWithoutDeviceInput | LockEventUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: LockEventUpdateManyWithWhereWithoutDeviceInput | LockEventUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: LockEventScalarWhereInput | LockEventScalarWhereInput[]
  }

  export type SensorUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<SensorCreateWithoutDeviceInput, SensorUncheckedCreateWithoutDeviceInput> | SensorCreateWithoutDeviceInput[] | SensorUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: SensorCreateOrConnectWithoutDeviceInput | SensorCreateOrConnectWithoutDeviceInput[]
    upsert?: SensorUpsertWithWhereUniqueWithoutDeviceInput | SensorUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: SensorCreateManyDeviceInputEnvelope
    set?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    disconnect?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    delete?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    connect?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    update?: SensorUpdateWithWhereUniqueWithoutDeviceInput | SensorUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: SensorUpdateManyWithWhereWithoutDeviceInput | SensorUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: SensorScalarWhereInput | SensorScalarWhereInput[]
  }

  export type GpsPositionUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<GpsPositionCreateWithoutDeviceInput, GpsPositionUncheckedCreateWithoutDeviceInput> | GpsPositionCreateWithoutDeviceInput[] | GpsPositionUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: GpsPositionCreateOrConnectWithoutDeviceInput | GpsPositionCreateOrConnectWithoutDeviceInput[]
    upsert?: GpsPositionUpsertWithWhereUniqueWithoutDeviceInput | GpsPositionUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: GpsPositionCreateManyDeviceInputEnvelope
    set?: GpsPositionWhereUniqueInput | GpsPositionWhereUniqueInput[]
    disconnect?: GpsPositionWhereUniqueInput | GpsPositionWhereUniqueInput[]
    delete?: GpsPositionWhereUniqueInput | GpsPositionWhereUniqueInput[]
    connect?: GpsPositionWhereUniqueInput | GpsPositionWhereUniqueInput[]
    update?: GpsPositionUpdateWithWhereUniqueWithoutDeviceInput | GpsPositionUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: GpsPositionUpdateManyWithWhereWithoutDeviceInput | GpsPositionUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: GpsPositionScalarWhereInput | GpsPositionScalarWhereInput[]
  }

  export type TirePressureEventUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<TirePressureEventCreateWithoutDeviceInput, TirePressureEventUncheckedCreateWithoutDeviceInput> | TirePressureEventCreateWithoutDeviceInput[] | TirePressureEventUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: TirePressureEventCreateOrConnectWithoutDeviceInput | TirePressureEventCreateOrConnectWithoutDeviceInput[]
    upsert?: TirePressureEventUpsertWithWhereUniqueWithoutDeviceInput | TirePressureEventUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: TirePressureEventCreateManyDeviceInputEnvelope
    set?: TirePressureEventWhereUniqueInput | TirePressureEventWhereUniqueInput[]
    disconnect?: TirePressureEventWhereUniqueInput | TirePressureEventWhereUniqueInput[]
    delete?: TirePressureEventWhereUniqueInput | TirePressureEventWhereUniqueInput[]
    connect?: TirePressureEventWhereUniqueInput | TirePressureEventWhereUniqueInput[]
    update?: TirePressureEventUpdateWithWhereUniqueWithoutDeviceInput | TirePressureEventUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: TirePressureEventUpdateManyWithWhereWithoutDeviceInput | TirePressureEventUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: TirePressureEventScalarWhereInput | TirePressureEventScalarWhereInput[]
  }

  export type HubTemperatureEventUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<HubTemperatureEventCreateWithoutDeviceInput, HubTemperatureEventUncheckedCreateWithoutDeviceInput> | HubTemperatureEventCreateWithoutDeviceInput[] | HubTemperatureEventUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: HubTemperatureEventCreateOrConnectWithoutDeviceInput | HubTemperatureEventCreateOrConnectWithoutDeviceInput[]
    upsert?: HubTemperatureEventUpsertWithWhereUniqueWithoutDeviceInput | HubTemperatureEventUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: HubTemperatureEventCreateManyDeviceInputEnvelope
    set?: HubTemperatureEventWhereUniqueInput | HubTemperatureEventWhereUniqueInput[]
    disconnect?: HubTemperatureEventWhereUniqueInput | HubTemperatureEventWhereUniqueInput[]
    delete?: HubTemperatureEventWhereUniqueInput | HubTemperatureEventWhereUniqueInput[]
    connect?: HubTemperatureEventWhereUniqueInput | HubTemperatureEventWhereUniqueInput[]
    update?: HubTemperatureEventUpdateWithWhereUniqueWithoutDeviceInput | HubTemperatureEventUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: HubTemperatureEventUpdateManyWithWhereWithoutDeviceInput | HubTemperatureEventUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: HubTemperatureEventScalarWhereInput | HubTemperatureEventScalarWhereInput[]
  }

  export type DeviceStatusEventUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<DeviceStatusEventCreateWithoutDeviceInput, DeviceStatusEventUncheckedCreateWithoutDeviceInput> | DeviceStatusEventCreateWithoutDeviceInput[] | DeviceStatusEventUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DeviceStatusEventCreateOrConnectWithoutDeviceInput | DeviceStatusEventCreateOrConnectWithoutDeviceInput[]
    upsert?: DeviceStatusEventUpsertWithWhereUniqueWithoutDeviceInput | DeviceStatusEventUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: DeviceStatusEventCreateManyDeviceInputEnvelope
    set?: DeviceStatusEventWhereUniqueInput | DeviceStatusEventWhereUniqueInput[]
    disconnect?: DeviceStatusEventWhereUniqueInput | DeviceStatusEventWhereUniqueInput[]
    delete?: DeviceStatusEventWhereUniqueInput | DeviceStatusEventWhereUniqueInput[]
    connect?: DeviceStatusEventWhereUniqueInput | DeviceStatusEventWhereUniqueInput[]
    update?: DeviceStatusEventUpdateWithWhereUniqueWithoutDeviceInput | DeviceStatusEventUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: DeviceStatusEventUpdateManyWithWhereWithoutDeviceInput | DeviceStatusEventUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: DeviceStatusEventScalarWhereInput | DeviceStatusEventScalarWhereInput[]
  }

  export type LockEventUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<LockEventCreateWithoutDeviceInput, LockEventUncheckedCreateWithoutDeviceInput> | LockEventCreateWithoutDeviceInput[] | LockEventUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: LockEventCreateOrConnectWithoutDeviceInput | LockEventCreateOrConnectWithoutDeviceInput[]
    upsert?: LockEventUpsertWithWhereUniqueWithoutDeviceInput | LockEventUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: LockEventCreateManyDeviceInputEnvelope
    set?: LockEventWhereUniqueInput | LockEventWhereUniqueInput[]
    disconnect?: LockEventWhereUniqueInput | LockEventWhereUniqueInput[]
    delete?: LockEventWhereUniqueInput | LockEventWhereUniqueInput[]
    connect?: LockEventWhereUniqueInput | LockEventWhereUniqueInput[]
    update?: LockEventUpdateWithWhereUniqueWithoutDeviceInput | LockEventUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: LockEventUpdateManyWithWhereWithoutDeviceInput | LockEventUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: LockEventScalarWhereInput | LockEventScalarWhereInput[]
  }

  export type DeviceCreateNestedOneWithoutSensorsInput = {
    create?: XOR<DeviceCreateWithoutSensorsInput, DeviceUncheckedCreateWithoutSensorsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutSensorsInput
    connect?: DeviceWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DeviceUpdateOneRequiredWithoutSensorsNestedInput = {
    create?: XOR<DeviceCreateWithoutSensorsInput, DeviceUncheckedCreateWithoutSensorsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutSensorsInput
    upsert?: DeviceUpsertWithoutSensorsInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutSensorsInput, DeviceUpdateWithoutSensorsInput>, DeviceUncheckedUpdateWithoutSensorsInput>
  }

  export type TruckCreateNestedOneWithoutTruckStatusEventsInput = {
    create?: XOR<TruckCreateWithoutTruckStatusEventsInput, TruckUncheckedCreateWithoutTruckStatusEventsInput>
    connectOrCreate?: TruckCreateOrConnectWithoutTruckStatusEventsInput
    connect?: TruckWhereUniqueInput
  }

  export type EnumTruckStatusFieldUpdateOperationsInput = {
    set?: $Enums.TruckStatus
  }

  export type TruckUpdateOneRequiredWithoutTruckStatusEventsNestedInput = {
    create?: XOR<TruckCreateWithoutTruckStatusEventsInput, TruckUncheckedCreateWithoutTruckStatusEventsInput>
    connectOrCreate?: TruckCreateOrConnectWithoutTruckStatusEventsInput
    upsert?: TruckUpsertWithoutTruckStatusEventsInput
    connect?: TruckWhereUniqueInput
    update?: XOR<XOR<TruckUpdateToOneWithWhereWithoutTruckStatusEventsInput, TruckUpdateWithoutTruckStatusEventsInput>, TruckUncheckedUpdateWithoutTruckStatusEventsInput>
  }

  export type DeviceCreateNestedOneWithoutGpsPositionsInput = {
    create?: XOR<DeviceCreateWithoutGpsPositionsInput, DeviceUncheckedCreateWithoutGpsPositionsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutGpsPositionsInput
    connect?: DeviceWhereUniqueInput
  }

  export type TruckCreateNestedOneWithoutGpsPositionsInput = {
    create?: XOR<TruckCreateWithoutGpsPositionsInput, TruckUncheckedCreateWithoutGpsPositionsInput>
    connectOrCreate?: TruckCreateOrConnectWithoutGpsPositionsInput
    connect?: TruckWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DeviceUpdateOneWithoutGpsPositionsNestedInput = {
    create?: XOR<DeviceCreateWithoutGpsPositionsInput, DeviceUncheckedCreateWithoutGpsPositionsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutGpsPositionsInput
    upsert?: DeviceUpsertWithoutGpsPositionsInput
    disconnect?: DeviceWhereInput | boolean
    delete?: DeviceWhereInput | boolean
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutGpsPositionsInput, DeviceUpdateWithoutGpsPositionsInput>, DeviceUncheckedUpdateWithoutGpsPositionsInput>
  }

  export type TruckUpdateOneRequiredWithoutGpsPositionsNestedInput = {
    create?: XOR<TruckCreateWithoutGpsPositionsInput, TruckUncheckedCreateWithoutGpsPositionsInput>
    connectOrCreate?: TruckCreateOrConnectWithoutGpsPositionsInput
    upsert?: TruckUpsertWithoutGpsPositionsInput
    connect?: TruckWhereUniqueInput
    update?: XOR<XOR<TruckUpdateToOneWithWhereWithoutGpsPositionsInput, TruckUpdateWithoutGpsPositionsInput>, TruckUncheckedUpdateWithoutGpsPositionsInput>
  }

  export type TruckCreateNestedOneWithoutTripsInput = {
    create?: XOR<TruckCreateWithoutTripsInput, TruckUncheckedCreateWithoutTripsInput>
    connectOrCreate?: TruckCreateOrConnectWithoutTripsInput
    connect?: TruckWhereUniqueInput
  }

  export type TruckUpdateOneRequiredWithoutTripsNestedInput = {
    create?: XOR<TruckCreateWithoutTripsInput, TruckUncheckedCreateWithoutTripsInput>
    connectOrCreate?: TruckCreateOrConnectWithoutTripsInput
    upsert?: TruckUpsertWithoutTripsInput
    connect?: TruckWhereUniqueInput
    update?: XOR<XOR<TruckUpdateToOneWithWhereWithoutTripsInput, TruckUpdateWithoutTripsInput>, TruckUncheckedUpdateWithoutTripsInput>
  }

  export type DeviceCreateNestedOneWithoutTirePressureEventsInput = {
    create?: XOR<DeviceCreateWithoutTirePressureEventsInput, DeviceUncheckedCreateWithoutTirePressureEventsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutTirePressureEventsInput
    connect?: DeviceWhereUniqueInput
  }

  export type TruckCreateNestedOneWithoutTirePressureEventsInput = {
    create?: XOR<TruckCreateWithoutTirePressureEventsInput, TruckUncheckedCreateWithoutTirePressureEventsInput>
    connectOrCreate?: TruckCreateOrConnectWithoutTirePressureEventsInput
    connect?: TruckWhereUniqueInput
  }

  export type DeviceUpdateOneRequiredWithoutTirePressureEventsNestedInput = {
    create?: XOR<DeviceCreateWithoutTirePressureEventsInput, DeviceUncheckedCreateWithoutTirePressureEventsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutTirePressureEventsInput
    upsert?: DeviceUpsertWithoutTirePressureEventsInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutTirePressureEventsInput, DeviceUpdateWithoutTirePressureEventsInput>, DeviceUncheckedUpdateWithoutTirePressureEventsInput>
  }

  export type TruckUpdateOneRequiredWithoutTirePressureEventsNestedInput = {
    create?: XOR<TruckCreateWithoutTirePressureEventsInput, TruckUncheckedCreateWithoutTirePressureEventsInput>
    connectOrCreate?: TruckCreateOrConnectWithoutTirePressureEventsInput
    upsert?: TruckUpsertWithoutTirePressureEventsInput
    connect?: TruckWhereUniqueInput
    update?: XOR<XOR<TruckUpdateToOneWithWhereWithoutTirePressureEventsInput, TruckUpdateWithoutTirePressureEventsInput>, TruckUncheckedUpdateWithoutTirePressureEventsInput>
  }

  export type DeviceCreateNestedOneWithoutHubTemperatureEventsInput = {
    create?: XOR<DeviceCreateWithoutHubTemperatureEventsInput, DeviceUncheckedCreateWithoutHubTemperatureEventsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutHubTemperatureEventsInput
    connect?: DeviceWhereUniqueInput
  }

  export type TruckCreateNestedOneWithoutHubTemperatureEventsInput = {
    create?: XOR<TruckCreateWithoutHubTemperatureEventsInput, TruckUncheckedCreateWithoutHubTemperatureEventsInput>
    connectOrCreate?: TruckCreateOrConnectWithoutHubTemperatureEventsInput
    connect?: TruckWhereUniqueInput
  }

  export type DeviceUpdateOneRequiredWithoutHubTemperatureEventsNestedInput = {
    create?: XOR<DeviceCreateWithoutHubTemperatureEventsInput, DeviceUncheckedCreateWithoutHubTemperatureEventsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutHubTemperatureEventsInput
    upsert?: DeviceUpsertWithoutHubTemperatureEventsInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutHubTemperatureEventsInput, DeviceUpdateWithoutHubTemperatureEventsInput>, DeviceUncheckedUpdateWithoutHubTemperatureEventsInput>
  }

  export type TruckUpdateOneRequiredWithoutHubTemperatureEventsNestedInput = {
    create?: XOR<TruckCreateWithoutHubTemperatureEventsInput, TruckUncheckedCreateWithoutHubTemperatureEventsInput>
    connectOrCreate?: TruckCreateOrConnectWithoutHubTemperatureEventsInput
    upsert?: TruckUpsertWithoutHubTemperatureEventsInput
    connect?: TruckWhereUniqueInput
    update?: XOR<XOR<TruckUpdateToOneWithWhereWithoutHubTemperatureEventsInput, TruckUpdateWithoutHubTemperatureEventsInput>, TruckUncheckedUpdateWithoutHubTemperatureEventsInput>
  }

  export type TruckCreateNestedOneWithoutFuelLevelEventsInput = {
    create?: XOR<TruckCreateWithoutFuelLevelEventsInput, TruckUncheckedCreateWithoutFuelLevelEventsInput>
    connectOrCreate?: TruckCreateOrConnectWithoutFuelLevelEventsInput
    connect?: TruckWhereUniqueInput
  }

  export type TruckUpdateOneRequiredWithoutFuelLevelEventsNestedInput = {
    create?: XOR<TruckCreateWithoutFuelLevelEventsInput, TruckUncheckedCreateWithoutFuelLevelEventsInput>
    connectOrCreate?: TruckCreateOrConnectWithoutFuelLevelEventsInput
    upsert?: TruckUpsertWithoutFuelLevelEventsInput
    connect?: TruckWhereUniqueInput
    update?: XOR<XOR<TruckUpdateToOneWithWhereWithoutFuelLevelEventsInput, TruckUpdateWithoutFuelLevelEventsInput>, TruckUncheckedUpdateWithoutFuelLevelEventsInput>
  }

  export type TruckCreateNestedOneWithoutSpeedEventsInput = {
    create?: XOR<TruckCreateWithoutSpeedEventsInput, TruckUncheckedCreateWithoutSpeedEventsInput>
    connectOrCreate?: TruckCreateOrConnectWithoutSpeedEventsInput
    connect?: TruckWhereUniqueInput
  }

  export type TruckUpdateOneRequiredWithoutSpeedEventsNestedInput = {
    create?: XOR<TruckCreateWithoutSpeedEventsInput, TruckUncheckedCreateWithoutSpeedEventsInput>
    connectOrCreate?: TruckCreateOrConnectWithoutSpeedEventsInput
    upsert?: TruckUpsertWithoutSpeedEventsInput
    connect?: TruckWhereUniqueInput
    update?: XOR<XOR<TruckUpdateToOneWithWhereWithoutSpeedEventsInput, TruckUpdateWithoutSpeedEventsInput>, TruckUncheckedUpdateWithoutSpeedEventsInput>
  }

  export type TruckCreateNestedOneWithoutAlertEventsInput = {
    create?: XOR<TruckCreateWithoutAlertEventsInput, TruckUncheckedCreateWithoutAlertEventsInput>
    connectOrCreate?: TruckCreateOrConnectWithoutAlertEventsInput
    connect?: TruckWhereUniqueInput
  }

  export type EnumAlertTypeFieldUpdateOperationsInput = {
    set?: $Enums.AlertType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type TruckUpdateOneRequiredWithoutAlertEventsNestedInput = {
    create?: XOR<TruckCreateWithoutAlertEventsInput, TruckUncheckedCreateWithoutAlertEventsInput>
    connectOrCreate?: TruckCreateOrConnectWithoutAlertEventsInput
    upsert?: TruckUpsertWithoutAlertEventsInput
    connect?: TruckWhereUniqueInput
    update?: XOR<XOR<TruckUpdateToOneWithWhereWithoutAlertEventsInput, TruckUpdateWithoutAlertEventsInput>, TruckUncheckedUpdateWithoutAlertEventsInput>
  }

  export type DeviceCreateNestedOneWithoutDeviceStatusEventsInput = {
    create?: XOR<DeviceCreateWithoutDeviceStatusEventsInput, DeviceUncheckedCreateWithoutDeviceStatusEventsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutDeviceStatusEventsInput
    connect?: DeviceWhereUniqueInput
  }

  export type TruckCreateNestedOneWithoutDeviceStatusEventsInput = {
    create?: XOR<TruckCreateWithoutDeviceStatusEventsInput, TruckUncheckedCreateWithoutDeviceStatusEventsInput>
    connectOrCreate?: TruckCreateOrConnectWithoutDeviceStatusEventsInput
    connect?: TruckWhereUniqueInput
  }

  export type DeviceUpdateOneRequiredWithoutDeviceStatusEventsNestedInput = {
    create?: XOR<DeviceCreateWithoutDeviceStatusEventsInput, DeviceUncheckedCreateWithoutDeviceStatusEventsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutDeviceStatusEventsInput
    upsert?: DeviceUpsertWithoutDeviceStatusEventsInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutDeviceStatusEventsInput, DeviceUpdateWithoutDeviceStatusEventsInput>, DeviceUncheckedUpdateWithoutDeviceStatusEventsInput>
  }

  export type TruckUpdateOneRequiredWithoutDeviceStatusEventsNestedInput = {
    create?: XOR<TruckCreateWithoutDeviceStatusEventsInput, TruckUncheckedCreateWithoutDeviceStatusEventsInput>
    connectOrCreate?: TruckCreateOrConnectWithoutDeviceStatusEventsInput
    upsert?: TruckUpsertWithoutDeviceStatusEventsInput
    connect?: TruckWhereUniqueInput
    update?: XOR<XOR<TruckUpdateToOneWithWhereWithoutDeviceStatusEventsInput, TruckUpdateWithoutDeviceStatusEventsInput>, TruckUncheckedUpdateWithoutDeviceStatusEventsInput>
  }

  export type DeviceCreateNestedOneWithoutLockEventsInput = {
    create?: XOR<DeviceCreateWithoutLockEventsInput, DeviceUncheckedCreateWithoutLockEventsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutLockEventsInput
    connect?: DeviceWhereUniqueInput
  }

  export type TruckCreateNestedOneWithoutLockEventsInput = {
    create?: XOR<TruckCreateWithoutLockEventsInput, TruckUncheckedCreateWithoutLockEventsInput>
    connectOrCreate?: TruckCreateOrConnectWithoutLockEventsInput
    connect?: TruckWhereUniqueInput
  }

  export type DeviceUpdateOneRequiredWithoutLockEventsNestedInput = {
    create?: XOR<DeviceCreateWithoutLockEventsInput, DeviceUncheckedCreateWithoutLockEventsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutLockEventsInput
    upsert?: DeviceUpsertWithoutLockEventsInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutLockEventsInput, DeviceUpdateWithoutLockEventsInput>, DeviceUncheckedUpdateWithoutLockEventsInput>
  }

  export type TruckUpdateOneRequiredWithoutLockEventsNestedInput = {
    create?: XOR<TruckCreateWithoutLockEventsInput, TruckUncheckedCreateWithoutLockEventsInput>
    connectOrCreate?: TruckCreateOrConnectWithoutLockEventsInput
    upsert?: TruckUpsertWithoutLockEventsInput
    connect?: TruckWhereUniqueInput
    update?: XOR<XOR<TruckUpdateToOneWithWhereWithoutLockEventsInput, TruckUpdateWithoutLockEventsInput>, TruckUncheckedUpdateWithoutLockEventsInput>
  }

  export type TruckCreateNestedOneWithoutDailyRoutesInput = {
    create?: XOR<TruckCreateWithoutDailyRoutesInput, TruckUncheckedCreateWithoutDailyRoutesInput>
    connectOrCreate?: TruckCreateOrConnectWithoutDailyRoutesInput
    connect?: TruckWhereUniqueInput
  }

  export type TruckUpdateOneRequiredWithoutDailyRoutesNestedInput = {
    create?: XOR<TruckCreateWithoutDailyRoutesInput, TruckUncheckedCreateWithoutDailyRoutesInput>
    connectOrCreate?: TruckCreateOrConnectWithoutDailyRoutesInput
    upsert?: TruckUpsertWithoutDailyRoutesInput
    connect?: TruckWhereUniqueInput
    update?: XOR<XOR<TruckUpdateToOneWithWhereWithoutDailyRoutesInput, TruckUpdateWithoutDailyRoutesInput>, TruckUncheckedUpdateWithoutDailyRoutesInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumTruckStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TruckStatus | EnumTruckStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TruckStatus[] | ListEnumTruckStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TruckStatus[] | ListEnumTruckStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTruckStatusFilter<$PrismaModel> | $Enums.TruckStatus
  }

  export type NestedEnumTruckStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TruckStatus | EnumTruckStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TruckStatus[] | ListEnumTruckStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TruckStatus[] | ListEnumTruckStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTruckStatusWithAggregatesFilter<$PrismaModel> | $Enums.TruckStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTruckStatusFilter<$PrismaModel>
    _max?: NestedEnumTruckStatusFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumAlertTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertTypeFilter<$PrismaModel> | $Enums.AlertType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumAlertTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertTypeWithAggregatesFilter<$PrismaModel> | $Enums.AlertType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertTypeFilter<$PrismaModel>
    _max?: NestedEnumAlertTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type TruckCreateWithoutFleetGroupInput = {
    id?: string
    plateNumber: string
    vin?: string | null
    name?: string | null
    model?: string | null
    year?: number | null
    tireConfig?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    devices?: DeviceCreateNestedManyWithoutTruckInput
    truckStatusEvents?: TruckStatusEventCreateNestedManyWithoutTruckInput
    gpsPositions?: GpsPositionCreateNestedManyWithoutTruckInput
    trips?: TripCreateNestedManyWithoutTruckInput
    tirePressureEvents?: TirePressureEventCreateNestedManyWithoutTruckInput
    hubTemperatureEvents?: HubTemperatureEventCreateNestedManyWithoutTruckInput
    fuelLevelEvents?: FuelLevelEventCreateNestedManyWithoutTruckInput
    speedEvents?: SpeedEventCreateNestedManyWithoutTruckInput
    alertEvents?: AlertEventCreateNestedManyWithoutTruckInput
    deviceStatusEvents?: DeviceStatusEventCreateNestedManyWithoutTruckInput
    lockEvents?: LockEventCreateNestedManyWithoutTruckInput
    dailyRoutes?: DailyRouteCreateNestedManyWithoutTruckInput
  }

  export type TruckUncheckedCreateWithoutFleetGroupInput = {
    id?: string
    plateNumber: string
    vin?: string | null
    name?: string | null
    model?: string | null
    year?: number | null
    tireConfig?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    devices?: DeviceUncheckedCreateNestedManyWithoutTruckInput
    truckStatusEvents?: TruckStatusEventUncheckedCreateNestedManyWithoutTruckInput
    gpsPositions?: GpsPositionUncheckedCreateNestedManyWithoutTruckInput
    trips?: TripUncheckedCreateNestedManyWithoutTruckInput
    tirePressureEvents?: TirePressureEventUncheckedCreateNestedManyWithoutTruckInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedCreateNestedManyWithoutTruckInput
    fuelLevelEvents?: FuelLevelEventUncheckedCreateNestedManyWithoutTruckInput
    speedEvents?: SpeedEventUncheckedCreateNestedManyWithoutTruckInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutTruckInput
    deviceStatusEvents?: DeviceStatusEventUncheckedCreateNestedManyWithoutTruckInput
    lockEvents?: LockEventUncheckedCreateNestedManyWithoutTruckInput
    dailyRoutes?: DailyRouteUncheckedCreateNestedManyWithoutTruckInput
  }

  export type TruckCreateOrConnectWithoutFleetGroupInput = {
    where: TruckWhereUniqueInput
    create: XOR<TruckCreateWithoutFleetGroupInput, TruckUncheckedCreateWithoutFleetGroupInput>
  }

  export type TruckCreateManyFleetGroupInputEnvelope = {
    data: TruckCreateManyFleetGroupInput | TruckCreateManyFleetGroupInput[]
    skipDuplicates?: boolean
  }

  export type TruckUpsertWithWhereUniqueWithoutFleetGroupInput = {
    where: TruckWhereUniqueInput
    update: XOR<TruckUpdateWithoutFleetGroupInput, TruckUncheckedUpdateWithoutFleetGroupInput>
    create: XOR<TruckCreateWithoutFleetGroupInput, TruckUncheckedCreateWithoutFleetGroupInput>
  }

  export type TruckUpdateWithWhereUniqueWithoutFleetGroupInput = {
    where: TruckWhereUniqueInput
    data: XOR<TruckUpdateWithoutFleetGroupInput, TruckUncheckedUpdateWithoutFleetGroupInput>
  }

  export type TruckUpdateManyWithWhereWithoutFleetGroupInput = {
    where: TruckScalarWhereInput
    data: XOR<TruckUpdateManyMutationInput, TruckUncheckedUpdateManyWithoutFleetGroupInput>
  }

  export type TruckScalarWhereInput = {
    AND?: TruckScalarWhereInput | TruckScalarWhereInput[]
    OR?: TruckScalarWhereInput[]
    NOT?: TruckScalarWhereInput | TruckScalarWhereInput[]
    id?: UuidFilter<"Truck"> | string
    plateNumber?: StringFilter<"Truck"> | string
    vin?: StringNullableFilter<"Truck"> | string | null
    name?: StringNullableFilter<"Truck"> | string | null
    model?: StringNullableFilter<"Truck"> | string | null
    year?: IntNullableFilter<"Truck"> | number | null
    tireConfig?: StringNullableFilter<"Truck"> | string | null
    fleetGroupId?: UuidNullableFilter<"Truck"> | string | null
    createdAt?: DateTimeFilter<"Truck"> | Date | string
    createdBy?: UuidNullableFilter<"Truck"> | string | null
    updatedBy?: UuidNullableFilter<"Truck"> | string | null
  }

  export type FleetGroupCreateWithoutTrucksInput = {
    id?: string
    name: string
    site?: string | null
    description?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type FleetGroupUncheckedCreateWithoutTrucksInput = {
    id?: string
    name: string
    site?: string | null
    description?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type FleetGroupCreateOrConnectWithoutTrucksInput = {
    where: FleetGroupWhereUniqueInput
    create: XOR<FleetGroupCreateWithoutTrucksInput, FleetGroupUncheckedCreateWithoutTrucksInput>
  }

  export type DeviceCreateWithoutTruckInput = {
    id?: string
    sn: string
    simNumber?: string | null
    installedAt?: Date | string
    removedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    sensors?: SensorCreateNestedManyWithoutDeviceInput
    gpsPositions?: GpsPositionCreateNestedManyWithoutDeviceInput
    tirePressureEvents?: TirePressureEventCreateNestedManyWithoutDeviceInput
    hubTemperatureEvents?: HubTemperatureEventCreateNestedManyWithoutDeviceInput
    deviceStatusEvents?: DeviceStatusEventCreateNestedManyWithoutDeviceInput
    lockEvents?: LockEventCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutTruckInput = {
    id?: string
    sn: string
    simNumber?: string | null
    installedAt?: Date | string
    removedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    sensors?: SensorUncheckedCreateNestedManyWithoutDeviceInput
    gpsPositions?: GpsPositionUncheckedCreateNestedManyWithoutDeviceInput
    tirePressureEvents?: TirePressureEventUncheckedCreateNestedManyWithoutDeviceInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedCreateNestedManyWithoutDeviceInput
    deviceStatusEvents?: DeviceStatusEventUncheckedCreateNestedManyWithoutDeviceInput
    lockEvents?: LockEventUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutTruckInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutTruckInput, DeviceUncheckedCreateWithoutTruckInput>
  }

  export type DeviceCreateManyTruckInputEnvelope = {
    data: DeviceCreateManyTruckInput | DeviceCreateManyTruckInput[]
    skipDuplicates?: boolean
  }

  export type TruckStatusEventCreateWithoutTruckInput = {
    id?: string
    status: $Enums.TruckStatus
    note?: string | null
    changedAt?: Date | string
    createdBy?: string | null
  }

  export type TruckStatusEventUncheckedCreateWithoutTruckInput = {
    id?: string
    status: $Enums.TruckStatus
    note?: string | null
    changedAt?: Date | string
    createdBy?: string | null
  }

  export type TruckStatusEventCreateOrConnectWithoutTruckInput = {
    where: TruckStatusEventWhereUniqueInput
    create: XOR<TruckStatusEventCreateWithoutTruckInput, TruckStatusEventUncheckedCreateWithoutTruckInput>
  }

  export type TruckStatusEventCreateManyTruckInputEnvelope = {
    data: TruckStatusEventCreateManyTruckInput | TruckStatusEventCreateManyTruckInput[]
    skipDuplicates?: boolean
  }

  export type GpsPositionCreateWithoutTruckInput = {
    id?: bigint | number
    ts: Date | string
    speedKph?: number | null
    headingDeg?: number | null
    hdop?: number | null
    source?: string | null
    device?: DeviceCreateNestedOneWithoutGpsPositionsInput
  }

  export type GpsPositionUncheckedCreateWithoutTruckInput = {
    id?: bigint | number
    deviceId?: string | null
    ts: Date | string
    speedKph?: number | null
    headingDeg?: number | null
    hdop?: number | null
    source?: string | null
  }

  export type GpsPositionCreateOrConnectWithoutTruckInput = {
    where: GpsPositionWhereUniqueInput
    create: XOR<GpsPositionCreateWithoutTruckInput, GpsPositionUncheckedCreateWithoutTruckInput>
  }

  export type GpsPositionCreateManyTruckInputEnvelope = {
    data: GpsPositionCreateManyTruckInput | GpsPositionCreateManyTruckInput[]
    skipDuplicates?: boolean
  }

  export type TripCreateWithoutTruckInput = {
    id?: string
    startTs: Date | string
    endTs?: Date | string | null
  }

  export type TripUncheckedCreateWithoutTruckInput = {
    id?: string
    startTs: Date | string
    endTs?: Date | string | null
  }

  export type TripCreateOrConnectWithoutTruckInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutTruckInput, TripUncheckedCreateWithoutTruckInput>
  }

  export type TripCreateManyTruckInputEnvelope = {
    data: TripCreateManyTruckInput | TripCreateManyTruckInput[]
    skipDuplicates?: boolean
  }

  export type TirePressureEventCreateWithoutTruckInput = {
    id?: string
    tireNo: number
    pressureKpa?: number | null
    tempCelsius?: number | null
    exType?: string | null
    batteryLevel?: number | null
    changedAt?: Date | string
    createdBy?: string | null
    device: DeviceCreateNestedOneWithoutTirePressureEventsInput
  }

  export type TirePressureEventUncheckedCreateWithoutTruckInput = {
    id?: string
    deviceId: string
    tireNo: number
    pressureKpa?: number | null
    tempCelsius?: number | null
    exType?: string | null
    batteryLevel?: number | null
    changedAt?: Date | string
    createdBy?: string | null
  }

  export type TirePressureEventCreateOrConnectWithoutTruckInput = {
    where: TirePressureEventWhereUniqueInput
    create: XOR<TirePressureEventCreateWithoutTruckInput, TirePressureEventUncheckedCreateWithoutTruckInput>
  }

  export type TirePressureEventCreateManyTruckInputEnvelope = {
    data: TirePressureEventCreateManyTruckInput | TirePressureEventCreateManyTruckInput[]
    skipDuplicates?: boolean
  }

  export type HubTemperatureEventCreateWithoutTruckInput = {
    id?: string
    hubNo?: number | null
    tempCelsius?: number | null
    exType?: string | null
    batteryLevel?: number | null
    changedAt?: Date | string
    createdBy?: string | null
    device: DeviceCreateNestedOneWithoutHubTemperatureEventsInput
  }

  export type HubTemperatureEventUncheckedCreateWithoutTruckInput = {
    id?: string
    deviceId: string
    hubNo?: number | null
    tempCelsius?: number | null
    exType?: string | null
    batteryLevel?: number | null
    changedAt?: Date | string
    createdBy?: string | null
  }

  export type HubTemperatureEventCreateOrConnectWithoutTruckInput = {
    where: HubTemperatureEventWhereUniqueInput
    create: XOR<HubTemperatureEventCreateWithoutTruckInput, HubTemperatureEventUncheckedCreateWithoutTruckInput>
  }

  export type HubTemperatureEventCreateManyTruckInputEnvelope = {
    data: HubTemperatureEventCreateManyTruckInput | HubTemperatureEventCreateManyTruckInput[]
    skipDuplicates?: boolean
  }

  export type FuelLevelEventCreateWithoutTruckInput = {
    id?: string
    fuelPercent?: number | null
    changedAt: Date | string
    source?: string | null
    createdBy?: string | null
  }

  export type FuelLevelEventUncheckedCreateWithoutTruckInput = {
    id?: string
    fuelPercent?: number | null
    changedAt: Date | string
    source?: string | null
    createdBy?: string | null
  }

  export type FuelLevelEventCreateOrConnectWithoutTruckInput = {
    where: FuelLevelEventWhereUniqueInput
    create: XOR<FuelLevelEventCreateWithoutTruckInput, FuelLevelEventUncheckedCreateWithoutTruckInput>
  }

  export type FuelLevelEventCreateManyTruckInputEnvelope = {
    data: FuelLevelEventCreateManyTruckInput | FuelLevelEventCreateManyTruckInput[]
    skipDuplicates?: boolean
  }

  export type SpeedEventCreateWithoutTruckInput = {
    id?: string
    speedKph?: number | null
    changedAt: Date | string
    source?: string | null
    createdBy?: string | null
  }

  export type SpeedEventUncheckedCreateWithoutTruckInput = {
    id?: string
    speedKph?: number | null
    changedAt: Date | string
    source?: string | null
    createdBy?: string | null
  }

  export type SpeedEventCreateOrConnectWithoutTruckInput = {
    where: SpeedEventWhereUniqueInput
    create: XOR<SpeedEventCreateWithoutTruckInput, SpeedEventUncheckedCreateWithoutTruckInput>
  }

  export type SpeedEventCreateManyTruckInputEnvelope = {
    data: SpeedEventCreateManyTruckInput | SpeedEventCreateManyTruckInput[]
    skipDuplicates?: boolean
  }

  export type AlertEventCreateWithoutTruckInput = {
    id?: string
    type: $Enums.AlertType
    severity?: number | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: Date | string
    acknowledged?: boolean
    createdBy?: string | null
  }

  export type AlertEventUncheckedCreateWithoutTruckInput = {
    id?: string
    type: $Enums.AlertType
    severity?: number | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: Date | string
    acknowledged?: boolean
    createdBy?: string | null
  }

  export type AlertEventCreateOrConnectWithoutTruckInput = {
    where: AlertEventWhereUniqueInput
    create: XOR<AlertEventCreateWithoutTruckInput, AlertEventUncheckedCreateWithoutTruckInput>
  }

  export type AlertEventCreateManyTruckInputEnvelope = {
    data: AlertEventCreateManyTruckInput | AlertEventCreateManyTruckInput[]
    skipDuplicates?: boolean
  }

  export type DeviceStatusEventCreateWithoutTruckInput = {
    id?: string
    hostBat?: number | null
    repeater1Bat?: number | null
    repeater2Bat?: number | null
    lockState?: number | null
    reportedAt?: Date | string
    createdBy?: string | null
    device: DeviceCreateNestedOneWithoutDeviceStatusEventsInput
  }

  export type DeviceStatusEventUncheckedCreateWithoutTruckInput = {
    id?: string
    deviceId: string
    hostBat?: number | null
    repeater1Bat?: number | null
    repeater2Bat?: number | null
    lockState?: number | null
    reportedAt?: Date | string
    createdBy?: string | null
  }

  export type DeviceStatusEventCreateOrConnectWithoutTruckInput = {
    where: DeviceStatusEventWhereUniqueInput
    create: XOR<DeviceStatusEventCreateWithoutTruckInput, DeviceStatusEventUncheckedCreateWithoutTruckInput>
  }

  export type DeviceStatusEventCreateManyTruckInputEnvelope = {
    data: DeviceStatusEventCreateManyTruckInput | DeviceStatusEventCreateManyTruckInput[]
    skipDuplicates?: boolean
  }

  export type LockEventCreateWithoutTruckInput = {
    id?: string
    isLock?: number | null
    reportedAt?: Date | string
    createdBy?: string | null
    device: DeviceCreateNestedOneWithoutLockEventsInput
  }

  export type LockEventUncheckedCreateWithoutTruckInput = {
    id?: string
    deviceId: string
    isLock?: number | null
    reportedAt?: Date | string
    createdBy?: string | null
  }

  export type LockEventCreateOrConnectWithoutTruckInput = {
    where: LockEventWhereUniqueInput
    create: XOR<LockEventCreateWithoutTruckInput, LockEventUncheckedCreateWithoutTruckInput>
  }

  export type LockEventCreateManyTruckInputEnvelope = {
    data: LockEventCreateManyTruckInput | LockEventCreateManyTruckInput[]
    skipDuplicates?: boolean
  }

  export type DailyRouteCreateWithoutTruckInput = {
    id?: string
    routeDate: Date | string
    pointCount: number
    generatedAt?: Date | string
    createdBy?: string | null
  }

  export type DailyRouteUncheckedCreateWithoutTruckInput = {
    id?: string
    routeDate: Date | string
    pointCount: number
    generatedAt?: Date | string
    createdBy?: string | null
  }

  export type DailyRouteCreateOrConnectWithoutTruckInput = {
    where: DailyRouteWhereUniqueInput
    create: XOR<DailyRouteCreateWithoutTruckInput, DailyRouteUncheckedCreateWithoutTruckInput>
  }

  export type DailyRouteCreateManyTruckInputEnvelope = {
    data: DailyRouteCreateManyTruckInput | DailyRouteCreateManyTruckInput[]
    skipDuplicates?: boolean
  }

  export type FleetGroupUpsertWithoutTrucksInput = {
    update: XOR<FleetGroupUpdateWithoutTrucksInput, FleetGroupUncheckedUpdateWithoutTrucksInput>
    create: XOR<FleetGroupCreateWithoutTrucksInput, FleetGroupUncheckedCreateWithoutTrucksInput>
    where?: FleetGroupWhereInput
  }

  export type FleetGroupUpdateToOneWithWhereWithoutTrucksInput = {
    where?: FleetGroupWhereInput
    data: XOR<FleetGroupUpdateWithoutTrucksInput, FleetGroupUncheckedUpdateWithoutTrucksInput>
  }

  export type FleetGroupUpdateWithoutTrucksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    site?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FleetGroupUncheckedUpdateWithoutTrucksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    site?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeviceUpsertWithWhereUniqueWithoutTruckInput = {
    where: DeviceWhereUniqueInput
    update: XOR<DeviceUpdateWithoutTruckInput, DeviceUncheckedUpdateWithoutTruckInput>
    create: XOR<DeviceCreateWithoutTruckInput, DeviceUncheckedCreateWithoutTruckInput>
  }

  export type DeviceUpdateWithWhereUniqueWithoutTruckInput = {
    where: DeviceWhereUniqueInput
    data: XOR<DeviceUpdateWithoutTruckInput, DeviceUncheckedUpdateWithoutTruckInput>
  }

  export type DeviceUpdateManyWithWhereWithoutTruckInput = {
    where: DeviceScalarWhereInput
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyWithoutTruckInput>
  }

  export type DeviceScalarWhereInput = {
    AND?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
    OR?: DeviceScalarWhereInput[]
    NOT?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
    id?: UuidFilter<"Device"> | string
    truckId?: UuidFilter<"Device"> | string
    sn?: StringFilter<"Device"> | string
    simNumber?: StringNullableFilter<"Device"> | string | null
    installedAt?: DateTimeFilter<"Device"> | Date | string
    removedAt?: DateTimeNullableFilter<"Device"> | Date | string | null
    createdBy?: UuidNullableFilter<"Device"> | string | null
    updatedBy?: UuidNullableFilter<"Device"> | string | null
  }

  export type TruckStatusEventUpsertWithWhereUniqueWithoutTruckInput = {
    where: TruckStatusEventWhereUniqueInput
    update: XOR<TruckStatusEventUpdateWithoutTruckInput, TruckStatusEventUncheckedUpdateWithoutTruckInput>
    create: XOR<TruckStatusEventCreateWithoutTruckInput, TruckStatusEventUncheckedCreateWithoutTruckInput>
  }

  export type TruckStatusEventUpdateWithWhereUniqueWithoutTruckInput = {
    where: TruckStatusEventWhereUniqueInput
    data: XOR<TruckStatusEventUpdateWithoutTruckInput, TruckStatusEventUncheckedUpdateWithoutTruckInput>
  }

  export type TruckStatusEventUpdateManyWithWhereWithoutTruckInput = {
    where: TruckStatusEventScalarWhereInput
    data: XOR<TruckStatusEventUpdateManyMutationInput, TruckStatusEventUncheckedUpdateManyWithoutTruckInput>
  }

  export type TruckStatusEventScalarWhereInput = {
    AND?: TruckStatusEventScalarWhereInput | TruckStatusEventScalarWhereInput[]
    OR?: TruckStatusEventScalarWhereInput[]
    NOT?: TruckStatusEventScalarWhereInput | TruckStatusEventScalarWhereInput[]
    id?: UuidFilter<"TruckStatusEvent"> | string
    truckId?: UuidFilter<"TruckStatusEvent"> | string
    status?: EnumTruckStatusFilter<"TruckStatusEvent"> | $Enums.TruckStatus
    note?: StringNullableFilter<"TruckStatusEvent"> | string | null
    changedAt?: DateTimeFilter<"TruckStatusEvent"> | Date | string
    createdBy?: UuidNullableFilter<"TruckStatusEvent"> | string | null
  }

  export type GpsPositionUpsertWithWhereUniqueWithoutTruckInput = {
    where: GpsPositionWhereUniqueInput
    update: XOR<GpsPositionUpdateWithoutTruckInput, GpsPositionUncheckedUpdateWithoutTruckInput>
    create: XOR<GpsPositionCreateWithoutTruckInput, GpsPositionUncheckedCreateWithoutTruckInput>
  }

  export type GpsPositionUpdateWithWhereUniqueWithoutTruckInput = {
    where: GpsPositionWhereUniqueInput
    data: XOR<GpsPositionUpdateWithoutTruckInput, GpsPositionUncheckedUpdateWithoutTruckInput>
  }

  export type GpsPositionUpdateManyWithWhereWithoutTruckInput = {
    where: GpsPositionScalarWhereInput
    data: XOR<GpsPositionUpdateManyMutationInput, GpsPositionUncheckedUpdateManyWithoutTruckInput>
  }

  export type GpsPositionScalarWhereInput = {
    AND?: GpsPositionScalarWhereInput | GpsPositionScalarWhereInput[]
    OR?: GpsPositionScalarWhereInput[]
    NOT?: GpsPositionScalarWhereInput | GpsPositionScalarWhereInput[]
    id?: BigIntFilter<"GpsPosition"> | bigint | number
    deviceId?: UuidNullableFilter<"GpsPosition"> | string | null
    truckId?: UuidFilter<"GpsPosition"> | string
    ts?: DateTimeFilter<"GpsPosition"> | Date | string
    speedKph?: FloatNullableFilter<"GpsPosition"> | number | null
    headingDeg?: FloatNullableFilter<"GpsPosition"> | number | null
    hdop?: FloatNullableFilter<"GpsPosition"> | number | null
    source?: StringNullableFilter<"GpsPosition"> | string | null
  }

  export type TripUpsertWithWhereUniqueWithoutTruckInput = {
    where: TripWhereUniqueInput
    update: XOR<TripUpdateWithoutTruckInput, TripUncheckedUpdateWithoutTruckInput>
    create: XOR<TripCreateWithoutTruckInput, TripUncheckedCreateWithoutTruckInput>
  }

  export type TripUpdateWithWhereUniqueWithoutTruckInput = {
    where: TripWhereUniqueInput
    data: XOR<TripUpdateWithoutTruckInput, TripUncheckedUpdateWithoutTruckInput>
  }

  export type TripUpdateManyWithWhereWithoutTruckInput = {
    where: TripScalarWhereInput
    data: XOR<TripUpdateManyMutationInput, TripUncheckedUpdateManyWithoutTruckInput>
  }

  export type TripScalarWhereInput = {
    AND?: TripScalarWhereInput | TripScalarWhereInput[]
    OR?: TripScalarWhereInput[]
    NOT?: TripScalarWhereInput | TripScalarWhereInput[]
    id?: UuidFilter<"Trip"> | string
    truckId?: UuidFilter<"Trip"> | string
    startTs?: DateTimeFilter<"Trip"> | Date | string
    endTs?: DateTimeNullableFilter<"Trip"> | Date | string | null
  }

  export type TirePressureEventUpsertWithWhereUniqueWithoutTruckInput = {
    where: TirePressureEventWhereUniqueInput
    update: XOR<TirePressureEventUpdateWithoutTruckInput, TirePressureEventUncheckedUpdateWithoutTruckInput>
    create: XOR<TirePressureEventCreateWithoutTruckInput, TirePressureEventUncheckedCreateWithoutTruckInput>
  }

  export type TirePressureEventUpdateWithWhereUniqueWithoutTruckInput = {
    where: TirePressureEventWhereUniqueInput
    data: XOR<TirePressureEventUpdateWithoutTruckInput, TirePressureEventUncheckedUpdateWithoutTruckInput>
  }

  export type TirePressureEventUpdateManyWithWhereWithoutTruckInput = {
    where: TirePressureEventScalarWhereInput
    data: XOR<TirePressureEventUpdateManyMutationInput, TirePressureEventUncheckedUpdateManyWithoutTruckInput>
  }

  export type TirePressureEventScalarWhereInput = {
    AND?: TirePressureEventScalarWhereInput | TirePressureEventScalarWhereInput[]
    OR?: TirePressureEventScalarWhereInput[]
    NOT?: TirePressureEventScalarWhereInput | TirePressureEventScalarWhereInput[]
    id?: UuidFilter<"TirePressureEvent"> | string
    deviceId?: UuidFilter<"TirePressureEvent"> | string
    truckId?: UuidFilter<"TirePressureEvent"> | string
    tireNo?: IntFilter<"TirePressureEvent"> | number
    pressureKpa?: FloatNullableFilter<"TirePressureEvent"> | number | null
    tempCelsius?: FloatNullableFilter<"TirePressureEvent"> | number | null
    exType?: StringNullableFilter<"TirePressureEvent"> | string | null
    batteryLevel?: IntNullableFilter<"TirePressureEvent"> | number | null
    changedAt?: DateTimeFilter<"TirePressureEvent"> | Date | string
    createdBy?: UuidNullableFilter<"TirePressureEvent"> | string | null
  }

  export type HubTemperatureEventUpsertWithWhereUniqueWithoutTruckInput = {
    where: HubTemperatureEventWhereUniqueInput
    update: XOR<HubTemperatureEventUpdateWithoutTruckInput, HubTemperatureEventUncheckedUpdateWithoutTruckInput>
    create: XOR<HubTemperatureEventCreateWithoutTruckInput, HubTemperatureEventUncheckedCreateWithoutTruckInput>
  }

  export type HubTemperatureEventUpdateWithWhereUniqueWithoutTruckInput = {
    where: HubTemperatureEventWhereUniqueInput
    data: XOR<HubTemperatureEventUpdateWithoutTruckInput, HubTemperatureEventUncheckedUpdateWithoutTruckInput>
  }

  export type HubTemperatureEventUpdateManyWithWhereWithoutTruckInput = {
    where: HubTemperatureEventScalarWhereInput
    data: XOR<HubTemperatureEventUpdateManyMutationInput, HubTemperatureEventUncheckedUpdateManyWithoutTruckInput>
  }

  export type HubTemperatureEventScalarWhereInput = {
    AND?: HubTemperatureEventScalarWhereInput | HubTemperatureEventScalarWhereInput[]
    OR?: HubTemperatureEventScalarWhereInput[]
    NOT?: HubTemperatureEventScalarWhereInput | HubTemperatureEventScalarWhereInput[]
    id?: UuidFilter<"HubTemperatureEvent"> | string
    deviceId?: UuidFilter<"HubTemperatureEvent"> | string
    truckId?: UuidFilter<"HubTemperatureEvent"> | string
    hubNo?: IntNullableFilter<"HubTemperatureEvent"> | number | null
    tempCelsius?: FloatNullableFilter<"HubTemperatureEvent"> | number | null
    exType?: StringNullableFilter<"HubTemperatureEvent"> | string | null
    batteryLevel?: IntNullableFilter<"HubTemperatureEvent"> | number | null
    changedAt?: DateTimeFilter<"HubTemperatureEvent"> | Date | string
    createdBy?: UuidNullableFilter<"HubTemperatureEvent"> | string | null
  }

  export type FuelLevelEventUpsertWithWhereUniqueWithoutTruckInput = {
    where: FuelLevelEventWhereUniqueInput
    update: XOR<FuelLevelEventUpdateWithoutTruckInput, FuelLevelEventUncheckedUpdateWithoutTruckInput>
    create: XOR<FuelLevelEventCreateWithoutTruckInput, FuelLevelEventUncheckedCreateWithoutTruckInput>
  }

  export type FuelLevelEventUpdateWithWhereUniqueWithoutTruckInput = {
    where: FuelLevelEventWhereUniqueInput
    data: XOR<FuelLevelEventUpdateWithoutTruckInput, FuelLevelEventUncheckedUpdateWithoutTruckInput>
  }

  export type FuelLevelEventUpdateManyWithWhereWithoutTruckInput = {
    where: FuelLevelEventScalarWhereInput
    data: XOR<FuelLevelEventUpdateManyMutationInput, FuelLevelEventUncheckedUpdateManyWithoutTruckInput>
  }

  export type FuelLevelEventScalarWhereInput = {
    AND?: FuelLevelEventScalarWhereInput | FuelLevelEventScalarWhereInput[]
    OR?: FuelLevelEventScalarWhereInput[]
    NOT?: FuelLevelEventScalarWhereInput | FuelLevelEventScalarWhereInput[]
    id?: UuidFilter<"FuelLevelEvent"> | string
    truckId?: UuidFilter<"FuelLevelEvent"> | string
    fuelPercent?: FloatNullableFilter<"FuelLevelEvent"> | number | null
    changedAt?: DateTimeFilter<"FuelLevelEvent"> | Date | string
    source?: StringNullableFilter<"FuelLevelEvent"> | string | null
    createdBy?: UuidNullableFilter<"FuelLevelEvent"> | string | null
  }

  export type SpeedEventUpsertWithWhereUniqueWithoutTruckInput = {
    where: SpeedEventWhereUniqueInput
    update: XOR<SpeedEventUpdateWithoutTruckInput, SpeedEventUncheckedUpdateWithoutTruckInput>
    create: XOR<SpeedEventCreateWithoutTruckInput, SpeedEventUncheckedCreateWithoutTruckInput>
  }

  export type SpeedEventUpdateWithWhereUniqueWithoutTruckInput = {
    where: SpeedEventWhereUniqueInput
    data: XOR<SpeedEventUpdateWithoutTruckInput, SpeedEventUncheckedUpdateWithoutTruckInput>
  }

  export type SpeedEventUpdateManyWithWhereWithoutTruckInput = {
    where: SpeedEventScalarWhereInput
    data: XOR<SpeedEventUpdateManyMutationInput, SpeedEventUncheckedUpdateManyWithoutTruckInput>
  }

  export type SpeedEventScalarWhereInput = {
    AND?: SpeedEventScalarWhereInput | SpeedEventScalarWhereInput[]
    OR?: SpeedEventScalarWhereInput[]
    NOT?: SpeedEventScalarWhereInput | SpeedEventScalarWhereInput[]
    id?: UuidFilter<"SpeedEvent"> | string
    truckId?: UuidFilter<"SpeedEvent"> | string
    speedKph?: FloatNullableFilter<"SpeedEvent"> | number | null
    changedAt?: DateTimeFilter<"SpeedEvent"> | Date | string
    source?: StringNullableFilter<"SpeedEvent"> | string | null
    createdBy?: UuidNullableFilter<"SpeedEvent"> | string | null
  }

  export type AlertEventUpsertWithWhereUniqueWithoutTruckInput = {
    where: AlertEventWhereUniqueInput
    update: XOR<AlertEventUpdateWithoutTruckInput, AlertEventUncheckedUpdateWithoutTruckInput>
    create: XOR<AlertEventCreateWithoutTruckInput, AlertEventUncheckedCreateWithoutTruckInput>
  }

  export type AlertEventUpdateWithWhereUniqueWithoutTruckInput = {
    where: AlertEventWhereUniqueInput
    data: XOR<AlertEventUpdateWithoutTruckInput, AlertEventUncheckedUpdateWithoutTruckInput>
  }

  export type AlertEventUpdateManyWithWhereWithoutTruckInput = {
    where: AlertEventScalarWhereInput
    data: XOR<AlertEventUpdateManyMutationInput, AlertEventUncheckedUpdateManyWithoutTruckInput>
  }

  export type AlertEventScalarWhereInput = {
    AND?: AlertEventScalarWhereInput | AlertEventScalarWhereInput[]
    OR?: AlertEventScalarWhereInput[]
    NOT?: AlertEventScalarWhereInput | AlertEventScalarWhereInput[]
    id?: UuidFilter<"AlertEvent"> | string
    truckId?: UuidFilter<"AlertEvent"> | string
    type?: EnumAlertTypeFilter<"AlertEvent"> | $Enums.AlertType
    severity?: IntNullableFilter<"AlertEvent"> | number | null
    detail?: JsonNullableFilter<"AlertEvent">
    occurredAt?: DateTimeFilter<"AlertEvent"> | Date | string
    acknowledged?: BoolFilter<"AlertEvent"> | boolean
    createdBy?: UuidNullableFilter<"AlertEvent"> | string | null
  }

  export type DeviceStatusEventUpsertWithWhereUniqueWithoutTruckInput = {
    where: DeviceStatusEventWhereUniqueInput
    update: XOR<DeviceStatusEventUpdateWithoutTruckInput, DeviceStatusEventUncheckedUpdateWithoutTruckInput>
    create: XOR<DeviceStatusEventCreateWithoutTruckInput, DeviceStatusEventUncheckedCreateWithoutTruckInput>
  }

  export type DeviceStatusEventUpdateWithWhereUniqueWithoutTruckInput = {
    where: DeviceStatusEventWhereUniqueInput
    data: XOR<DeviceStatusEventUpdateWithoutTruckInput, DeviceStatusEventUncheckedUpdateWithoutTruckInput>
  }

  export type DeviceStatusEventUpdateManyWithWhereWithoutTruckInput = {
    where: DeviceStatusEventScalarWhereInput
    data: XOR<DeviceStatusEventUpdateManyMutationInput, DeviceStatusEventUncheckedUpdateManyWithoutTruckInput>
  }

  export type DeviceStatusEventScalarWhereInput = {
    AND?: DeviceStatusEventScalarWhereInput | DeviceStatusEventScalarWhereInput[]
    OR?: DeviceStatusEventScalarWhereInput[]
    NOT?: DeviceStatusEventScalarWhereInput | DeviceStatusEventScalarWhereInput[]
    id?: UuidFilter<"DeviceStatusEvent"> | string
    deviceId?: UuidFilter<"DeviceStatusEvent"> | string
    truckId?: UuidFilter<"DeviceStatusEvent"> | string
    hostBat?: IntNullableFilter<"DeviceStatusEvent"> | number | null
    repeater1Bat?: IntNullableFilter<"DeviceStatusEvent"> | number | null
    repeater2Bat?: IntNullableFilter<"DeviceStatusEvent"> | number | null
    lockState?: IntNullableFilter<"DeviceStatusEvent"> | number | null
    reportedAt?: DateTimeFilter<"DeviceStatusEvent"> | Date | string
    createdBy?: UuidNullableFilter<"DeviceStatusEvent"> | string | null
  }

  export type LockEventUpsertWithWhereUniqueWithoutTruckInput = {
    where: LockEventWhereUniqueInput
    update: XOR<LockEventUpdateWithoutTruckInput, LockEventUncheckedUpdateWithoutTruckInput>
    create: XOR<LockEventCreateWithoutTruckInput, LockEventUncheckedCreateWithoutTruckInput>
  }

  export type LockEventUpdateWithWhereUniqueWithoutTruckInput = {
    where: LockEventWhereUniqueInput
    data: XOR<LockEventUpdateWithoutTruckInput, LockEventUncheckedUpdateWithoutTruckInput>
  }

  export type LockEventUpdateManyWithWhereWithoutTruckInput = {
    where: LockEventScalarWhereInput
    data: XOR<LockEventUpdateManyMutationInput, LockEventUncheckedUpdateManyWithoutTruckInput>
  }

  export type LockEventScalarWhereInput = {
    AND?: LockEventScalarWhereInput | LockEventScalarWhereInput[]
    OR?: LockEventScalarWhereInput[]
    NOT?: LockEventScalarWhereInput | LockEventScalarWhereInput[]
    id?: UuidFilter<"LockEvent"> | string
    deviceId?: UuidFilter<"LockEvent"> | string
    truckId?: UuidFilter<"LockEvent"> | string
    isLock?: IntNullableFilter<"LockEvent"> | number | null
    reportedAt?: DateTimeFilter<"LockEvent"> | Date | string
    createdBy?: UuidNullableFilter<"LockEvent"> | string | null
  }

  export type DailyRouteUpsertWithWhereUniqueWithoutTruckInput = {
    where: DailyRouteWhereUniqueInput
    update: XOR<DailyRouteUpdateWithoutTruckInput, DailyRouteUncheckedUpdateWithoutTruckInput>
    create: XOR<DailyRouteCreateWithoutTruckInput, DailyRouteUncheckedCreateWithoutTruckInput>
  }

  export type DailyRouteUpdateWithWhereUniqueWithoutTruckInput = {
    where: DailyRouteWhereUniqueInput
    data: XOR<DailyRouteUpdateWithoutTruckInput, DailyRouteUncheckedUpdateWithoutTruckInput>
  }

  export type DailyRouteUpdateManyWithWhereWithoutTruckInput = {
    where: DailyRouteScalarWhereInput
    data: XOR<DailyRouteUpdateManyMutationInput, DailyRouteUncheckedUpdateManyWithoutTruckInput>
  }

  export type DailyRouteScalarWhereInput = {
    AND?: DailyRouteScalarWhereInput | DailyRouteScalarWhereInput[]
    OR?: DailyRouteScalarWhereInput[]
    NOT?: DailyRouteScalarWhereInput | DailyRouteScalarWhereInput[]
    id?: UuidFilter<"DailyRoute"> | string
    truckId?: UuidFilter<"DailyRoute"> | string
    routeDate?: DateTimeFilter<"DailyRoute"> | Date | string
    pointCount?: IntFilter<"DailyRoute"> | number
    generatedAt?: DateTimeFilter<"DailyRoute"> | Date | string
    createdBy?: UuidNullableFilter<"DailyRoute"> | string | null
  }

  export type TruckCreateWithoutDevicesInput = {
    id?: string
    plateNumber: string
    vin?: string | null
    name?: string | null
    model?: string | null
    year?: number | null
    tireConfig?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    fleetGroup?: FleetGroupCreateNestedOneWithoutTrucksInput
    truckStatusEvents?: TruckStatusEventCreateNestedManyWithoutTruckInput
    gpsPositions?: GpsPositionCreateNestedManyWithoutTruckInput
    trips?: TripCreateNestedManyWithoutTruckInput
    tirePressureEvents?: TirePressureEventCreateNestedManyWithoutTruckInput
    hubTemperatureEvents?: HubTemperatureEventCreateNestedManyWithoutTruckInput
    fuelLevelEvents?: FuelLevelEventCreateNestedManyWithoutTruckInput
    speedEvents?: SpeedEventCreateNestedManyWithoutTruckInput
    alertEvents?: AlertEventCreateNestedManyWithoutTruckInput
    deviceStatusEvents?: DeviceStatusEventCreateNestedManyWithoutTruckInput
    lockEvents?: LockEventCreateNestedManyWithoutTruckInput
    dailyRoutes?: DailyRouteCreateNestedManyWithoutTruckInput
  }

  export type TruckUncheckedCreateWithoutDevicesInput = {
    id?: string
    plateNumber: string
    vin?: string | null
    name?: string | null
    model?: string | null
    year?: number | null
    tireConfig?: string | null
    fleetGroupId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    truckStatusEvents?: TruckStatusEventUncheckedCreateNestedManyWithoutTruckInput
    gpsPositions?: GpsPositionUncheckedCreateNestedManyWithoutTruckInput
    trips?: TripUncheckedCreateNestedManyWithoutTruckInput
    tirePressureEvents?: TirePressureEventUncheckedCreateNestedManyWithoutTruckInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedCreateNestedManyWithoutTruckInput
    fuelLevelEvents?: FuelLevelEventUncheckedCreateNestedManyWithoutTruckInput
    speedEvents?: SpeedEventUncheckedCreateNestedManyWithoutTruckInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutTruckInput
    deviceStatusEvents?: DeviceStatusEventUncheckedCreateNestedManyWithoutTruckInput
    lockEvents?: LockEventUncheckedCreateNestedManyWithoutTruckInput
    dailyRoutes?: DailyRouteUncheckedCreateNestedManyWithoutTruckInput
  }

  export type TruckCreateOrConnectWithoutDevicesInput = {
    where: TruckWhereUniqueInput
    create: XOR<TruckCreateWithoutDevicesInput, TruckUncheckedCreateWithoutDevicesInput>
  }

  export type SensorCreateWithoutDeviceInput = {
    id?: string
    type: string
    positionNo: number
    sn?: string | null
    installedAt?: Date | string | null
    removedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type SensorUncheckedCreateWithoutDeviceInput = {
    id?: string
    type: string
    positionNo: number
    sn?: string | null
    installedAt?: Date | string | null
    removedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type SensorCreateOrConnectWithoutDeviceInput = {
    where: SensorWhereUniqueInput
    create: XOR<SensorCreateWithoutDeviceInput, SensorUncheckedCreateWithoutDeviceInput>
  }

  export type SensorCreateManyDeviceInputEnvelope = {
    data: SensorCreateManyDeviceInput | SensorCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type GpsPositionCreateWithoutDeviceInput = {
    id?: bigint | number
    ts: Date | string
    speedKph?: number | null
    headingDeg?: number | null
    hdop?: number | null
    source?: string | null
    truck: TruckCreateNestedOneWithoutGpsPositionsInput
  }

  export type GpsPositionUncheckedCreateWithoutDeviceInput = {
    id?: bigint | number
    truckId: string
    ts: Date | string
    speedKph?: number | null
    headingDeg?: number | null
    hdop?: number | null
    source?: string | null
  }

  export type GpsPositionCreateOrConnectWithoutDeviceInput = {
    where: GpsPositionWhereUniqueInput
    create: XOR<GpsPositionCreateWithoutDeviceInput, GpsPositionUncheckedCreateWithoutDeviceInput>
  }

  export type GpsPositionCreateManyDeviceInputEnvelope = {
    data: GpsPositionCreateManyDeviceInput | GpsPositionCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type TirePressureEventCreateWithoutDeviceInput = {
    id?: string
    tireNo: number
    pressureKpa?: number | null
    tempCelsius?: number | null
    exType?: string | null
    batteryLevel?: number | null
    changedAt?: Date | string
    createdBy?: string | null
    truck: TruckCreateNestedOneWithoutTirePressureEventsInput
  }

  export type TirePressureEventUncheckedCreateWithoutDeviceInput = {
    id?: string
    truckId: string
    tireNo: number
    pressureKpa?: number | null
    tempCelsius?: number | null
    exType?: string | null
    batteryLevel?: number | null
    changedAt?: Date | string
    createdBy?: string | null
  }

  export type TirePressureEventCreateOrConnectWithoutDeviceInput = {
    where: TirePressureEventWhereUniqueInput
    create: XOR<TirePressureEventCreateWithoutDeviceInput, TirePressureEventUncheckedCreateWithoutDeviceInput>
  }

  export type TirePressureEventCreateManyDeviceInputEnvelope = {
    data: TirePressureEventCreateManyDeviceInput | TirePressureEventCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type HubTemperatureEventCreateWithoutDeviceInput = {
    id?: string
    hubNo?: number | null
    tempCelsius?: number | null
    exType?: string | null
    batteryLevel?: number | null
    changedAt?: Date | string
    createdBy?: string | null
    truck: TruckCreateNestedOneWithoutHubTemperatureEventsInput
  }

  export type HubTemperatureEventUncheckedCreateWithoutDeviceInput = {
    id?: string
    truckId: string
    hubNo?: number | null
    tempCelsius?: number | null
    exType?: string | null
    batteryLevel?: number | null
    changedAt?: Date | string
    createdBy?: string | null
  }

  export type HubTemperatureEventCreateOrConnectWithoutDeviceInput = {
    where: HubTemperatureEventWhereUniqueInput
    create: XOR<HubTemperatureEventCreateWithoutDeviceInput, HubTemperatureEventUncheckedCreateWithoutDeviceInput>
  }

  export type HubTemperatureEventCreateManyDeviceInputEnvelope = {
    data: HubTemperatureEventCreateManyDeviceInput | HubTemperatureEventCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type DeviceStatusEventCreateWithoutDeviceInput = {
    id?: string
    hostBat?: number | null
    repeater1Bat?: number | null
    repeater2Bat?: number | null
    lockState?: number | null
    reportedAt?: Date | string
    createdBy?: string | null
    truck: TruckCreateNestedOneWithoutDeviceStatusEventsInput
  }

  export type DeviceStatusEventUncheckedCreateWithoutDeviceInput = {
    id?: string
    truckId: string
    hostBat?: number | null
    repeater1Bat?: number | null
    repeater2Bat?: number | null
    lockState?: number | null
    reportedAt?: Date | string
    createdBy?: string | null
  }

  export type DeviceStatusEventCreateOrConnectWithoutDeviceInput = {
    where: DeviceStatusEventWhereUniqueInput
    create: XOR<DeviceStatusEventCreateWithoutDeviceInput, DeviceStatusEventUncheckedCreateWithoutDeviceInput>
  }

  export type DeviceStatusEventCreateManyDeviceInputEnvelope = {
    data: DeviceStatusEventCreateManyDeviceInput | DeviceStatusEventCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type LockEventCreateWithoutDeviceInput = {
    id?: string
    isLock?: number | null
    reportedAt?: Date | string
    createdBy?: string | null
    truck: TruckCreateNestedOneWithoutLockEventsInput
  }

  export type LockEventUncheckedCreateWithoutDeviceInput = {
    id?: string
    truckId: string
    isLock?: number | null
    reportedAt?: Date | string
    createdBy?: string | null
  }

  export type LockEventCreateOrConnectWithoutDeviceInput = {
    where: LockEventWhereUniqueInput
    create: XOR<LockEventCreateWithoutDeviceInput, LockEventUncheckedCreateWithoutDeviceInput>
  }

  export type LockEventCreateManyDeviceInputEnvelope = {
    data: LockEventCreateManyDeviceInput | LockEventCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type TruckUpsertWithoutDevicesInput = {
    update: XOR<TruckUpdateWithoutDevicesInput, TruckUncheckedUpdateWithoutDevicesInput>
    create: XOR<TruckCreateWithoutDevicesInput, TruckUncheckedCreateWithoutDevicesInput>
    where?: TruckWhereInput
  }

  export type TruckUpdateToOneWithWhereWithoutDevicesInput = {
    where?: TruckWhereInput
    data: XOR<TruckUpdateWithoutDevicesInput, TruckUncheckedUpdateWithoutDevicesInput>
  }

  export type TruckUpdateWithoutDevicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    fleetGroup?: FleetGroupUpdateOneWithoutTrucksNestedInput
    truckStatusEvents?: TruckStatusEventUpdateManyWithoutTruckNestedInput
    gpsPositions?: GpsPositionUpdateManyWithoutTruckNestedInput
    trips?: TripUpdateManyWithoutTruckNestedInput
    tirePressureEvents?: TirePressureEventUpdateManyWithoutTruckNestedInput
    hubTemperatureEvents?: HubTemperatureEventUpdateManyWithoutTruckNestedInput
    fuelLevelEvents?: FuelLevelEventUpdateManyWithoutTruckNestedInput
    speedEvents?: SpeedEventUpdateManyWithoutTruckNestedInput
    alertEvents?: AlertEventUpdateManyWithoutTruckNestedInput
    deviceStatusEvents?: DeviceStatusEventUpdateManyWithoutTruckNestedInput
    lockEvents?: LockEventUpdateManyWithoutTruckNestedInput
    dailyRoutes?: DailyRouteUpdateManyWithoutTruckNestedInput
  }

  export type TruckUncheckedUpdateWithoutDevicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    fleetGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    truckStatusEvents?: TruckStatusEventUncheckedUpdateManyWithoutTruckNestedInput
    gpsPositions?: GpsPositionUncheckedUpdateManyWithoutTruckNestedInput
    trips?: TripUncheckedUpdateManyWithoutTruckNestedInput
    tirePressureEvents?: TirePressureEventUncheckedUpdateManyWithoutTruckNestedInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedUpdateManyWithoutTruckNestedInput
    fuelLevelEvents?: FuelLevelEventUncheckedUpdateManyWithoutTruckNestedInput
    speedEvents?: SpeedEventUncheckedUpdateManyWithoutTruckNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutTruckNestedInput
    deviceStatusEvents?: DeviceStatusEventUncheckedUpdateManyWithoutTruckNestedInput
    lockEvents?: LockEventUncheckedUpdateManyWithoutTruckNestedInput
    dailyRoutes?: DailyRouteUncheckedUpdateManyWithoutTruckNestedInput
  }

  export type SensorUpsertWithWhereUniqueWithoutDeviceInput = {
    where: SensorWhereUniqueInput
    update: XOR<SensorUpdateWithoutDeviceInput, SensorUncheckedUpdateWithoutDeviceInput>
    create: XOR<SensorCreateWithoutDeviceInput, SensorUncheckedCreateWithoutDeviceInput>
  }

  export type SensorUpdateWithWhereUniqueWithoutDeviceInput = {
    where: SensorWhereUniqueInput
    data: XOR<SensorUpdateWithoutDeviceInput, SensorUncheckedUpdateWithoutDeviceInput>
  }

  export type SensorUpdateManyWithWhereWithoutDeviceInput = {
    where: SensorScalarWhereInput
    data: XOR<SensorUpdateManyMutationInput, SensorUncheckedUpdateManyWithoutDeviceInput>
  }

  export type SensorScalarWhereInput = {
    AND?: SensorScalarWhereInput | SensorScalarWhereInput[]
    OR?: SensorScalarWhereInput[]
    NOT?: SensorScalarWhereInput | SensorScalarWhereInput[]
    id?: UuidFilter<"Sensor"> | string
    deviceId?: UuidFilter<"Sensor"> | string
    type?: StringFilter<"Sensor"> | string
    positionNo?: IntFilter<"Sensor"> | number
    sn?: StringNullableFilter<"Sensor"> | string | null
    installedAt?: DateTimeNullableFilter<"Sensor"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"Sensor"> | Date | string | null
    createdBy?: UuidNullableFilter<"Sensor"> | string | null
    updatedBy?: UuidNullableFilter<"Sensor"> | string | null
  }

  export type GpsPositionUpsertWithWhereUniqueWithoutDeviceInput = {
    where: GpsPositionWhereUniqueInput
    update: XOR<GpsPositionUpdateWithoutDeviceInput, GpsPositionUncheckedUpdateWithoutDeviceInput>
    create: XOR<GpsPositionCreateWithoutDeviceInput, GpsPositionUncheckedCreateWithoutDeviceInput>
  }

  export type GpsPositionUpdateWithWhereUniqueWithoutDeviceInput = {
    where: GpsPositionWhereUniqueInput
    data: XOR<GpsPositionUpdateWithoutDeviceInput, GpsPositionUncheckedUpdateWithoutDeviceInput>
  }

  export type GpsPositionUpdateManyWithWhereWithoutDeviceInput = {
    where: GpsPositionScalarWhereInput
    data: XOR<GpsPositionUpdateManyMutationInput, GpsPositionUncheckedUpdateManyWithoutDeviceInput>
  }

  export type TirePressureEventUpsertWithWhereUniqueWithoutDeviceInput = {
    where: TirePressureEventWhereUniqueInput
    update: XOR<TirePressureEventUpdateWithoutDeviceInput, TirePressureEventUncheckedUpdateWithoutDeviceInput>
    create: XOR<TirePressureEventCreateWithoutDeviceInput, TirePressureEventUncheckedCreateWithoutDeviceInput>
  }

  export type TirePressureEventUpdateWithWhereUniqueWithoutDeviceInput = {
    where: TirePressureEventWhereUniqueInput
    data: XOR<TirePressureEventUpdateWithoutDeviceInput, TirePressureEventUncheckedUpdateWithoutDeviceInput>
  }

  export type TirePressureEventUpdateManyWithWhereWithoutDeviceInput = {
    where: TirePressureEventScalarWhereInput
    data: XOR<TirePressureEventUpdateManyMutationInput, TirePressureEventUncheckedUpdateManyWithoutDeviceInput>
  }

  export type HubTemperatureEventUpsertWithWhereUniqueWithoutDeviceInput = {
    where: HubTemperatureEventWhereUniqueInput
    update: XOR<HubTemperatureEventUpdateWithoutDeviceInput, HubTemperatureEventUncheckedUpdateWithoutDeviceInput>
    create: XOR<HubTemperatureEventCreateWithoutDeviceInput, HubTemperatureEventUncheckedCreateWithoutDeviceInput>
  }

  export type HubTemperatureEventUpdateWithWhereUniqueWithoutDeviceInput = {
    where: HubTemperatureEventWhereUniqueInput
    data: XOR<HubTemperatureEventUpdateWithoutDeviceInput, HubTemperatureEventUncheckedUpdateWithoutDeviceInput>
  }

  export type HubTemperatureEventUpdateManyWithWhereWithoutDeviceInput = {
    where: HubTemperatureEventScalarWhereInput
    data: XOR<HubTemperatureEventUpdateManyMutationInput, HubTemperatureEventUncheckedUpdateManyWithoutDeviceInput>
  }

  export type DeviceStatusEventUpsertWithWhereUniqueWithoutDeviceInput = {
    where: DeviceStatusEventWhereUniqueInput
    update: XOR<DeviceStatusEventUpdateWithoutDeviceInput, DeviceStatusEventUncheckedUpdateWithoutDeviceInput>
    create: XOR<DeviceStatusEventCreateWithoutDeviceInput, DeviceStatusEventUncheckedCreateWithoutDeviceInput>
  }

  export type DeviceStatusEventUpdateWithWhereUniqueWithoutDeviceInput = {
    where: DeviceStatusEventWhereUniqueInput
    data: XOR<DeviceStatusEventUpdateWithoutDeviceInput, DeviceStatusEventUncheckedUpdateWithoutDeviceInput>
  }

  export type DeviceStatusEventUpdateManyWithWhereWithoutDeviceInput = {
    where: DeviceStatusEventScalarWhereInput
    data: XOR<DeviceStatusEventUpdateManyMutationInput, DeviceStatusEventUncheckedUpdateManyWithoutDeviceInput>
  }

  export type LockEventUpsertWithWhereUniqueWithoutDeviceInput = {
    where: LockEventWhereUniqueInput
    update: XOR<LockEventUpdateWithoutDeviceInput, LockEventUncheckedUpdateWithoutDeviceInput>
    create: XOR<LockEventCreateWithoutDeviceInput, LockEventUncheckedCreateWithoutDeviceInput>
  }

  export type LockEventUpdateWithWhereUniqueWithoutDeviceInput = {
    where: LockEventWhereUniqueInput
    data: XOR<LockEventUpdateWithoutDeviceInput, LockEventUncheckedUpdateWithoutDeviceInput>
  }

  export type LockEventUpdateManyWithWhereWithoutDeviceInput = {
    where: LockEventScalarWhereInput
    data: XOR<LockEventUpdateManyMutationInput, LockEventUncheckedUpdateManyWithoutDeviceInput>
  }

  export type DeviceCreateWithoutSensorsInput = {
    id?: string
    sn: string
    simNumber?: string | null
    installedAt?: Date | string
    removedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    truck: TruckCreateNestedOneWithoutDevicesInput
    gpsPositions?: GpsPositionCreateNestedManyWithoutDeviceInput
    tirePressureEvents?: TirePressureEventCreateNestedManyWithoutDeviceInput
    hubTemperatureEvents?: HubTemperatureEventCreateNestedManyWithoutDeviceInput
    deviceStatusEvents?: DeviceStatusEventCreateNestedManyWithoutDeviceInput
    lockEvents?: LockEventCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutSensorsInput = {
    id?: string
    truckId: string
    sn: string
    simNumber?: string | null
    installedAt?: Date | string
    removedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    gpsPositions?: GpsPositionUncheckedCreateNestedManyWithoutDeviceInput
    tirePressureEvents?: TirePressureEventUncheckedCreateNestedManyWithoutDeviceInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedCreateNestedManyWithoutDeviceInput
    deviceStatusEvents?: DeviceStatusEventUncheckedCreateNestedManyWithoutDeviceInput
    lockEvents?: LockEventUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutSensorsInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutSensorsInput, DeviceUncheckedCreateWithoutSensorsInput>
  }

  export type DeviceUpsertWithoutSensorsInput = {
    update: XOR<DeviceUpdateWithoutSensorsInput, DeviceUncheckedUpdateWithoutSensorsInput>
    create: XOR<DeviceCreateWithoutSensorsInput, DeviceUncheckedCreateWithoutSensorsInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutSensorsInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutSensorsInput, DeviceUncheckedUpdateWithoutSensorsInput>
  }

  export type DeviceUpdateWithoutSensorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sn?: StringFieldUpdateOperationsInput | string
    simNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    truck?: TruckUpdateOneRequiredWithoutDevicesNestedInput
    gpsPositions?: GpsPositionUpdateManyWithoutDeviceNestedInput
    tirePressureEvents?: TirePressureEventUpdateManyWithoutDeviceNestedInput
    hubTemperatureEvents?: HubTemperatureEventUpdateManyWithoutDeviceNestedInput
    deviceStatusEvents?: DeviceStatusEventUpdateManyWithoutDeviceNestedInput
    lockEvents?: LockEventUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutSensorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    sn?: StringFieldUpdateOperationsInput | string
    simNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    gpsPositions?: GpsPositionUncheckedUpdateManyWithoutDeviceNestedInput
    tirePressureEvents?: TirePressureEventUncheckedUpdateManyWithoutDeviceNestedInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedUpdateManyWithoutDeviceNestedInput
    deviceStatusEvents?: DeviceStatusEventUncheckedUpdateManyWithoutDeviceNestedInput
    lockEvents?: LockEventUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type TruckCreateWithoutTruckStatusEventsInput = {
    id?: string
    plateNumber: string
    vin?: string | null
    name?: string | null
    model?: string | null
    year?: number | null
    tireConfig?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    fleetGroup?: FleetGroupCreateNestedOneWithoutTrucksInput
    devices?: DeviceCreateNestedManyWithoutTruckInput
    gpsPositions?: GpsPositionCreateNestedManyWithoutTruckInput
    trips?: TripCreateNestedManyWithoutTruckInput
    tirePressureEvents?: TirePressureEventCreateNestedManyWithoutTruckInput
    hubTemperatureEvents?: HubTemperatureEventCreateNestedManyWithoutTruckInput
    fuelLevelEvents?: FuelLevelEventCreateNestedManyWithoutTruckInput
    speedEvents?: SpeedEventCreateNestedManyWithoutTruckInput
    alertEvents?: AlertEventCreateNestedManyWithoutTruckInput
    deviceStatusEvents?: DeviceStatusEventCreateNestedManyWithoutTruckInput
    lockEvents?: LockEventCreateNestedManyWithoutTruckInput
    dailyRoutes?: DailyRouteCreateNestedManyWithoutTruckInput
  }

  export type TruckUncheckedCreateWithoutTruckStatusEventsInput = {
    id?: string
    plateNumber: string
    vin?: string | null
    name?: string | null
    model?: string | null
    year?: number | null
    tireConfig?: string | null
    fleetGroupId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    devices?: DeviceUncheckedCreateNestedManyWithoutTruckInput
    gpsPositions?: GpsPositionUncheckedCreateNestedManyWithoutTruckInput
    trips?: TripUncheckedCreateNestedManyWithoutTruckInput
    tirePressureEvents?: TirePressureEventUncheckedCreateNestedManyWithoutTruckInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedCreateNestedManyWithoutTruckInput
    fuelLevelEvents?: FuelLevelEventUncheckedCreateNestedManyWithoutTruckInput
    speedEvents?: SpeedEventUncheckedCreateNestedManyWithoutTruckInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutTruckInput
    deviceStatusEvents?: DeviceStatusEventUncheckedCreateNestedManyWithoutTruckInput
    lockEvents?: LockEventUncheckedCreateNestedManyWithoutTruckInput
    dailyRoutes?: DailyRouteUncheckedCreateNestedManyWithoutTruckInput
  }

  export type TruckCreateOrConnectWithoutTruckStatusEventsInput = {
    where: TruckWhereUniqueInput
    create: XOR<TruckCreateWithoutTruckStatusEventsInput, TruckUncheckedCreateWithoutTruckStatusEventsInput>
  }

  export type TruckUpsertWithoutTruckStatusEventsInput = {
    update: XOR<TruckUpdateWithoutTruckStatusEventsInput, TruckUncheckedUpdateWithoutTruckStatusEventsInput>
    create: XOR<TruckCreateWithoutTruckStatusEventsInput, TruckUncheckedCreateWithoutTruckStatusEventsInput>
    where?: TruckWhereInput
  }

  export type TruckUpdateToOneWithWhereWithoutTruckStatusEventsInput = {
    where?: TruckWhereInput
    data: XOR<TruckUpdateWithoutTruckStatusEventsInput, TruckUncheckedUpdateWithoutTruckStatusEventsInput>
  }

  export type TruckUpdateWithoutTruckStatusEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    fleetGroup?: FleetGroupUpdateOneWithoutTrucksNestedInput
    devices?: DeviceUpdateManyWithoutTruckNestedInput
    gpsPositions?: GpsPositionUpdateManyWithoutTruckNestedInput
    trips?: TripUpdateManyWithoutTruckNestedInput
    tirePressureEvents?: TirePressureEventUpdateManyWithoutTruckNestedInput
    hubTemperatureEvents?: HubTemperatureEventUpdateManyWithoutTruckNestedInput
    fuelLevelEvents?: FuelLevelEventUpdateManyWithoutTruckNestedInput
    speedEvents?: SpeedEventUpdateManyWithoutTruckNestedInput
    alertEvents?: AlertEventUpdateManyWithoutTruckNestedInput
    deviceStatusEvents?: DeviceStatusEventUpdateManyWithoutTruckNestedInput
    lockEvents?: LockEventUpdateManyWithoutTruckNestedInput
    dailyRoutes?: DailyRouteUpdateManyWithoutTruckNestedInput
  }

  export type TruckUncheckedUpdateWithoutTruckStatusEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    fleetGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    devices?: DeviceUncheckedUpdateManyWithoutTruckNestedInput
    gpsPositions?: GpsPositionUncheckedUpdateManyWithoutTruckNestedInput
    trips?: TripUncheckedUpdateManyWithoutTruckNestedInput
    tirePressureEvents?: TirePressureEventUncheckedUpdateManyWithoutTruckNestedInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedUpdateManyWithoutTruckNestedInput
    fuelLevelEvents?: FuelLevelEventUncheckedUpdateManyWithoutTruckNestedInput
    speedEvents?: SpeedEventUncheckedUpdateManyWithoutTruckNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutTruckNestedInput
    deviceStatusEvents?: DeviceStatusEventUncheckedUpdateManyWithoutTruckNestedInput
    lockEvents?: LockEventUncheckedUpdateManyWithoutTruckNestedInput
    dailyRoutes?: DailyRouteUncheckedUpdateManyWithoutTruckNestedInput
  }

  export type DeviceCreateWithoutGpsPositionsInput = {
    id?: string
    sn: string
    simNumber?: string | null
    installedAt?: Date | string
    removedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    truck: TruckCreateNestedOneWithoutDevicesInput
    sensors?: SensorCreateNestedManyWithoutDeviceInput
    tirePressureEvents?: TirePressureEventCreateNestedManyWithoutDeviceInput
    hubTemperatureEvents?: HubTemperatureEventCreateNestedManyWithoutDeviceInput
    deviceStatusEvents?: DeviceStatusEventCreateNestedManyWithoutDeviceInput
    lockEvents?: LockEventCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutGpsPositionsInput = {
    id?: string
    truckId: string
    sn: string
    simNumber?: string | null
    installedAt?: Date | string
    removedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    sensors?: SensorUncheckedCreateNestedManyWithoutDeviceInput
    tirePressureEvents?: TirePressureEventUncheckedCreateNestedManyWithoutDeviceInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedCreateNestedManyWithoutDeviceInput
    deviceStatusEvents?: DeviceStatusEventUncheckedCreateNestedManyWithoutDeviceInput
    lockEvents?: LockEventUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutGpsPositionsInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutGpsPositionsInput, DeviceUncheckedCreateWithoutGpsPositionsInput>
  }

  export type TruckCreateWithoutGpsPositionsInput = {
    id?: string
    plateNumber: string
    vin?: string | null
    name?: string | null
    model?: string | null
    year?: number | null
    tireConfig?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    fleetGroup?: FleetGroupCreateNestedOneWithoutTrucksInput
    devices?: DeviceCreateNestedManyWithoutTruckInput
    truckStatusEvents?: TruckStatusEventCreateNestedManyWithoutTruckInput
    trips?: TripCreateNestedManyWithoutTruckInput
    tirePressureEvents?: TirePressureEventCreateNestedManyWithoutTruckInput
    hubTemperatureEvents?: HubTemperatureEventCreateNestedManyWithoutTruckInput
    fuelLevelEvents?: FuelLevelEventCreateNestedManyWithoutTruckInput
    speedEvents?: SpeedEventCreateNestedManyWithoutTruckInput
    alertEvents?: AlertEventCreateNestedManyWithoutTruckInput
    deviceStatusEvents?: DeviceStatusEventCreateNestedManyWithoutTruckInput
    lockEvents?: LockEventCreateNestedManyWithoutTruckInput
    dailyRoutes?: DailyRouteCreateNestedManyWithoutTruckInput
  }

  export type TruckUncheckedCreateWithoutGpsPositionsInput = {
    id?: string
    plateNumber: string
    vin?: string | null
    name?: string | null
    model?: string | null
    year?: number | null
    tireConfig?: string | null
    fleetGroupId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    devices?: DeviceUncheckedCreateNestedManyWithoutTruckInput
    truckStatusEvents?: TruckStatusEventUncheckedCreateNestedManyWithoutTruckInput
    trips?: TripUncheckedCreateNestedManyWithoutTruckInput
    tirePressureEvents?: TirePressureEventUncheckedCreateNestedManyWithoutTruckInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedCreateNestedManyWithoutTruckInput
    fuelLevelEvents?: FuelLevelEventUncheckedCreateNestedManyWithoutTruckInput
    speedEvents?: SpeedEventUncheckedCreateNestedManyWithoutTruckInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutTruckInput
    deviceStatusEvents?: DeviceStatusEventUncheckedCreateNestedManyWithoutTruckInput
    lockEvents?: LockEventUncheckedCreateNestedManyWithoutTruckInput
    dailyRoutes?: DailyRouteUncheckedCreateNestedManyWithoutTruckInput
  }

  export type TruckCreateOrConnectWithoutGpsPositionsInput = {
    where: TruckWhereUniqueInput
    create: XOR<TruckCreateWithoutGpsPositionsInput, TruckUncheckedCreateWithoutGpsPositionsInput>
  }

  export type DeviceUpsertWithoutGpsPositionsInput = {
    update: XOR<DeviceUpdateWithoutGpsPositionsInput, DeviceUncheckedUpdateWithoutGpsPositionsInput>
    create: XOR<DeviceCreateWithoutGpsPositionsInput, DeviceUncheckedCreateWithoutGpsPositionsInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutGpsPositionsInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutGpsPositionsInput, DeviceUncheckedUpdateWithoutGpsPositionsInput>
  }

  export type DeviceUpdateWithoutGpsPositionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sn?: StringFieldUpdateOperationsInput | string
    simNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    truck?: TruckUpdateOneRequiredWithoutDevicesNestedInput
    sensors?: SensorUpdateManyWithoutDeviceNestedInput
    tirePressureEvents?: TirePressureEventUpdateManyWithoutDeviceNestedInput
    hubTemperatureEvents?: HubTemperatureEventUpdateManyWithoutDeviceNestedInput
    deviceStatusEvents?: DeviceStatusEventUpdateManyWithoutDeviceNestedInput
    lockEvents?: LockEventUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutGpsPositionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    sn?: StringFieldUpdateOperationsInput | string
    simNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sensors?: SensorUncheckedUpdateManyWithoutDeviceNestedInput
    tirePressureEvents?: TirePressureEventUncheckedUpdateManyWithoutDeviceNestedInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedUpdateManyWithoutDeviceNestedInput
    deviceStatusEvents?: DeviceStatusEventUncheckedUpdateManyWithoutDeviceNestedInput
    lockEvents?: LockEventUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type TruckUpsertWithoutGpsPositionsInput = {
    update: XOR<TruckUpdateWithoutGpsPositionsInput, TruckUncheckedUpdateWithoutGpsPositionsInput>
    create: XOR<TruckCreateWithoutGpsPositionsInput, TruckUncheckedCreateWithoutGpsPositionsInput>
    where?: TruckWhereInput
  }

  export type TruckUpdateToOneWithWhereWithoutGpsPositionsInput = {
    where?: TruckWhereInput
    data: XOR<TruckUpdateWithoutGpsPositionsInput, TruckUncheckedUpdateWithoutGpsPositionsInput>
  }

  export type TruckUpdateWithoutGpsPositionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    fleetGroup?: FleetGroupUpdateOneWithoutTrucksNestedInput
    devices?: DeviceUpdateManyWithoutTruckNestedInput
    truckStatusEvents?: TruckStatusEventUpdateManyWithoutTruckNestedInput
    trips?: TripUpdateManyWithoutTruckNestedInput
    tirePressureEvents?: TirePressureEventUpdateManyWithoutTruckNestedInput
    hubTemperatureEvents?: HubTemperatureEventUpdateManyWithoutTruckNestedInput
    fuelLevelEvents?: FuelLevelEventUpdateManyWithoutTruckNestedInput
    speedEvents?: SpeedEventUpdateManyWithoutTruckNestedInput
    alertEvents?: AlertEventUpdateManyWithoutTruckNestedInput
    deviceStatusEvents?: DeviceStatusEventUpdateManyWithoutTruckNestedInput
    lockEvents?: LockEventUpdateManyWithoutTruckNestedInput
    dailyRoutes?: DailyRouteUpdateManyWithoutTruckNestedInput
  }

  export type TruckUncheckedUpdateWithoutGpsPositionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    fleetGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    devices?: DeviceUncheckedUpdateManyWithoutTruckNestedInput
    truckStatusEvents?: TruckStatusEventUncheckedUpdateManyWithoutTruckNestedInput
    trips?: TripUncheckedUpdateManyWithoutTruckNestedInput
    tirePressureEvents?: TirePressureEventUncheckedUpdateManyWithoutTruckNestedInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedUpdateManyWithoutTruckNestedInput
    fuelLevelEvents?: FuelLevelEventUncheckedUpdateManyWithoutTruckNestedInput
    speedEvents?: SpeedEventUncheckedUpdateManyWithoutTruckNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutTruckNestedInput
    deviceStatusEvents?: DeviceStatusEventUncheckedUpdateManyWithoutTruckNestedInput
    lockEvents?: LockEventUncheckedUpdateManyWithoutTruckNestedInput
    dailyRoutes?: DailyRouteUncheckedUpdateManyWithoutTruckNestedInput
  }

  export type TruckCreateWithoutTripsInput = {
    id?: string
    plateNumber: string
    vin?: string | null
    name?: string | null
    model?: string | null
    year?: number | null
    tireConfig?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    fleetGroup?: FleetGroupCreateNestedOneWithoutTrucksInput
    devices?: DeviceCreateNestedManyWithoutTruckInput
    truckStatusEvents?: TruckStatusEventCreateNestedManyWithoutTruckInput
    gpsPositions?: GpsPositionCreateNestedManyWithoutTruckInput
    tirePressureEvents?: TirePressureEventCreateNestedManyWithoutTruckInput
    hubTemperatureEvents?: HubTemperatureEventCreateNestedManyWithoutTruckInput
    fuelLevelEvents?: FuelLevelEventCreateNestedManyWithoutTruckInput
    speedEvents?: SpeedEventCreateNestedManyWithoutTruckInput
    alertEvents?: AlertEventCreateNestedManyWithoutTruckInput
    deviceStatusEvents?: DeviceStatusEventCreateNestedManyWithoutTruckInput
    lockEvents?: LockEventCreateNestedManyWithoutTruckInput
    dailyRoutes?: DailyRouteCreateNestedManyWithoutTruckInput
  }

  export type TruckUncheckedCreateWithoutTripsInput = {
    id?: string
    plateNumber: string
    vin?: string | null
    name?: string | null
    model?: string | null
    year?: number | null
    tireConfig?: string | null
    fleetGroupId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    devices?: DeviceUncheckedCreateNestedManyWithoutTruckInput
    truckStatusEvents?: TruckStatusEventUncheckedCreateNestedManyWithoutTruckInput
    gpsPositions?: GpsPositionUncheckedCreateNestedManyWithoutTruckInput
    tirePressureEvents?: TirePressureEventUncheckedCreateNestedManyWithoutTruckInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedCreateNestedManyWithoutTruckInput
    fuelLevelEvents?: FuelLevelEventUncheckedCreateNestedManyWithoutTruckInput
    speedEvents?: SpeedEventUncheckedCreateNestedManyWithoutTruckInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutTruckInput
    deviceStatusEvents?: DeviceStatusEventUncheckedCreateNestedManyWithoutTruckInput
    lockEvents?: LockEventUncheckedCreateNestedManyWithoutTruckInput
    dailyRoutes?: DailyRouteUncheckedCreateNestedManyWithoutTruckInput
  }

  export type TruckCreateOrConnectWithoutTripsInput = {
    where: TruckWhereUniqueInput
    create: XOR<TruckCreateWithoutTripsInput, TruckUncheckedCreateWithoutTripsInput>
  }

  export type TruckUpsertWithoutTripsInput = {
    update: XOR<TruckUpdateWithoutTripsInput, TruckUncheckedUpdateWithoutTripsInput>
    create: XOR<TruckCreateWithoutTripsInput, TruckUncheckedCreateWithoutTripsInput>
    where?: TruckWhereInput
  }

  export type TruckUpdateToOneWithWhereWithoutTripsInput = {
    where?: TruckWhereInput
    data: XOR<TruckUpdateWithoutTripsInput, TruckUncheckedUpdateWithoutTripsInput>
  }

  export type TruckUpdateWithoutTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    fleetGroup?: FleetGroupUpdateOneWithoutTrucksNestedInput
    devices?: DeviceUpdateManyWithoutTruckNestedInput
    truckStatusEvents?: TruckStatusEventUpdateManyWithoutTruckNestedInput
    gpsPositions?: GpsPositionUpdateManyWithoutTruckNestedInput
    tirePressureEvents?: TirePressureEventUpdateManyWithoutTruckNestedInput
    hubTemperatureEvents?: HubTemperatureEventUpdateManyWithoutTruckNestedInput
    fuelLevelEvents?: FuelLevelEventUpdateManyWithoutTruckNestedInput
    speedEvents?: SpeedEventUpdateManyWithoutTruckNestedInput
    alertEvents?: AlertEventUpdateManyWithoutTruckNestedInput
    deviceStatusEvents?: DeviceStatusEventUpdateManyWithoutTruckNestedInput
    lockEvents?: LockEventUpdateManyWithoutTruckNestedInput
    dailyRoutes?: DailyRouteUpdateManyWithoutTruckNestedInput
  }

  export type TruckUncheckedUpdateWithoutTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    fleetGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    devices?: DeviceUncheckedUpdateManyWithoutTruckNestedInput
    truckStatusEvents?: TruckStatusEventUncheckedUpdateManyWithoutTruckNestedInput
    gpsPositions?: GpsPositionUncheckedUpdateManyWithoutTruckNestedInput
    tirePressureEvents?: TirePressureEventUncheckedUpdateManyWithoutTruckNestedInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedUpdateManyWithoutTruckNestedInput
    fuelLevelEvents?: FuelLevelEventUncheckedUpdateManyWithoutTruckNestedInput
    speedEvents?: SpeedEventUncheckedUpdateManyWithoutTruckNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutTruckNestedInput
    deviceStatusEvents?: DeviceStatusEventUncheckedUpdateManyWithoutTruckNestedInput
    lockEvents?: LockEventUncheckedUpdateManyWithoutTruckNestedInput
    dailyRoutes?: DailyRouteUncheckedUpdateManyWithoutTruckNestedInput
  }

  export type DeviceCreateWithoutTirePressureEventsInput = {
    id?: string
    sn: string
    simNumber?: string | null
    installedAt?: Date | string
    removedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    truck: TruckCreateNestedOneWithoutDevicesInput
    sensors?: SensorCreateNestedManyWithoutDeviceInput
    gpsPositions?: GpsPositionCreateNestedManyWithoutDeviceInput
    hubTemperatureEvents?: HubTemperatureEventCreateNestedManyWithoutDeviceInput
    deviceStatusEvents?: DeviceStatusEventCreateNestedManyWithoutDeviceInput
    lockEvents?: LockEventCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutTirePressureEventsInput = {
    id?: string
    truckId: string
    sn: string
    simNumber?: string | null
    installedAt?: Date | string
    removedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    sensors?: SensorUncheckedCreateNestedManyWithoutDeviceInput
    gpsPositions?: GpsPositionUncheckedCreateNestedManyWithoutDeviceInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedCreateNestedManyWithoutDeviceInput
    deviceStatusEvents?: DeviceStatusEventUncheckedCreateNestedManyWithoutDeviceInput
    lockEvents?: LockEventUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutTirePressureEventsInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutTirePressureEventsInput, DeviceUncheckedCreateWithoutTirePressureEventsInput>
  }

  export type TruckCreateWithoutTirePressureEventsInput = {
    id?: string
    plateNumber: string
    vin?: string | null
    name?: string | null
    model?: string | null
    year?: number | null
    tireConfig?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    fleetGroup?: FleetGroupCreateNestedOneWithoutTrucksInput
    devices?: DeviceCreateNestedManyWithoutTruckInput
    truckStatusEvents?: TruckStatusEventCreateNestedManyWithoutTruckInput
    gpsPositions?: GpsPositionCreateNestedManyWithoutTruckInput
    trips?: TripCreateNestedManyWithoutTruckInput
    hubTemperatureEvents?: HubTemperatureEventCreateNestedManyWithoutTruckInput
    fuelLevelEvents?: FuelLevelEventCreateNestedManyWithoutTruckInput
    speedEvents?: SpeedEventCreateNestedManyWithoutTruckInput
    alertEvents?: AlertEventCreateNestedManyWithoutTruckInput
    deviceStatusEvents?: DeviceStatusEventCreateNestedManyWithoutTruckInput
    lockEvents?: LockEventCreateNestedManyWithoutTruckInput
    dailyRoutes?: DailyRouteCreateNestedManyWithoutTruckInput
  }

  export type TruckUncheckedCreateWithoutTirePressureEventsInput = {
    id?: string
    plateNumber: string
    vin?: string | null
    name?: string | null
    model?: string | null
    year?: number | null
    tireConfig?: string | null
    fleetGroupId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    devices?: DeviceUncheckedCreateNestedManyWithoutTruckInput
    truckStatusEvents?: TruckStatusEventUncheckedCreateNestedManyWithoutTruckInput
    gpsPositions?: GpsPositionUncheckedCreateNestedManyWithoutTruckInput
    trips?: TripUncheckedCreateNestedManyWithoutTruckInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedCreateNestedManyWithoutTruckInput
    fuelLevelEvents?: FuelLevelEventUncheckedCreateNestedManyWithoutTruckInput
    speedEvents?: SpeedEventUncheckedCreateNestedManyWithoutTruckInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutTruckInput
    deviceStatusEvents?: DeviceStatusEventUncheckedCreateNestedManyWithoutTruckInput
    lockEvents?: LockEventUncheckedCreateNestedManyWithoutTruckInput
    dailyRoutes?: DailyRouteUncheckedCreateNestedManyWithoutTruckInput
  }

  export type TruckCreateOrConnectWithoutTirePressureEventsInput = {
    where: TruckWhereUniqueInput
    create: XOR<TruckCreateWithoutTirePressureEventsInput, TruckUncheckedCreateWithoutTirePressureEventsInput>
  }

  export type DeviceUpsertWithoutTirePressureEventsInput = {
    update: XOR<DeviceUpdateWithoutTirePressureEventsInput, DeviceUncheckedUpdateWithoutTirePressureEventsInput>
    create: XOR<DeviceCreateWithoutTirePressureEventsInput, DeviceUncheckedCreateWithoutTirePressureEventsInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutTirePressureEventsInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutTirePressureEventsInput, DeviceUncheckedUpdateWithoutTirePressureEventsInput>
  }

  export type DeviceUpdateWithoutTirePressureEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sn?: StringFieldUpdateOperationsInput | string
    simNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    truck?: TruckUpdateOneRequiredWithoutDevicesNestedInput
    sensors?: SensorUpdateManyWithoutDeviceNestedInput
    gpsPositions?: GpsPositionUpdateManyWithoutDeviceNestedInput
    hubTemperatureEvents?: HubTemperatureEventUpdateManyWithoutDeviceNestedInput
    deviceStatusEvents?: DeviceStatusEventUpdateManyWithoutDeviceNestedInput
    lockEvents?: LockEventUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutTirePressureEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    sn?: StringFieldUpdateOperationsInput | string
    simNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sensors?: SensorUncheckedUpdateManyWithoutDeviceNestedInput
    gpsPositions?: GpsPositionUncheckedUpdateManyWithoutDeviceNestedInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedUpdateManyWithoutDeviceNestedInput
    deviceStatusEvents?: DeviceStatusEventUncheckedUpdateManyWithoutDeviceNestedInput
    lockEvents?: LockEventUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type TruckUpsertWithoutTirePressureEventsInput = {
    update: XOR<TruckUpdateWithoutTirePressureEventsInput, TruckUncheckedUpdateWithoutTirePressureEventsInput>
    create: XOR<TruckCreateWithoutTirePressureEventsInput, TruckUncheckedCreateWithoutTirePressureEventsInput>
    where?: TruckWhereInput
  }

  export type TruckUpdateToOneWithWhereWithoutTirePressureEventsInput = {
    where?: TruckWhereInput
    data: XOR<TruckUpdateWithoutTirePressureEventsInput, TruckUncheckedUpdateWithoutTirePressureEventsInput>
  }

  export type TruckUpdateWithoutTirePressureEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    fleetGroup?: FleetGroupUpdateOneWithoutTrucksNestedInput
    devices?: DeviceUpdateManyWithoutTruckNestedInput
    truckStatusEvents?: TruckStatusEventUpdateManyWithoutTruckNestedInput
    gpsPositions?: GpsPositionUpdateManyWithoutTruckNestedInput
    trips?: TripUpdateManyWithoutTruckNestedInput
    hubTemperatureEvents?: HubTemperatureEventUpdateManyWithoutTruckNestedInput
    fuelLevelEvents?: FuelLevelEventUpdateManyWithoutTruckNestedInput
    speedEvents?: SpeedEventUpdateManyWithoutTruckNestedInput
    alertEvents?: AlertEventUpdateManyWithoutTruckNestedInput
    deviceStatusEvents?: DeviceStatusEventUpdateManyWithoutTruckNestedInput
    lockEvents?: LockEventUpdateManyWithoutTruckNestedInput
    dailyRoutes?: DailyRouteUpdateManyWithoutTruckNestedInput
  }

  export type TruckUncheckedUpdateWithoutTirePressureEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    fleetGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    devices?: DeviceUncheckedUpdateManyWithoutTruckNestedInput
    truckStatusEvents?: TruckStatusEventUncheckedUpdateManyWithoutTruckNestedInput
    gpsPositions?: GpsPositionUncheckedUpdateManyWithoutTruckNestedInput
    trips?: TripUncheckedUpdateManyWithoutTruckNestedInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedUpdateManyWithoutTruckNestedInput
    fuelLevelEvents?: FuelLevelEventUncheckedUpdateManyWithoutTruckNestedInput
    speedEvents?: SpeedEventUncheckedUpdateManyWithoutTruckNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutTruckNestedInput
    deviceStatusEvents?: DeviceStatusEventUncheckedUpdateManyWithoutTruckNestedInput
    lockEvents?: LockEventUncheckedUpdateManyWithoutTruckNestedInput
    dailyRoutes?: DailyRouteUncheckedUpdateManyWithoutTruckNestedInput
  }

  export type DeviceCreateWithoutHubTemperatureEventsInput = {
    id?: string
    sn: string
    simNumber?: string | null
    installedAt?: Date | string
    removedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    truck: TruckCreateNestedOneWithoutDevicesInput
    sensors?: SensorCreateNestedManyWithoutDeviceInput
    gpsPositions?: GpsPositionCreateNestedManyWithoutDeviceInput
    tirePressureEvents?: TirePressureEventCreateNestedManyWithoutDeviceInput
    deviceStatusEvents?: DeviceStatusEventCreateNestedManyWithoutDeviceInput
    lockEvents?: LockEventCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutHubTemperatureEventsInput = {
    id?: string
    truckId: string
    sn: string
    simNumber?: string | null
    installedAt?: Date | string
    removedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    sensors?: SensorUncheckedCreateNestedManyWithoutDeviceInput
    gpsPositions?: GpsPositionUncheckedCreateNestedManyWithoutDeviceInput
    tirePressureEvents?: TirePressureEventUncheckedCreateNestedManyWithoutDeviceInput
    deviceStatusEvents?: DeviceStatusEventUncheckedCreateNestedManyWithoutDeviceInput
    lockEvents?: LockEventUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutHubTemperatureEventsInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutHubTemperatureEventsInput, DeviceUncheckedCreateWithoutHubTemperatureEventsInput>
  }

  export type TruckCreateWithoutHubTemperatureEventsInput = {
    id?: string
    plateNumber: string
    vin?: string | null
    name?: string | null
    model?: string | null
    year?: number | null
    tireConfig?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    fleetGroup?: FleetGroupCreateNestedOneWithoutTrucksInput
    devices?: DeviceCreateNestedManyWithoutTruckInput
    truckStatusEvents?: TruckStatusEventCreateNestedManyWithoutTruckInput
    gpsPositions?: GpsPositionCreateNestedManyWithoutTruckInput
    trips?: TripCreateNestedManyWithoutTruckInput
    tirePressureEvents?: TirePressureEventCreateNestedManyWithoutTruckInput
    fuelLevelEvents?: FuelLevelEventCreateNestedManyWithoutTruckInput
    speedEvents?: SpeedEventCreateNestedManyWithoutTruckInput
    alertEvents?: AlertEventCreateNestedManyWithoutTruckInput
    deviceStatusEvents?: DeviceStatusEventCreateNestedManyWithoutTruckInput
    lockEvents?: LockEventCreateNestedManyWithoutTruckInput
    dailyRoutes?: DailyRouteCreateNestedManyWithoutTruckInput
  }

  export type TruckUncheckedCreateWithoutHubTemperatureEventsInput = {
    id?: string
    plateNumber: string
    vin?: string | null
    name?: string | null
    model?: string | null
    year?: number | null
    tireConfig?: string | null
    fleetGroupId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    devices?: DeviceUncheckedCreateNestedManyWithoutTruckInput
    truckStatusEvents?: TruckStatusEventUncheckedCreateNestedManyWithoutTruckInput
    gpsPositions?: GpsPositionUncheckedCreateNestedManyWithoutTruckInput
    trips?: TripUncheckedCreateNestedManyWithoutTruckInput
    tirePressureEvents?: TirePressureEventUncheckedCreateNestedManyWithoutTruckInput
    fuelLevelEvents?: FuelLevelEventUncheckedCreateNestedManyWithoutTruckInput
    speedEvents?: SpeedEventUncheckedCreateNestedManyWithoutTruckInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutTruckInput
    deviceStatusEvents?: DeviceStatusEventUncheckedCreateNestedManyWithoutTruckInput
    lockEvents?: LockEventUncheckedCreateNestedManyWithoutTruckInput
    dailyRoutes?: DailyRouteUncheckedCreateNestedManyWithoutTruckInput
  }

  export type TruckCreateOrConnectWithoutHubTemperatureEventsInput = {
    where: TruckWhereUniqueInput
    create: XOR<TruckCreateWithoutHubTemperatureEventsInput, TruckUncheckedCreateWithoutHubTemperatureEventsInput>
  }

  export type DeviceUpsertWithoutHubTemperatureEventsInput = {
    update: XOR<DeviceUpdateWithoutHubTemperatureEventsInput, DeviceUncheckedUpdateWithoutHubTemperatureEventsInput>
    create: XOR<DeviceCreateWithoutHubTemperatureEventsInput, DeviceUncheckedCreateWithoutHubTemperatureEventsInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutHubTemperatureEventsInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutHubTemperatureEventsInput, DeviceUncheckedUpdateWithoutHubTemperatureEventsInput>
  }

  export type DeviceUpdateWithoutHubTemperatureEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sn?: StringFieldUpdateOperationsInput | string
    simNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    truck?: TruckUpdateOneRequiredWithoutDevicesNestedInput
    sensors?: SensorUpdateManyWithoutDeviceNestedInput
    gpsPositions?: GpsPositionUpdateManyWithoutDeviceNestedInput
    tirePressureEvents?: TirePressureEventUpdateManyWithoutDeviceNestedInput
    deviceStatusEvents?: DeviceStatusEventUpdateManyWithoutDeviceNestedInput
    lockEvents?: LockEventUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutHubTemperatureEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    sn?: StringFieldUpdateOperationsInput | string
    simNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sensors?: SensorUncheckedUpdateManyWithoutDeviceNestedInput
    gpsPositions?: GpsPositionUncheckedUpdateManyWithoutDeviceNestedInput
    tirePressureEvents?: TirePressureEventUncheckedUpdateManyWithoutDeviceNestedInput
    deviceStatusEvents?: DeviceStatusEventUncheckedUpdateManyWithoutDeviceNestedInput
    lockEvents?: LockEventUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type TruckUpsertWithoutHubTemperatureEventsInput = {
    update: XOR<TruckUpdateWithoutHubTemperatureEventsInput, TruckUncheckedUpdateWithoutHubTemperatureEventsInput>
    create: XOR<TruckCreateWithoutHubTemperatureEventsInput, TruckUncheckedCreateWithoutHubTemperatureEventsInput>
    where?: TruckWhereInput
  }

  export type TruckUpdateToOneWithWhereWithoutHubTemperatureEventsInput = {
    where?: TruckWhereInput
    data: XOR<TruckUpdateWithoutHubTemperatureEventsInput, TruckUncheckedUpdateWithoutHubTemperatureEventsInput>
  }

  export type TruckUpdateWithoutHubTemperatureEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    fleetGroup?: FleetGroupUpdateOneWithoutTrucksNestedInput
    devices?: DeviceUpdateManyWithoutTruckNestedInput
    truckStatusEvents?: TruckStatusEventUpdateManyWithoutTruckNestedInput
    gpsPositions?: GpsPositionUpdateManyWithoutTruckNestedInput
    trips?: TripUpdateManyWithoutTruckNestedInput
    tirePressureEvents?: TirePressureEventUpdateManyWithoutTruckNestedInput
    fuelLevelEvents?: FuelLevelEventUpdateManyWithoutTruckNestedInput
    speedEvents?: SpeedEventUpdateManyWithoutTruckNestedInput
    alertEvents?: AlertEventUpdateManyWithoutTruckNestedInput
    deviceStatusEvents?: DeviceStatusEventUpdateManyWithoutTruckNestedInput
    lockEvents?: LockEventUpdateManyWithoutTruckNestedInput
    dailyRoutes?: DailyRouteUpdateManyWithoutTruckNestedInput
  }

  export type TruckUncheckedUpdateWithoutHubTemperatureEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    fleetGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    devices?: DeviceUncheckedUpdateManyWithoutTruckNestedInput
    truckStatusEvents?: TruckStatusEventUncheckedUpdateManyWithoutTruckNestedInput
    gpsPositions?: GpsPositionUncheckedUpdateManyWithoutTruckNestedInput
    trips?: TripUncheckedUpdateManyWithoutTruckNestedInput
    tirePressureEvents?: TirePressureEventUncheckedUpdateManyWithoutTruckNestedInput
    fuelLevelEvents?: FuelLevelEventUncheckedUpdateManyWithoutTruckNestedInput
    speedEvents?: SpeedEventUncheckedUpdateManyWithoutTruckNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutTruckNestedInput
    deviceStatusEvents?: DeviceStatusEventUncheckedUpdateManyWithoutTruckNestedInput
    lockEvents?: LockEventUncheckedUpdateManyWithoutTruckNestedInput
    dailyRoutes?: DailyRouteUncheckedUpdateManyWithoutTruckNestedInput
  }

  export type TruckCreateWithoutFuelLevelEventsInput = {
    id?: string
    plateNumber: string
    vin?: string | null
    name?: string | null
    model?: string | null
    year?: number | null
    tireConfig?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    fleetGroup?: FleetGroupCreateNestedOneWithoutTrucksInput
    devices?: DeviceCreateNestedManyWithoutTruckInput
    truckStatusEvents?: TruckStatusEventCreateNestedManyWithoutTruckInput
    gpsPositions?: GpsPositionCreateNestedManyWithoutTruckInput
    trips?: TripCreateNestedManyWithoutTruckInput
    tirePressureEvents?: TirePressureEventCreateNestedManyWithoutTruckInput
    hubTemperatureEvents?: HubTemperatureEventCreateNestedManyWithoutTruckInput
    speedEvents?: SpeedEventCreateNestedManyWithoutTruckInput
    alertEvents?: AlertEventCreateNestedManyWithoutTruckInput
    deviceStatusEvents?: DeviceStatusEventCreateNestedManyWithoutTruckInput
    lockEvents?: LockEventCreateNestedManyWithoutTruckInput
    dailyRoutes?: DailyRouteCreateNestedManyWithoutTruckInput
  }

  export type TruckUncheckedCreateWithoutFuelLevelEventsInput = {
    id?: string
    plateNumber: string
    vin?: string | null
    name?: string | null
    model?: string | null
    year?: number | null
    tireConfig?: string | null
    fleetGroupId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    devices?: DeviceUncheckedCreateNestedManyWithoutTruckInput
    truckStatusEvents?: TruckStatusEventUncheckedCreateNestedManyWithoutTruckInput
    gpsPositions?: GpsPositionUncheckedCreateNestedManyWithoutTruckInput
    trips?: TripUncheckedCreateNestedManyWithoutTruckInput
    tirePressureEvents?: TirePressureEventUncheckedCreateNestedManyWithoutTruckInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedCreateNestedManyWithoutTruckInput
    speedEvents?: SpeedEventUncheckedCreateNestedManyWithoutTruckInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutTruckInput
    deviceStatusEvents?: DeviceStatusEventUncheckedCreateNestedManyWithoutTruckInput
    lockEvents?: LockEventUncheckedCreateNestedManyWithoutTruckInput
    dailyRoutes?: DailyRouteUncheckedCreateNestedManyWithoutTruckInput
  }

  export type TruckCreateOrConnectWithoutFuelLevelEventsInput = {
    where: TruckWhereUniqueInput
    create: XOR<TruckCreateWithoutFuelLevelEventsInput, TruckUncheckedCreateWithoutFuelLevelEventsInput>
  }

  export type TruckUpsertWithoutFuelLevelEventsInput = {
    update: XOR<TruckUpdateWithoutFuelLevelEventsInput, TruckUncheckedUpdateWithoutFuelLevelEventsInput>
    create: XOR<TruckCreateWithoutFuelLevelEventsInput, TruckUncheckedCreateWithoutFuelLevelEventsInput>
    where?: TruckWhereInput
  }

  export type TruckUpdateToOneWithWhereWithoutFuelLevelEventsInput = {
    where?: TruckWhereInput
    data: XOR<TruckUpdateWithoutFuelLevelEventsInput, TruckUncheckedUpdateWithoutFuelLevelEventsInput>
  }

  export type TruckUpdateWithoutFuelLevelEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    fleetGroup?: FleetGroupUpdateOneWithoutTrucksNestedInput
    devices?: DeviceUpdateManyWithoutTruckNestedInput
    truckStatusEvents?: TruckStatusEventUpdateManyWithoutTruckNestedInput
    gpsPositions?: GpsPositionUpdateManyWithoutTruckNestedInput
    trips?: TripUpdateManyWithoutTruckNestedInput
    tirePressureEvents?: TirePressureEventUpdateManyWithoutTruckNestedInput
    hubTemperatureEvents?: HubTemperatureEventUpdateManyWithoutTruckNestedInput
    speedEvents?: SpeedEventUpdateManyWithoutTruckNestedInput
    alertEvents?: AlertEventUpdateManyWithoutTruckNestedInput
    deviceStatusEvents?: DeviceStatusEventUpdateManyWithoutTruckNestedInput
    lockEvents?: LockEventUpdateManyWithoutTruckNestedInput
    dailyRoutes?: DailyRouteUpdateManyWithoutTruckNestedInput
  }

  export type TruckUncheckedUpdateWithoutFuelLevelEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    fleetGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    devices?: DeviceUncheckedUpdateManyWithoutTruckNestedInput
    truckStatusEvents?: TruckStatusEventUncheckedUpdateManyWithoutTruckNestedInput
    gpsPositions?: GpsPositionUncheckedUpdateManyWithoutTruckNestedInput
    trips?: TripUncheckedUpdateManyWithoutTruckNestedInput
    tirePressureEvents?: TirePressureEventUncheckedUpdateManyWithoutTruckNestedInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedUpdateManyWithoutTruckNestedInput
    speedEvents?: SpeedEventUncheckedUpdateManyWithoutTruckNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutTruckNestedInput
    deviceStatusEvents?: DeviceStatusEventUncheckedUpdateManyWithoutTruckNestedInput
    lockEvents?: LockEventUncheckedUpdateManyWithoutTruckNestedInput
    dailyRoutes?: DailyRouteUncheckedUpdateManyWithoutTruckNestedInput
  }

  export type TruckCreateWithoutSpeedEventsInput = {
    id?: string
    plateNumber: string
    vin?: string | null
    name?: string | null
    model?: string | null
    year?: number | null
    tireConfig?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    fleetGroup?: FleetGroupCreateNestedOneWithoutTrucksInput
    devices?: DeviceCreateNestedManyWithoutTruckInput
    truckStatusEvents?: TruckStatusEventCreateNestedManyWithoutTruckInput
    gpsPositions?: GpsPositionCreateNestedManyWithoutTruckInput
    trips?: TripCreateNestedManyWithoutTruckInput
    tirePressureEvents?: TirePressureEventCreateNestedManyWithoutTruckInput
    hubTemperatureEvents?: HubTemperatureEventCreateNestedManyWithoutTruckInput
    fuelLevelEvents?: FuelLevelEventCreateNestedManyWithoutTruckInput
    alertEvents?: AlertEventCreateNestedManyWithoutTruckInput
    deviceStatusEvents?: DeviceStatusEventCreateNestedManyWithoutTruckInput
    lockEvents?: LockEventCreateNestedManyWithoutTruckInput
    dailyRoutes?: DailyRouteCreateNestedManyWithoutTruckInput
  }

  export type TruckUncheckedCreateWithoutSpeedEventsInput = {
    id?: string
    plateNumber: string
    vin?: string | null
    name?: string | null
    model?: string | null
    year?: number | null
    tireConfig?: string | null
    fleetGroupId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    devices?: DeviceUncheckedCreateNestedManyWithoutTruckInput
    truckStatusEvents?: TruckStatusEventUncheckedCreateNestedManyWithoutTruckInput
    gpsPositions?: GpsPositionUncheckedCreateNestedManyWithoutTruckInput
    trips?: TripUncheckedCreateNestedManyWithoutTruckInput
    tirePressureEvents?: TirePressureEventUncheckedCreateNestedManyWithoutTruckInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedCreateNestedManyWithoutTruckInput
    fuelLevelEvents?: FuelLevelEventUncheckedCreateNestedManyWithoutTruckInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutTruckInput
    deviceStatusEvents?: DeviceStatusEventUncheckedCreateNestedManyWithoutTruckInput
    lockEvents?: LockEventUncheckedCreateNestedManyWithoutTruckInput
    dailyRoutes?: DailyRouteUncheckedCreateNestedManyWithoutTruckInput
  }

  export type TruckCreateOrConnectWithoutSpeedEventsInput = {
    where: TruckWhereUniqueInput
    create: XOR<TruckCreateWithoutSpeedEventsInput, TruckUncheckedCreateWithoutSpeedEventsInput>
  }

  export type TruckUpsertWithoutSpeedEventsInput = {
    update: XOR<TruckUpdateWithoutSpeedEventsInput, TruckUncheckedUpdateWithoutSpeedEventsInput>
    create: XOR<TruckCreateWithoutSpeedEventsInput, TruckUncheckedCreateWithoutSpeedEventsInput>
    where?: TruckWhereInput
  }

  export type TruckUpdateToOneWithWhereWithoutSpeedEventsInput = {
    where?: TruckWhereInput
    data: XOR<TruckUpdateWithoutSpeedEventsInput, TruckUncheckedUpdateWithoutSpeedEventsInput>
  }

  export type TruckUpdateWithoutSpeedEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    fleetGroup?: FleetGroupUpdateOneWithoutTrucksNestedInput
    devices?: DeviceUpdateManyWithoutTruckNestedInput
    truckStatusEvents?: TruckStatusEventUpdateManyWithoutTruckNestedInput
    gpsPositions?: GpsPositionUpdateManyWithoutTruckNestedInput
    trips?: TripUpdateManyWithoutTruckNestedInput
    tirePressureEvents?: TirePressureEventUpdateManyWithoutTruckNestedInput
    hubTemperatureEvents?: HubTemperatureEventUpdateManyWithoutTruckNestedInput
    fuelLevelEvents?: FuelLevelEventUpdateManyWithoutTruckNestedInput
    alertEvents?: AlertEventUpdateManyWithoutTruckNestedInput
    deviceStatusEvents?: DeviceStatusEventUpdateManyWithoutTruckNestedInput
    lockEvents?: LockEventUpdateManyWithoutTruckNestedInput
    dailyRoutes?: DailyRouteUpdateManyWithoutTruckNestedInput
  }

  export type TruckUncheckedUpdateWithoutSpeedEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    fleetGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    devices?: DeviceUncheckedUpdateManyWithoutTruckNestedInput
    truckStatusEvents?: TruckStatusEventUncheckedUpdateManyWithoutTruckNestedInput
    gpsPositions?: GpsPositionUncheckedUpdateManyWithoutTruckNestedInput
    trips?: TripUncheckedUpdateManyWithoutTruckNestedInput
    tirePressureEvents?: TirePressureEventUncheckedUpdateManyWithoutTruckNestedInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedUpdateManyWithoutTruckNestedInput
    fuelLevelEvents?: FuelLevelEventUncheckedUpdateManyWithoutTruckNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutTruckNestedInput
    deviceStatusEvents?: DeviceStatusEventUncheckedUpdateManyWithoutTruckNestedInput
    lockEvents?: LockEventUncheckedUpdateManyWithoutTruckNestedInput
    dailyRoutes?: DailyRouteUncheckedUpdateManyWithoutTruckNestedInput
  }

  export type TruckCreateWithoutAlertEventsInput = {
    id?: string
    plateNumber: string
    vin?: string | null
    name?: string | null
    model?: string | null
    year?: number | null
    tireConfig?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    fleetGroup?: FleetGroupCreateNestedOneWithoutTrucksInput
    devices?: DeviceCreateNestedManyWithoutTruckInput
    truckStatusEvents?: TruckStatusEventCreateNestedManyWithoutTruckInput
    gpsPositions?: GpsPositionCreateNestedManyWithoutTruckInput
    trips?: TripCreateNestedManyWithoutTruckInput
    tirePressureEvents?: TirePressureEventCreateNestedManyWithoutTruckInput
    hubTemperatureEvents?: HubTemperatureEventCreateNestedManyWithoutTruckInput
    fuelLevelEvents?: FuelLevelEventCreateNestedManyWithoutTruckInput
    speedEvents?: SpeedEventCreateNestedManyWithoutTruckInput
    deviceStatusEvents?: DeviceStatusEventCreateNestedManyWithoutTruckInput
    lockEvents?: LockEventCreateNestedManyWithoutTruckInput
    dailyRoutes?: DailyRouteCreateNestedManyWithoutTruckInput
  }

  export type TruckUncheckedCreateWithoutAlertEventsInput = {
    id?: string
    plateNumber: string
    vin?: string | null
    name?: string | null
    model?: string | null
    year?: number | null
    tireConfig?: string | null
    fleetGroupId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    devices?: DeviceUncheckedCreateNestedManyWithoutTruckInput
    truckStatusEvents?: TruckStatusEventUncheckedCreateNestedManyWithoutTruckInput
    gpsPositions?: GpsPositionUncheckedCreateNestedManyWithoutTruckInput
    trips?: TripUncheckedCreateNestedManyWithoutTruckInput
    tirePressureEvents?: TirePressureEventUncheckedCreateNestedManyWithoutTruckInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedCreateNestedManyWithoutTruckInput
    fuelLevelEvents?: FuelLevelEventUncheckedCreateNestedManyWithoutTruckInput
    speedEvents?: SpeedEventUncheckedCreateNestedManyWithoutTruckInput
    deviceStatusEvents?: DeviceStatusEventUncheckedCreateNestedManyWithoutTruckInput
    lockEvents?: LockEventUncheckedCreateNestedManyWithoutTruckInput
    dailyRoutes?: DailyRouteUncheckedCreateNestedManyWithoutTruckInput
  }

  export type TruckCreateOrConnectWithoutAlertEventsInput = {
    where: TruckWhereUniqueInput
    create: XOR<TruckCreateWithoutAlertEventsInput, TruckUncheckedCreateWithoutAlertEventsInput>
  }

  export type TruckUpsertWithoutAlertEventsInput = {
    update: XOR<TruckUpdateWithoutAlertEventsInput, TruckUncheckedUpdateWithoutAlertEventsInput>
    create: XOR<TruckCreateWithoutAlertEventsInput, TruckUncheckedCreateWithoutAlertEventsInput>
    where?: TruckWhereInput
  }

  export type TruckUpdateToOneWithWhereWithoutAlertEventsInput = {
    where?: TruckWhereInput
    data: XOR<TruckUpdateWithoutAlertEventsInput, TruckUncheckedUpdateWithoutAlertEventsInput>
  }

  export type TruckUpdateWithoutAlertEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    fleetGroup?: FleetGroupUpdateOneWithoutTrucksNestedInput
    devices?: DeviceUpdateManyWithoutTruckNestedInput
    truckStatusEvents?: TruckStatusEventUpdateManyWithoutTruckNestedInput
    gpsPositions?: GpsPositionUpdateManyWithoutTruckNestedInput
    trips?: TripUpdateManyWithoutTruckNestedInput
    tirePressureEvents?: TirePressureEventUpdateManyWithoutTruckNestedInput
    hubTemperatureEvents?: HubTemperatureEventUpdateManyWithoutTruckNestedInput
    fuelLevelEvents?: FuelLevelEventUpdateManyWithoutTruckNestedInput
    speedEvents?: SpeedEventUpdateManyWithoutTruckNestedInput
    deviceStatusEvents?: DeviceStatusEventUpdateManyWithoutTruckNestedInput
    lockEvents?: LockEventUpdateManyWithoutTruckNestedInput
    dailyRoutes?: DailyRouteUpdateManyWithoutTruckNestedInput
  }

  export type TruckUncheckedUpdateWithoutAlertEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    fleetGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    devices?: DeviceUncheckedUpdateManyWithoutTruckNestedInput
    truckStatusEvents?: TruckStatusEventUncheckedUpdateManyWithoutTruckNestedInput
    gpsPositions?: GpsPositionUncheckedUpdateManyWithoutTruckNestedInput
    trips?: TripUncheckedUpdateManyWithoutTruckNestedInput
    tirePressureEvents?: TirePressureEventUncheckedUpdateManyWithoutTruckNestedInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedUpdateManyWithoutTruckNestedInput
    fuelLevelEvents?: FuelLevelEventUncheckedUpdateManyWithoutTruckNestedInput
    speedEvents?: SpeedEventUncheckedUpdateManyWithoutTruckNestedInput
    deviceStatusEvents?: DeviceStatusEventUncheckedUpdateManyWithoutTruckNestedInput
    lockEvents?: LockEventUncheckedUpdateManyWithoutTruckNestedInput
    dailyRoutes?: DailyRouteUncheckedUpdateManyWithoutTruckNestedInput
  }

  export type DeviceCreateWithoutDeviceStatusEventsInput = {
    id?: string
    sn: string
    simNumber?: string | null
    installedAt?: Date | string
    removedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    truck: TruckCreateNestedOneWithoutDevicesInput
    sensors?: SensorCreateNestedManyWithoutDeviceInput
    gpsPositions?: GpsPositionCreateNestedManyWithoutDeviceInput
    tirePressureEvents?: TirePressureEventCreateNestedManyWithoutDeviceInput
    hubTemperatureEvents?: HubTemperatureEventCreateNestedManyWithoutDeviceInput
    lockEvents?: LockEventCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutDeviceStatusEventsInput = {
    id?: string
    truckId: string
    sn: string
    simNumber?: string | null
    installedAt?: Date | string
    removedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    sensors?: SensorUncheckedCreateNestedManyWithoutDeviceInput
    gpsPositions?: GpsPositionUncheckedCreateNestedManyWithoutDeviceInput
    tirePressureEvents?: TirePressureEventUncheckedCreateNestedManyWithoutDeviceInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedCreateNestedManyWithoutDeviceInput
    lockEvents?: LockEventUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutDeviceStatusEventsInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutDeviceStatusEventsInput, DeviceUncheckedCreateWithoutDeviceStatusEventsInput>
  }

  export type TruckCreateWithoutDeviceStatusEventsInput = {
    id?: string
    plateNumber: string
    vin?: string | null
    name?: string | null
    model?: string | null
    year?: number | null
    tireConfig?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    fleetGroup?: FleetGroupCreateNestedOneWithoutTrucksInput
    devices?: DeviceCreateNestedManyWithoutTruckInput
    truckStatusEvents?: TruckStatusEventCreateNestedManyWithoutTruckInput
    gpsPositions?: GpsPositionCreateNestedManyWithoutTruckInput
    trips?: TripCreateNestedManyWithoutTruckInput
    tirePressureEvents?: TirePressureEventCreateNestedManyWithoutTruckInput
    hubTemperatureEvents?: HubTemperatureEventCreateNestedManyWithoutTruckInput
    fuelLevelEvents?: FuelLevelEventCreateNestedManyWithoutTruckInput
    speedEvents?: SpeedEventCreateNestedManyWithoutTruckInput
    alertEvents?: AlertEventCreateNestedManyWithoutTruckInput
    lockEvents?: LockEventCreateNestedManyWithoutTruckInput
    dailyRoutes?: DailyRouteCreateNestedManyWithoutTruckInput
  }

  export type TruckUncheckedCreateWithoutDeviceStatusEventsInput = {
    id?: string
    plateNumber: string
    vin?: string | null
    name?: string | null
    model?: string | null
    year?: number | null
    tireConfig?: string | null
    fleetGroupId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    devices?: DeviceUncheckedCreateNestedManyWithoutTruckInput
    truckStatusEvents?: TruckStatusEventUncheckedCreateNestedManyWithoutTruckInput
    gpsPositions?: GpsPositionUncheckedCreateNestedManyWithoutTruckInput
    trips?: TripUncheckedCreateNestedManyWithoutTruckInput
    tirePressureEvents?: TirePressureEventUncheckedCreateNestedManyWithoutTruckInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedCreateNestedManyWithoutTruckInput
    fuelLevelEvents?: FuelLevelEventUncheckedCreateNestedManyWithoutTruckInput
    speedEvents?: SpeedEventUncheckedCreateNestedManyWithoutTruckInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutTruckInput
    lockEvents?: LockEventUncheckedCreateNestedManyWithoutTruckInput
    dailyRoutes?: DailyRouteUncheckedCreateNestedManyWithoutTruckInput
  }

  export type TruckCreateOrConnectWithoutDeviceStatusEventsInput = {
    where: TruckWhereUniqueInput
    create: XOR<TruckCreateWithoutDeviceStatusEventsInput, TruckUncheckedCreateWithoutDeviceStatusEventsInput>
  }

  export type DeviceUpsertWithoutDeviceStatusEventsInput = {
    update: XOR<DeviceUpdateWithoutDeviceStatusEventsInput, DeviceUncheckedUpdateWithoutDeviceStatusEventsInput>
    create: XOR<DeviceCreateWithoutDeviceStatusEventsInput, DeviceUncheckedCreateWithoutDeviceStatusEventsInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutDeviceStatusEventsInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutDeviceStatusEventsInput, DeviceUncheckedUpdateWithoutDeviceStatusEventsInput>
  }

  export type DeviceUpdateWithoutDeviceStatusEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sn?: StringFieldUpdateOperationsInput | string
    simNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    truck?: TruckUpdateOneRequiredWithoutDevicesNestedInput
    sensors?: SensorUpdateManyWithoutDeviceNestedInput
    gpsPositions?: GpsPositionUpdateManyWithoutDeviceNestedInput
    tirePressureEvents?: TirePressureEventUpdateManyWithoutDeviceNestedInput
    hubTemperatureEvents?: HubTemperatureEventUpdateManyWithoutDeviceNestedInput
    lockEvents?: LockEventUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutDeviceStatusEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    sn?: StringFieldUpdateOperationsInput | string
    simNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sensors?: SensorUncheckedUpdateManyWithoutDeviceNestedInput
    gpsPositions?: GpsPositionUncheckedUpdateManyWithoutDeviceNestedInput
    tirePressureEvents?: TirePressureEventUncheckedUpdateManyWithoutDeviceNestedInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedUpdateManyWithoutDeviceNestedInput
    lockEvents?: LockEventUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type TruckUpsertWithoutDeviceStatusEventsInput = {
    update: XOR<TruckUpdateWithoutDeviceStatusEventsInput, TruckUncheckedUpdateWithoutDeviceStatusEventsInput>
    create: XOR<TruckCreateWithoutDeviceStatusEventsInput, TruckUncheckedCreateWithoutDeviceStatusEventsInput>
    where?: TruckWhereInput
  }

  export type TruckUpdateToOneWithWhereWithoutDeviceStatusEventsInput = {
    where?: TruckWhereInput
    data: XOR<TruckUpdateWithoutDeviceStatusEventsInput, TruckUncheckedUpdateWithoutDeviceStatusEventsInput>
  }

  export type TruckUpdateWithoutDeviceStatusEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    fleetGroup?: FleetGroupUpdateOneWithoutTrucksNestedInput
    devices?: DeviceUpdateManyWithoutTruckNestedInput
    truckStatusEvents?: TruckStatusEventUpdateManyWithoutTruckNestedInput
    gpsPositions?: GpsPositionUpdateManyWithoutTruckNestedInput
    trips?: TripUpdateManyWithoutTruckNestedInput
    tirePressureEvents?: TirePressureEventUpdateManyWithoutTruckNestedInput
    hubTemperatureEvents?: HubTemperatureEventUpdateManyWithoutTruckNestedInput
    fuelLevelEvents?: FuelLevelEventUpdateManyWithoutTruckNestedInput
    speedEvents?: SpeedEventUpdateManyWithoutTruckNestedInput
    alertEvents?: AlertEventUpdateManyWithoutTruckNestedInput
    lockEvents?: LockEventUpdateManyWithoutTruckNestedInput
    dailyRoutes?: DailyRouteUpdateManyWithoutTruckNestedInput
  }

  export type TruckUncheckedUpdateWithoutDeviceStatusEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    fleetGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    devices?: DeviceUncheckedUpdateManyWithoutTruckNestedInput
    truckStatusEvents?: TruckStatusEventUncheckedUpdateManyWithoutTruckNestedInput
    gpsPositions?: GpsPositionUncheckedUpdateManyWithoutTruckNestedInput
    trips?: TripUncheckedUpdateManyWithoutTruckNestedInput
    tirePressureEvents?: TirePressureEventUncheckedUpdateManyWithoutTruckNestedInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedUpdateManyWithoutTruckNestedInput
    fuelLevelEvents?: FuelLevelEventUncheckedUpdateManyWithoutTruckNestedInput
    speedEvents?: SpeedEventUncheckedUpdateManyWithoutTruckNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutTruckNestedInput
    lockEvents?: LockEventUncheckedUpdateManyWithoutTruckNestedInput
    dailyRoutes?: DailyRouteUncheckedUpdateManyWithoutTruckNestedInput
  }

  export type DeviceCreateWithoutLockEventsInput = {
    id?: string
    sn: string
    simNumber?: string | null
    installedAt?: Date | string
    removedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    truck: TruckCreateNestedOneWithoutDevicesInput
    sensors?: SensorCreateNestedManyWithoutDeviceInput
    gpsPositions?: GpsPositionCreateNestedManyWithoutDeviceInput
    tirePressureEvents?: TirePressureEventCreateNestedManyWithoutDeviceInput
    hubTemperatureEvents?: HubTemperatureEventCreateNestedManyWithoutDeviceInput
    deviceStatusEvents?: DeviceStatusEventCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutLockEventsInput = {
    id?: string
    truckId: string
    sn: string
    simNumber?: string | null
    installedAt?: Date | string
    removedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    sensors?: SensorUncheckedCreateNestedManyWithoutDeviceInput
    gpsPositions?: GpsPositionUncheckedCreateNestedManyWithoutDeviceInput
    tirePressureEvents?: TirePressureEventUncheckedCreateNestedManyWithoutDeviceInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedCreateNestedManyWithoutDeviceInput
    deviceStatusEvents?: DeviceStatusEventUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutLockEventsInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutLockEventsInput, DeviceUncheckedCreateWithoutLockEventsInput>
  }

  export type TruckCreateWithoutLockEventsInput = {
    id?: string
    plateNumber: string
    vin?: string | null
    name?: string | null
    model?: string | null
    year?: number | null
    tireConfig?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    fleetGroup?: FleetGroupCreateNestedOneWithoutTrucksInput
    devices?: DeviceCreateNestedManyWithoutTruckInput
    truckStatusEvents?: TruckStatusEventCreateNestedManyWithoutTruckInput
    gpsPositions?: GpsPositionCreateNestedManyWithoutTruckInput
    trips?: TripCreateNestedManyWithoutTruckInput
    tirePressureEvents?: TirePressureEventCreateNestedManyWithoutTruckInput
    hubTemperatureEvents?: HubTemperatureEventCreateNestedManyWithoutTruckInput
    fuelLevelEvents?: FuelLevelEventCreateNestedManyWithoutTruckInput
    speedEvents?: SpeedEventCreateNestedManyWithoutTruckInput
    alertEvents?: AlertEventCreateNestedManyWithoutTruckInput
    deviceStatusEvents?: DeviceStatusEventCreateNestedManyWithoutTruckInput
    dailyRoutes?: DailyRouteCreateNestedManyWithoutTruckInput
  }

  export type TruckUncheckedCreateWithoutLockEventsInput = {
    id?: string
    plateNumber: string
    vin?: string | null
    name?: string | null
    model?: string | null
    year?: number | null
    tireConfig?: string | null
    fleetGroupId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    devices?: DeviceUncheckedCreateNestedManyWithoutTruckInput
    truckStatusEvents?: TruckStatusEventUncheckedCreateNestedManyWithoutTruckInput
    gpsPositions?: GpsPositionUncheckedCreateNestedManyWithoutTruckInput
    trips?: TripUncheckedCreateNestedManyWithoutTruckInput
    tirePressureEvents?: TirePressureEventUncheckedCreateNestedManyWithoutTruckInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedCreateNestedManyWithoutTruckInput
    fuelLevelEvents?: FuelLevelEventUncheckedCreateNestedManyWithoutTruckInput
    speedEvents?: SpeedEventUncheckedCreateNestedManyWithoutTruckInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutTruckInput
    deviceStatusEvents?: DeviceStatusEventUncheckedCreateNestedManyWithoutTruckInput
    dailyRoutes?: DailyRouteUncheckedCreateNestedManyWithoutTruckInput
  }

  export type TruckCreateOrConnectWithoutLockEventsInput = {
    where: TruckWhereUniqueInput
    create: XOR<TruckCreateWithoutLockEventsInput, TruckUncheckedCreateWithoutLockEventsInput>
  }

  export type DeviceUpsertWithoutLockEventsInput = {
    update: XOR<DeviceUpdateWithoutLockEventsInput, DeviceUncheckedUpdateWithoutLockEventsInput>
    create: XOR<DeviceCreateWithoutLockEventsInput, DeviceUncheckedCreateWithoutLockEventsInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutLockEventsInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutLockEventsInput, DeviceUncheckedUpdateWithoutLockEventsInput>
  }

  export type DeviceUpdateWithoutLockEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sn?: StringFieldUpdateOperationsInput | string
    simNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    truck?: TruckUpdateOneRequiredWithoutDevicesNestedInput
    sensors?: SensorUpdateManyWithoutDeviceNestedInput
    gpsPositions?: GpsPositionUpdateManyWithoutDeviceNestedInput
    tirePressureEvents?: TirePressureEventUpdateManyWithoutDeviceNestedInput
    hubTemperatureEvents?: HubTemperatureEventUpdateManyWithoutDeviceNestedInput
    deviceStatusEvents?: DeviceStatusEventUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutLockEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    sn?: StringFieldUpdateOperationsInput | string
    simNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sensors?: SensorUncheckedUpdateManyWithoutDeviceNestedInput
    gpsPositions?: GpsPositionUncheckedUpdateManyWithoutDeviceNestedInput
    tirePressureEvents?: TirePressureEventUncheckedUpdateManyWithoutDeviceNestedInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedUpdateManyWithoutDeviceNestedInput
    deviceStatusEvents?: DeviceStatusEventUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type TruckUpsertWithoutLockEventsInput = {
    update: XOR<TruckUpdateWithoutLockEventsInput, TruckUncheckedUpdateWithoutLockEventsInput>
    create: XOR<TruckCreateWithoutLockEventsInput, TruckUncheckedCreateWithoutLockEventsInput>
    where?: TruckWhereInput
  }

  export type TruckUpdateToOneWithWhereWithoutLockEventsInput = {
    where?: TruckWhereInput
    data: XOR<TruckUpdateWithoutLockEventsInput, TruckUncheckedUpdateWithoutLockEventsInput>
  }

  export type TruckUpdateWithoutLockEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    fleetGroup?: FleetGroupUpdateOneWithoutTrucksNestedInput
    devices?: DeviceUpdateManyWithoutTruckNestedInput
    truckStatusEvents?: TruckStatusEventUpdateManyWithoutTruckNestedInput
    gpsPositions?: GpsPositionUpdateManyWithoutTruckNestedInput
    trips?: TripUpdateManyWithoutTruckNestedInput
    tirePressureEvents?: TirePressureEventUpdateManyWithoutTruckNestedInput
    hubTemperatureEvents?: HubTemperatureEventUpdateManyWithoutTruckNestedInput
    fuelLevelEvents?: FuelLevelEventUpdateManyWithoutTruckNestedInput
    speedEvents?: SpeedEventUpdateManyWithoutTruckNestedInput
    alertEvents?: AlertEventUpdateManyWithoutTruckNestedInput
    deviceStatusEvents?: DeviceStatusEventUpdateManyWithoutTruckNestedInput
    dailyRoutes?: DailyRouteUpdateManyWithoutTruckNestedInput
  }

  export type TruckUncheckedUpdateWithoutLockEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    fleetGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    devices?: DeviceUncheckedUpdateManyWithoutTruckNestedInput
    truckStatusEvents?: TruckStatusEventUncheckedUpdateManyWithoutTruckNestedInput
    gpsPositions?: GpsPositionUncheckedUpdateManyWithoutTruckNestedInput
    trips?: TripUncheckedUpdateManyWithoutTruckNestedInput
    tirePressureEvents?: TirePressureEventUncheckedUpdateManyWithoutTruckNestedInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedUpdateManyWithoutTruckNestedInput
    fuelLevelEvents?: FuelLevelEventUncheckedUpdateManyWithoutTruckNestedInput
    speedEvents?: SpeedEventUncheckedUpdateManyWithoutTruckNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutTruckNestedInput
    deviceStatusEvents?: DeviceStatusEventUncheckedUpdateManyWithoutTruckNestedInput
    dailyRoutes?: DailyRouteUncheckedUpdateManyWithoutTruckNestedInput
  }

  export type TruckCreateWithoutDailyRoutesInput = {
    id?: string
    plateNumber: string
    vin?: string | null
    name?: string | null
    model?: string | null
    year?: number | null
    tireConfig?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    fleetGroup?: FleetGroupCreateNestedOneWithoutTrucksInput
    devices?: DeviceCreateNestedManyWithoutTruckInput
    truckStatusEvents?: TruckStatusEventCreateNestedManyWithoutTruckInput
    gpsPositions?: GpsPositionCreateNestedManyWithoutTruckInput
    trips?: TripCreateNestedManyWithoutTruckInput
    tirePressureEvents?: TirePressureEventCreateNestedManyWithoutTruckInput
    hubTemperatureEvents?: HubTemperatureEventCreateNestedManyWithoutTruckInput
    fuelLevelEvents?: FuelLevelEventCreateNestedManyWithoutTruckInput
    speedEvents?: SpeedEventCreateNestedManyWithoutTruckInput
    alertEvents?: AlertEventCreateNestedManyWithoutTruckInput
    deviceStatusEvents?: DeviceStatusEventCreateNestedManyWithoutTruckInput
    lockEvents?: LockEventCreateNestedManyWithoutTruckInput
  }

  export type TruckUncheckedCreateWithoutDailyRoutesInput = {
    id?: string
    plateNumber: string
    vin?: string | null
    name?: string | null
    model?: string | null
    year?: number | null
    tireConfig?: string | null
    fleetGroupId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    devices?: DeviceUncheckedCreateNestedManyWithoutTruckInput
    truckStatusEvents?: TruckStatusEventUncheckedCreateNestedManyWithoutTruckInput
    gpsPositions?: GpsPositionUncheckedCreateNestedManyWithoutTruckInput
    trips?: TripUncheckedCreateNestedManyWithoutTruckInput
    tirePressureEvents?: TirePressureEventUncheckedCreateNestedManyWithoutTruckInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedCreateNestedManyWithoutTruckInput
    fuelLevelEvents?: FuelLevelEventUncheckedCreateNestedManyWithoutTruckInput
    speedEvents?: SpeedEventUncheckedCreateNestedManyWithoutTruckInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutTruckInput
    deviceStatusEvents?: DeviceStatusEventUncheckedCreateNestedManyWithoutTruckInput
    lockEvents?: LockEventUncheckedCreateNestedManyWithoutTruckInput
  }

  export type TruckCreateOrConnectWithoutDailyRoutesInput = {
    where: TruckWhereUniqueInput
    create: XOR<TruckCreateWithoutDailyRoutesInput, TruckUncheckedCreateWithoutDailyRoutesInput>
  }

  export type TruckUpsertWithoutDailyRoutesInput = {
    update: XOR<TruckUpdateWithoutDailyRoutesInput, TruckUncheckedUpdateWithoutDailyRoutesInput>
    create: XOR<TruckCreateWithoutDailyRoutesInput, TruckUncheckedCreateWithoutDailyRoutesInput>
    where?: TruckWhereInput
  }

  export type TruckUpdateToOneWithWhereWithoutDailyRoutesInput = {
    where?: TruckWhereInput
    data: XOR<TruckUpdateWithoutDailyRoutesInput, TruckUncheckedUpdateWithoutDailyRoutesInput>
  }

  export type TruckUpdateWithoutDailyRoutesInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    fleetGroup?: FleetGroupUpdateOneWithoutTrucksNestedInput
    devices?: DeviceUpdateManyWithoutTruckNestedInput
    truckStatusEvents?: TruckStatusEventUpdateManyWithoutTruckNestedInput
    gpsPositions?: GpsPositionUpdateManyWithoutTruckNestedInput
    trips?: TripUpdateManyWithoutTruckNestedInput
    tirePressureEvents?: TirePressureEventUpdateManyWithoutTruckNestedInput
    hubTemperatureEvents?: HubTemperatureEventUpdateManyWithoutTruckNestedInput
    fuelLevelEvents?: FuelLevelEventUpdateManyWithoutTruckNestedInput
    speedEvents?: SpeedEventUpdateManyWithoutTruckNestedInput
    alertEvents?: AlertEventUpdateManyWithoutTruckNestedInput
    deviceStatusEvents?: DeviceStatusEventUpdateManyWithoutTruckNestedInput
    lockEvents?: LockEventUpdateManyWithoutTruckNestedInput
  }

  export type TruckUncheckedUpdateWithoutDailyRoutesInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    fleetGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    devices?: DeviceUncheckedUpdateManyWithoutTruckNestedInput
    truckStatusEvents?: TruckStatusEventUncheckedUpdateManyWithoutTruckNestedInput
    gpsPositions?: GpsPositionUncheckedUpdateManyWithoutTruckNestedInput
    trips?: TripUncheckedUpdateManyWithoutTruckNestedInput
    tirePressureEvents?: TirePressureEventUncheckedUpdateManyWithoutTruckNestedInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedUpdateManyWithoutTruckNestedInput
    fuelLevelEvents?: FuelLevelEventUncheckedUpdateManyWithoutTruckNestedInput
    speedEvents?: SpeedEventUncheckedUpdateManyWithoutTruckNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutTruckNestedInput
    deviceStatusEvents?: DeviceStatusEventUncheckedUpdateManyWithoutTruckNestedInput
    lockEvents?: LockEventUncheckedUpdateManyWithoutTruckNestedInput
  }

  export type TruckCreateManyFleetGroupInput = {
    id?: string
    plateNumber: string
    vin?: string | null
    name?: string | null
    model?: string | null
    year?: number | null
    tireConfig?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type TruckUpdateWithoutFleetGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    devices?: DeviceUpdateManyWithoutTruckNestedInput
    truckStatusEvents?: TruckStatusEventUpdateManyWithoutTruckNestedInput
    gpsPositions?: GpsPositionUpdateManyWithoutTruckNestedInput
    trips?: TripUpdateManyWithoutTruckNestedInput
    tirePressureEvents?: TirePressureEventUpdateManyWithoutTruckNestedInput
    hubTemperatureEvents?: HubTemperatureEventUpdateManyWithoutTruckNestedInput
    fuelLevelEvents?: FuelLevelEventUpdateManyWithoutTruckNestedInput
    speedEvents?: SpeedEventUpdateManyWithoutTruckNestedInput
    alertEvents?: AlertEventUpdateManyWithoutTruckNestedInput
    deviceStatusEvents?: DeviceStatusEventUpdateManyWithoutTruckNestedInput
    lockEvents?: LockEventUpdateManyWithoutTruckNestedInput
    dailyRoutes?: DailyRouteUpdateManyWithoutTruckNestedInput
  }

  export type TruckUncheckedUpdateWithoutFleetGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    devices?: DeviceUncheckedUpdateManyWithoutTruckNestedInput
    truckStatusEvents?: TruckStatusEventUncheckedUpdateManyWithoutTruckNestedInput
    gpsPositions?: GpsPositionUncheckedUpdateManyWithoutTruckNestedInput
    trips?: TripUncheckedUpdateManyWithoutTruckNestedInput
    tirePressureEvents?: TirePressureEventUncheckedUpdateManyWithoutTruckNestedInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedUpdateManyWithoutTruckNestedInput
    fuelLevelEvents?: FuelLevelEventUncheckedUpdateManyWithoutTruckNestedInput
    speedEvents?: SpeedEventUncheckedUpdateManyWithoutTruckNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutTruckNestedInput
    deviceStatusEvents?: DeviceStatusEventUncheckedUpdateManyWithoutTruckNestedInput
    lockEvents?: LockEventUncheckedUpdateManyWithoutTruckNestedInput
    dailyRoutes?: DailyRouteUncheckedUpdateManyWithoutTruckNestedInput
  }

  export type TruckUncheckedUpdateManyWithoutFleetGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    plateNumber?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    tireConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeviceCreateManyTruckInput = {
    id?: string
    sn: string
    simNumber?: string | null
    installedAt?: Date | string
    removedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type TruckStatusEventCreateManyTruckInput = {
    id?: string
    status: $Enums.TruckStatus
    note?: string | null
    changedAt?: Date | string
    createdBy?: string | null
  }

  export type GpsPositionCreateManyTruckInput = {
    id?: bigint | number
    deviceId?: string | null
    ts: Date | string
    speedKph?: number | null
    headingDeg?: number | null
    hdop?: number | null
    source?: string | null
  }

  export type TripCreateManyTruckInput = {
    id?: string
    startTs: Date | string
    endTs?: Date | string | null
  }

  export type TirePressureEventCreateManyTruckInput = {
    id?: string
    deviceId: string
    tireNo: number
    pressureKpa?: number | null
    tempCelsius?: number | null
    exType?: string | null
    batteryLevel?: number | null
    changedAt?: Date | string
    createdBy?: string | null
  }

  export type HubTemperatureEventCreateManyTruckInput = {
    id?: string
    deviceId: string
    hubNo?: number | null
    tempCelsius?: number | null
    exType?: string | null
    batteryLevel?: number | null
    changedAt?: Date | string
    createdBy?: string | null
  }

  export type FuelLevelEventCreateManyTruckInput = {
    id?: string
    fuelPercent?: number | null
    changedAt: Date | string
    source?: string | null
    createdBy?: string | null
  }

  export type SpeedEventCreateManyTruckInput = {
    id?: string
    speedKph?: number | null
    changedAt: Date | string
    source?: string | null
    createdBy?: string | null
  }

  export type AlertEventCreateManyTruckInput = {
    id?: string
    type: $Enums.AlertType
    severity?: number | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: Date | string
    acknowledged?: boolean
    createdBy?: string | null
  }

  export type DeviceStatusEventCreateManyTruckInput = {
    id?: string
    deviceId: string
    hostBat?: number | null
    repeater1Bat?: number | null
    repeater2Bat?: number | null
    lockState?: number | null
    reportedAt?: Date | string
    createdBy?: string | null
  }

  export type LockEventCreateManyTruckInput = {
    id?: string
    deviceId: string
    isLock?: number | null
    reportedAt?: Date | string
    createdBy?: string | null
  }

  export type DailyRouteCreateManyTruckInput = {
    id?: string
    routeDate: Date | string
    pointCount: number
    generatedAt?: Date | string
    createdBy?: string | null
  }

  export type DeviceUpdateWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    sn?: StringFieldUpdateOperationsInput | string
    simNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sensors?: SensorUpdateManyWithoutDeviceNestedInput
    gpsPositions?: GpsPositionUpdateManyWithoutDeviceNestedInput
    tirePressureEvents?: TirePressureEventUpdateManyWithoutDeviceNestedInput
    hubTemperatureEvents?: HubTemperatureEventUpdateManyWithoutDeviceNestedInput
    deviceStatusEvents?: DeviceStatusEventUpdateManyWithoutDeviceNestedInput
    lockEvents?: LockEventUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    sn?: StringFieldUpdateOperationsInput | string
    simNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sensors?: SensorUncheckedUpdateManyWithoutDeviceNestedInput
    gpsPositions?: GpsPositionUncheckedUpdateManyWithoutDeviceNestedInput
    tirePressureEvents?: TirePressureEventUncheckedUpdateManyWithoutDeviceNestedInput
    hubTemperatureEvents?: HubTemperatureEventUncheckedUpdateManyWithoutDeviceNestedInput
    deviceStatusEvents?: DeviceStatusEventUncheckedUpdateManyWithoutDeviceNestedInput
    lockEvents?: LockEventUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateManyWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    sn?: StringFieldUpdateOperationsInput | string
    simNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TruckStatusEventUpdateWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTruckStatusFieldUpdateOperationsInput | $Enums.TruckStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TruckStatusEventUncheckedUpdateWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTruckStatusFieldUpdateOperationsInput | $Enums.TruckStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TruckStatusEventUncheckedUpdateManyWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTruckStatusFieldUpdateOperationsInput | $Enums.TruckStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GpsPositionUpdateWithoutTruckInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    speedKph?: NullableFloatFieldUpdateOperationsInput | number | null
    headingDeg?: NullableFloatFieldUpdateOperationsInput | number | null
    hdop?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    device?: DeviceUpdateOneWithoutGpsPositionsNestedInput
  }

  export type GpsPositionUncheckedUpdateWithoutTruckInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    speedKph?: NullableFloatFieldUpdateOperationsInput | number | null
    headingDeg?: NullableFloatFieldUpdateOperationsInput | number | null
    hdop?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GpsPositionUncheckedUpdateManyWithoutTruckInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    speedKph?: NullableFloatFieldUpdateOperationsInput | number | null
    headingDeg?: NullableFloatFieldUpdateOperationsInput | number | null
    hdop?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TripUpdateWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripUncheckedUpdateWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripUncheckedUpdateManyWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TirePressureEventUpdateWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    tireNo?: IntFieldUpdateOperationsInput | number
    pressureKpa?: NullableFloatFieldUpdateOperationsInput | number | null
    tempCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    exType?: NullableStringFieldUpdateOperationsInput | string | null
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    device?: DeviceUpdateOneRequiredWithoutTirePressureEventsNestedInput
  }

  export type TirePressureEventUncheckedUpdateWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    tireNo?: IntFieldUpdateOperationsInput | number
    pressureKpa?: NullableFloatFieldUpdateOperationsInput | number | null
    tempCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    exType?: NullableStringFieldUpdateOperationsInput | string | null
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TirePressureEventUncheckedUpdateManyWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    tireNo?: IntFieldUpdateOperationsInput | number
    pressureKpa?: NullableFloatFieldUpdateOperationsInput | number | null
    tempCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    exType?: NullableStringFieldUpdateOperationsInput | string | null
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HubTemperatureEventUpdateWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    hubNo?: NullableIntFieldUpdateOperationsInput | number | null
    tempCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    exType?: NullableStringFieldUpdateOperationsInput | string | null
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    device?: DeviceUpdateOneRequiredWithoutHubTemperatureEventsNestedInput
  }

  export type HubTemperatureEventUncheckedUpdateWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    hubNo?: NullableIntFieldUpdateOperationsInput | number | null
    tempCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    exType?: NullableStringFieldUpdateOperationsInput | string | null
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HubTemperatureEventUncheckedUpdateManyWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    hubNo?: NullableIntFieldUpdateOperationsInput | number | null
    tempCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    exType?: NullableStringFieldUpdateOperationsInput | string | null
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FuelLevelEventUpdateWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    fuelPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FuelLevelEventUncheckedUpdateWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    fuelPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FuelLevelEventUncheckedUpdateManyWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    fuelPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpeedEventUpdateWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    speedKph?: NullableFloatFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpeedEventUncheckedUpdateWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    speedKph?: NullableFloatFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpeedEventUncheckedUpdateManyWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    speedKph?: NullableFloatFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertEventUpdateWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    severity?: NullableIntFieldUpdateOperationsInput | number | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertEventUncheckedUpdateWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    severity?: NullableIntFieldUpdateOperationsInput | number | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertEventUncheckedUpdateManyWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    severity?: NullableIntFieldUpdateOperationsInput | number | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeviceStatusEventUpdateWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    hostBat?: NullableIntFieldUpdateOperationsInput | number | null
    repeater1Bat?: NullableIntFieldUpdateOperationsInput | number | null
    repeater2Bat?: NullableIntFieldUpdateOperationsInput | number | null
    lockState?: NullableIntFieldUpdateOperationsInput | number | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    device?: DeviceUpdateOneRequiredWithoutDeviceStatusEventsNestedInput
  }

  export type DeviceStatusEventUncheckedUpdateWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    hostBat?: NullableIntFieldUpdateOperationsInput | number | null
    repeater1Bat?: NullableIntFieldUpdateOperationsInput | number | null
    repeater2Bat?: NullableIntFieldUpdateOperationsInput | number | null
    lockState?: NullableIntFieldUpdateOperationsInput | number | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeviceStatusEventUncheckedUpdateManyWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    hostBat?: NullableIntFieldUpdateOperationsInput | number | null
    repeater1Bat?: NullableIntFieldUpdateOperationsInput | number | null
    repeater2Bat?: NullableIntFieldUpdateOperationsInput | number | null
    lockState?: NullableIntFieldUpdateOperationsInput | number | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LockEventUpdateWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLock?: NullableIntFieldUpdateOperationsInput | number | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    device?: DeviceUpdateOneRequiredWithoutLockEventsNestedInput
  }

  export type LockEventUncheckedUpdateWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    isLock?: NullableIntFieldUpdateOperationsInput | number | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LockEventUncheckedUpdateManyWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    isLock?: NullableIntFieldUpdateOperationsInput | number | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DailyRouteUpdateWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pointCount?: IntFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DailyRouteUncheckedUpdateWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pointCount?: IntFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DailyRouteUncheckedUpdateManyWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pointCount?: IntFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SensorCreateManyDeviceInput = {
    id?: string
    type: string
    positionNo: number
    sn?: string | null
    installedAt?: Date | string | null
    removedAt?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type GpsPositionCreateManyDeviceInput = {
    id?: bigint | number
    truckId: string
    ts: Date | string
    speedKph?: number | null
    headingDeg?: number | null
    hdop?: number | null
    source?: string | null
  }

  export type TirePressureEventCreateManyDeviceInput = {
    id?: string
    truckId: string
    tireNo: number
    pressureKpa?: number | null
    tempCelsius?: number | null
    exType?: string | null
    batteryLevel?: number | null
    changedAt?: Date | string
    createdBy?: string | null
  }

  export type HubTemperatureEventCreateManyDeviceInput = {
    id?: string
    truckId: string
    hubNo?: number | null
    tempCelsius?: number | null
    exType?: string | null
    batteryLevel?: number | null
    changedAt?: Date | string
    createdBy?: string | null
  }

  export type DeviceStatusEventCreateManyDeviceInput = {
    id?: string
    truckId: string
    hostBat?: number | null
    repeater1Bat?: number | null
    repeater2Bat?: number | null
    lockState?: number | null
    reportedAt?: Date | string
    createdBy?: string | null
  }

  export type LockEventCreateManyDeviceInput = {
    id?: string
    truckId: string
    isLock?: number | null
    reportedAt?: Date | string
    createdBy?: string | null
  }

  export type SensorUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    positionNo?: IntFieldUpdateOperationsInput | number
    sn?: NullableStringFieldUpdateOperationsInput | string | null
    installedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SensorUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    positionNo?: IntFieldUpdateOperationsInput | number
    sn?: NullableStringFieldUpdateOperationsInput | string | null
    installedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SensorUncheckedUpdateManyWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    positionNo?: IntFieldUpdateOperationsInput | number
    sn?: NullableStringFieldUpdateOperationsInput | string | null
    installedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GpsPositionUpdateWithoutDeviceInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    speedKph?: NullableFloatFieldUpdateOperationsInput | number | null
    headingDeg?: NullableFloatFieldUpdateOperationsInput | number | null
    hdop?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    truck?: TruckUpdateOneRequiredWithoutGpsPositionsNestedInput
  }

  export type GpsPositionUncheckedUpdateWithoutDeviceInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    truckId?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    speedKph?: NullableFloatFieldUpdateOperationsInput | number | null
    headingDeg?: NullableFloatFieldUpdateOperationsInput | number | null
    hdop?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GpsPositionUncheckedUpdateManyWithoutDeviceInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    truckId?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    speedKph?: NullableFloatFieldUpdateOperationsInput | number | null
    headingDeg?: NullableFloatFieldUpdateOperationsInput | number | null
    hdop?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TirePressureEventUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tireNo?: IntFieldUpdateOperationsInput | number
    pressureKpa?: NullableFloatFieldUpdateOperationsInput | number | null
    tempCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    exType?: NullableStringFieldUpdateOperationsInput | string | null
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    truck?: TruckUpdateOneRequiredWithoutTirePressureEventsNestedInput
  }

  export type TirePressureEventUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    tireNo?: IntFieldUpdateOperationsInput | number
    pressureKpa?: NullableFloatFieldUpdateOperationsInput | number | null
    tempCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    exType?: NullableStringFieldUpdateOperationsInput | string | null
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TirePressureEventUncheckedUpdateManyWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    tireNo?: IntFieldUpdateOperationsInput | number
    pressureKpa?: NullableFloatFieldUpdateOperationsInput | number | null
    tempCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    exType?: NullableStringFieldUpdateOperationsInput | string | null
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HubTemperatureEventUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    hubNo?: NullableIntFieldUpdateOperationsInput | number | null
    tempCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    exType?: NullableStringFieldUpdateOperationsInput | string | null
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    truck?: TruckUpdateOneRequiredWithoutHubTemperatureEventsNestedInput
  }

  export type HubTemperatureEventUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    hubNo?: NullableIntFieldUpdateOperationsInput | number | null
    tempCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    exType?: NullableStringFieldUpdateOperationsInput | string | null
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HubTemperatureEventUncheckedUpdateManyWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    hubNo?: NullableIntFieldUpdateOperationsInput | number | null
    tempCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    exType?: NullableStringFieldUpdateOperationsInput | string | null
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeviceStatusEventUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    hostBat?: NullableIntFieldUpdateOperationsInput | number | null
    repeater1Bat?: NullableIntFieldUpdateOperationsInput | number | null
    repeater2Bat?: NullableIntFieldUpdateOperationsInput | number | null
    lockState?: NullableIntFieldUpdateOperationsInput | number | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    truck?: TruckUpdateOneRequiredWithoutDeviceStatusEventsNestedInput
  }

  export type DeviceStatusEventUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    hostBat?: NullableIntFieldUpdateOperationsInput | number | null
    repeater1Bat?: NullableIntFieldUpdateOperationsInput | number | null
    repeater2Bat?: NullableIntFieldUpdateOperationsInput | number | null
    lockState?: NullableIntFieldUpdateOperationsInput | number | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeviceStatusEventUncheckedUpdateManyWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    hostBat?: NullableIntFieldUpdateOperationsInput | number | null
    repeater1Bat?: NullableIntFieldUpdateOperationsInput | number | null
    repeater2Bat?: NullableIntFieldUpdateOperationsInput | number | null
    lockState?: NullableIntFieldUpdateOperationsInput | number | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LockEventUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLock?: NullableIntFieldUpdateOperationsInput | number | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    truck?: TruckUpdateOneRequiredWithoutLockEventsNestedInput
  }

  export type LockEventUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    isLock?: NullableIntFieldUpdateOperationsInput | number | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LockEventUncheckedUpdateManyWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckId?: StringFieldUpdateOperationsInput | string
    isLock?: NullableIntFieldUpdateOperationsInput | number | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use FleetGroupCountOutputTypeDefaultArgs instead
     */
    export type FleetGroupCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FleetGroupCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TruckCountOutputTypeDefaultArgs instead
     */
    export type TruckCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TruckCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeviceCountOutputTypeDefaultArgs instead
     */
    export type DeviceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeviceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FleetGroupDefaultArgs instead
     */
    export type FleetGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FleetGroupDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TruckDefaultArgs instead
     */
    export type TruckArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TruckDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeviceDefaultArgs instead
     */
    export type DeviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeviceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SensorDefaultArgs instead
     */
    export type SensorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SensorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TruckStatusEventDefaultArgs instead
     */
    export type TruckStatusEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TruckStatusEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GeofenceDefaultArgs instead
     */
    export type GeofenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GeofenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GpsPositionDefaultArgs instead
     */
    export type GpsPositionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GpsPositionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TripDefaultArgs instead
     */
    export type TripArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TripDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TirePressureEventDefaultArgs instead
     */
    export type TirePressureEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TirePressureEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TireErrorCodeDefaultArgs instead
     */
    export type TireErrorCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TireErrorCodeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HubTemperatureEventDefaultArgs instead
     */
    export type HubTemperatureEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HubTemperatureEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FuelLevelEventDefaultArgs instead
     */
    export type FuelLevelEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FuelLevelEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpeedEventDefaultArgs instead
     */
    export type SpeedEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpeedEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlertEventDefaultArgs instead
     */
    export type AlertEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlertEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeviceStatusEventDefaultArgs instead
     */
    export type DeviceStatusEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeviceStatusEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LockEventDefaultArgs instead
     */
    export type LockEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LockEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DailyRouteDefaultArgs instead
     */
    export type DailyRouteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DailyRouteDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}